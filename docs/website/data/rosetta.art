[
	"100 doors"
 	{
		isOpen: map 1..101 => false
		 
		loop 1..100 'pass ->
			loop (range.step:pass pass 100) 'door [
				set isOpen door not? isOpen \ door
			]
		
		loop 1..100 'x ->
			if isOpen \ x [
				print ["Door" x "is open."]
			]
	}
 	"99 bottles of beer"
 	{
		s: "s"
		
		loop 99..1 'i [
		    print ~"|i| bottle|s| of beer on the wall,"
		    print ~"|i| bottle|s| of beer"
		    print ~"Take one down, pass it around!"
		    if 1=i-1 -> s: ""
		
		    if? i>1 [
		        print ~"|i-1| bottle|s| of beer on the wall!"
		        print ""
		    ]
		    else -> print "No more bottles of beer on the wall!"
		]
	}
 	"abc problem"
 	{
		blocks: map [
		    [B O] [X K] [D Q] [C P] [N A] [G T] [R E] 
		    [T G] [Q D] [F S] [J W] [H U] [V I] [A N] 
		    [O B] [E R] [F S] [L Y] [P C] [Z M]
		] => [ join map & => [to :string]]
		
		charInBlock: function [ch,bl][
		    loop.with:'i bl 'b ->
		        if contains? b upper ch [
		            return i
		        ]
		    return ø
		]
		
		canMakeWord?: function [wrd][
		    ref: new blocks
		    loop split wrd 'chr [
		        cib: charInBlock chr ref
		        if? cib = ø [ return false ]
		        else        [ ref: remove ref .index cib ]
		    ]
		    return true
		]
		
		loop ["A" "BaRk" "bOoK" "tReAt" "CoMmOn" "SqUaD" "cONfUsE"] 'wrd
		    -> print [wrd "=>" canMakeWord? wrd]
	}
 	"abundant, deficient and perfect number classifications"
 	{
		properDivisors: function [n]->
		    (factors n) -- n
		
		abundant: new 0 deficient: new 0 perfect: new 0
		
		loop 1..20000 'x [
		    s: sum properDivisors x
		
		    case [s]
		        when? [<x] -> inc 'deficient
		        when? [>x] -> inc 'abundant
		        else       -> inc 'perfect
		]
		
		print ["Found" abundant "abundant," 
		               deficient "deficient and" 
		               perfect "perfect numbers."]
	}
 	"align columns"
 	{
		text: {
		    Given$a$text$file$of$many$lines,$where$fields$within$a$line$
		    are$delineated$by$a$single$'dollar'$character,$write$a$program
		    that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
		    column$are$separated$by$at$least$one$space.
		    Further,$allow$for$each$word$in$a$column$to$be$either$left$
		    justified,$right$justified,$or$center$justified$within$its$column.
		}
		
		output: map split.lines text => [split.by:"$"]
		
		loop output 'line [
		    loop line 'word -> prints pad word 12
		    print ""
		]
	}
 	"amicable pairs"
 	{
		properDivs: function [x] ->
		    (factors x) -- x
		
		amicable: function [x][
		    y: sum properDivs x 
		    if and? x = sum properDivs y 
		            x <> y 
		        -> return @[x,y]
		    return ø
		]
		
		amicables: []
		
		loop 1..20000 'n [
		    am: amicable n
		    if am <> ø 
		        -> 'amicables ++ @[sort am]
		]
		
		print unique amicables
	}
 	"apply a callback to an array"
 	{
		arr: [1 2 3 4 5]
		
		print map arr => [2*]
	}
 	"array concatenation"
 	{
		arr1: [1 2 3]
		arr2: ["four" "five" "six"]
		 
		print arr1 ++ arr2
	}
 	"array length"
 	{
		fruit: ["apple" "orange"]
		
		print ["array length =" size fruit]
	}
 	"arrays"
 	{
		; empty  array
		arrA: []
		 
		; array with initial values
		arrB: ["one" "two" "three"]
		 
		; adding an element to an existing array
		arrB: arrB ++ "four"
		print arrB
		 
		; another way to add an element
		append 'arrB "five"
		print arrB
		 
		; retrieve an element at some index
		print arrB\1
	}
 	"assertions"
 	{
		a: 42
		ensure [a = 42]
	}
 	"associative array - creation"
 	{
		; create a dictionary
		d: #[
			name: 		"john"
			surname: 	"doe"
			age: 		34
		]
		
		print d
	}
 	"associative array - iteration"
 	{
		; create a dictionary
		d: #[
			name: 		"john"
			surname: 	"doe"
			age: 		34
		]
		
		; Iterate over key/value pairs
		loop d [key,value][
			print ["key =" key ", value =" value]
		]
		
		print "----"
		
		; Iterate over keys
		loop keys d [k][
			print ["key =" k]
		]
		
		print "----"
		
		; Iterate over values
		loop values d [v][
			print ["value =" v]
		]
	}
 	"associative array - merging"
 	{
		details: #[name: "Rocket Skates" price: 12.75 colour: 'yellow]
		newDetails: extend details #[price: 15.25 colour: 'red year: 1974]
		
		print newDetails
	}
 	"averages - arithmetic mean"
 	{
		arr: [1 2 3 4 5 6 7]
		 
		print average arr
	}
 	"averages - median"
 	{
		arr:  [1 2 3 4 5 6 7]
		arr2: [1 2 3 4 5 6]
		 
		print median arr
		print median arr2
	}
 	"averages - mode"
 	{
		getMode: function [arr][
		    freqs: new #[]
		    loop arr 'i [
		        k: to :string i
		        if not? key? freqs k -> set freqs k 0
		        set freqs k (freqs \ k) + 1
		    ]
		    maximum: max values freqs
		    select keys freqs 'i -> maximum = freqs \ i
		]
		 
		print getMode [1 3 6 6 6 6 7 7 12 12 17]
		print getMode [1 1 2 4 4]
	}
 	"averages - pythagorean means"
 	{
		arithmeticMean: function [arr]->
		    average arr
		
		geometricMean: function [arr]->
		    (product arr) ^ 1//size arr 
		
		harmonicMean: function [arr]->
		    (size arr) // sum map arr 'i [1//i]
		
		print arithmeticMean 1..10
		print geometricMean 1..10
		print harmonicMean 1..10
	}
 	"averages - root mean square"
 	{
		rootMeanSquare: function [arr]->
		    sqrt (sum map arr 'i -> i^2) // size arr
		
		print rootMeanSquare 1..10
	}
 	"base64 decode data"
 	{
		text: "VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g="
		
		print decode text
	}
 	"bell numbers"
 	{
		bellTriangle: function[n][
		    tri: map 0..n-1 'x [ map 0..n 'y -> 0 ]
		    set tri \ 1 0 1
		    loop 2..n-1 'i [
		        set tri \ i 0  (tri \ i-1) \ i-2
		        loop 1..i-1 'j [
		            set tri \ i j ((tri \ i)\j-1) + ((tri \ i-1)\j-1)
		        ]
		    ]
		    return tri
		]
		bt: bellTriangle 51
		
		loop 1..15 'x ->
		    print [x "=>" first bt \ x]
		print ["50 =>" first last bt]
		print ""
		print "The first ten rows of Bell's triangle:"
		
		loop 1..10 'i ->
		    print filter bt \ i => zero?
	}
 	"binary digits"
 	{
		print as.binary 5
		print as.binary 50
		print as.binary 9000
	}
 	"binary search"
 	{
		binarySearch: function [arr,val,low,high][
		    if high < low -> return ø
		    mid: shr low+high 1
		    case [val]
		        when? [< arr \ mid] -> return binarySearch arr val low mid-1
		        when? [> arr \ mid] -> return binarySearch arr val mid+1 high
		        else                -> return mid
		]
		
		ary: [
		    0 1 4 5 6 7 8 9 12 26 45 67 
		    78 90 98 123 211 234 456 769 
		    865 2345 3215 14345 24324
		]
		
		loop [0 42 45 24324 99999] 'v [
		    i: binarySearch ary v 0 (size ary)-1
		    if? not? null? i    -> print ["found" v "at index:" i]
		    else                -> print [v "not found"]
		]
	}
 	"binary strings"
 	{
		; creation
		x: "this is a string"
		y: "this is another string"
		z: "this is a string"
		 
		; comparison
		if x = z -> print "x is z"
		 
		; assignment
		z: "now this is another string too"
		 
		; copying reference
		y: z 
		
		; copying value
		y: new z
		
		; check if empty
		if? empty? x -> print "empty"
		else         -> print "not empty"
		
		; append a string
		'x ++ "!"
		
		print x
		
		; substrings
		print slice x 5 8
		
		; join strings
		z: x ++ y
		print z
		
		; replace occurrences of substring
		print replace z "t" "T"
	}
 	"bitwise operations"
 	{
		a: 255
		b: 2
		
		print [a "AND" b "=" and a b]
		print [a "OR" b "=" or a b]
		print [a "XOR" b "=" xor a b]
		print ["NOT" a "=" not a]
		print [a "SHL" b "=" shl a b]
		print [a "SHR" b "=" shr a b]
	}
 	"boolean values"
 	{
		a: true
		b: false
		
		if? a [ print "yep" ] else [ print "nope" ]
		
		if? b -> print "nope" 
		else  -> print "yep"
	}
 	"calculating the value of e"
 	{
		fact: 1
		e: 2.0
		e0: 0.0
		n: 2
		lim: 0.0000000000000010
		
		while [lim =< abs e-e0][
		    e0: e
		    fact: fact * n
		    n: n + 1
		    e: e + 1.0 / fact
		]
		
		print e
	}
 	"call a function"
 	{
		printHello: $[][
			print "Hello World!"
		]
		
		sayHello: $[name][
			print ["Hello" name "!"]
		]
		
		printAll: $[args][
			loop args [arg][
				print arg
			]
		]
		
		getNumber: $[][3]
		
		; Calling a function that requires no arguments
		printHello
		
		; Calling a function with a fixed number of arguments
		sayHello "John"
		
		; Calling a function with a variable number of arguments
		printAll ["one" "two" "three"]
		
		; Using a function in statement context
		if true [printHello]
		print getNumber
		
		; Using a function in first-class context within an expression
		if getNumber=3 [print "yep, it worked"]
		
		; Obtaining the return value of a function:
		num: getNumber
		
		print num
		
	}
 	"case-sensitivity of identifiers"
 	{
		dog: "Benjamin"
		Dog: "Samba"
		DOG: "Bernie"
		
		dogs: @[dog Dog DOG]
		
		print ["The" size dogs "dog(s) are named" join.with:", " dogs]
	}
 	"casting out nines"
 	{
		N: 2
		base: 10
		c1: 0
		c2: 0
		 
		loop 1..(base^N)-1 'k [
		    c1: c1 + 1
		
		    if (k%base-1)= (k*k)%base-1 [
		        c2: c2 + 1
		        prints ~"|k| "
		    ]
		]
		
		print ""
		print ["Trying" c2 "numbers instead of" c1 "numbers saves" 100.0 - 100.0*c2//c1 "%"]
	}
 	"catalan numbers"
 	{
		catalan: function [n][
			if? n=0 -> 1
			else 	-> div (catalan n-1) * (4*n)-2 n+1
		]
		 
		loop 0..15 [i][
			print [
				pad.right to :string i 5 
				pad.left to :string catalan i 20
			]
		]
	}
 	"catamorphism"
 	{
		; find the sum, with seed:0 (default)
		print fold [1 2 3 4] => (+)
		
		; find the product, with seed:1
		print fold [1 2 3 4] .seed:1 => (*)
	}
 	"character codes"
 	{
		print to :integer first "a"
		print to :integer `a`
		print to :char 97
	}
 	"collections - array"
 	{
		; initialize array
		arr: ["one" 2 "three" "four"]
		 
		; add an element to the array
		arr: arr ++ 5
		
		; print it
		print arr
	}
 	"collections - dictionary"
 	{
		; initialize dictionary
		dict: #[
			name: "john"
			surname: "doe"
			age: 34
			preferredFood: ["fruit" "pizza"]
		]
		 
		; add an element to the dictionary
		dict\country: "Spain"
		 
		; print it
		print dict
	}
 	"comma quibbling"
 	{
		quibble: function [seq][
			if? 0=size seq -> "{}"
			else [
				if? 1=size seq -> "{" ++ seq\0 ++ "}"
				else -> "{" ++ (join.with:", " slice seq 0 (size seq)-1) ++ " and " ++ (last seq) ++ "}"
			]
		]
		
		sentences: [
			[] 
			["ABC"] 
			["ABC" "DEF"] 
			["ABC" "DEF" "G" "H"]
		]
		
		loop sentences 'sentence [
			print quibble sentence
		]
	}
 	"compound data type - 1"
 	{
		point: #[
			x: 10
			y: 20
		]
		
		print point
	}
 	"conditional structures - case when"
 	{
		loop 1..5 'num [
		    case [num]
		        when? [<2] -> print [num ": it's less than 2"]
		        when? [=2] -> print [num ": it's 2!"]
		        when? [=3] -> print [num ": it's 3!"]
		        else       -> print [num ": the number is too big"]
		]
		
	}
 	"conditional structures - if then else"
 	{
		num: 2
		
		if? num=2 [
			print "yep, num is 2"
		]
		else [
			print "something went wrong..."
		]
	}
 	"copy a string"
 	{
		a: "Hello"
		b: a            ; reference the same string
		
		; changing one string in-place
		; will change both strings
		
		'b ++ "World"
		print b
		print a
		
		c: "Hello"
		d: new c        ; make a copy of the older string
		
		; changing one string in-place
		; will change only the string in question
		
		'd ++ "World"
		print d
		print c
	}
 	"count in octal"
 	{
		loop 1..40 'i ->
			print ["number in base 10:" pad to :string i 2 
				   "number in octal:" pad as.octal i 2]
	}
 	"damm algorithm"
 	{
		; by @Krenium
		
		table: [
		    [0 3 1 7 5 9 8 6 4 2]
		    [7 0 9 2 1 5 4 8 6 3]
		    [4 2 0 6 8 7 1 3 5 9]
		    [1 7 5 0 9 8 3 4 2 6]
		    [6 1 2 3 0 4 5 9 7 8]
		    [3 6 7 4 2 0 9 5 8 1]
		    [5 8 6 9 7 2 0 1 3 4]
		    [8 9 4 5 3 6 2 0 1 7]
		    [9 4 3 8 6 1 7 2 0 5]
		    [2 5 8 1 4 3 6 7 9 0]
		]
		
		digits: $ => [map split & => [to :integer]]
		
		damm?: $ => [zero? fold digits & .seed: 0 => [get get table]]
		
		; Or, being more explicit:
		digits2: function [str][
		    chars: split str
		    result: map chars 'ch -> to :integer ch
		    return result
		]
		
		damm2?: function [str][
		    d: digits2 str
		    r: fold d .seed: 0 [x y] -> get get table x y
		    return r = 0
		]
		
		test: function [str][
		    result: switch damm? str -> "valid"
		                             -> "invalid"
		    print [str "is" result]
		]
		
		loop ["5724" "5727" "112946" "112949"] => test
	}
 	"date manipulation"
 	{
		; a tiny helper, so that we aren't too repetitive
		formatDate: function [dt][
		    to :string .format: "MMMM d yyyy h:mmtt" dt
		]
		
		initial: "March 7 2009 7:30pm EST"
		
		; chop timezone off
		initial: join.with:" " chop split.words initial
		initial: to :date .format: "MMMM d yyyy h:mmtt" initial
		
		print ["initial:"           formatDate initial]
		print ["after 12 hours:"    formatDate after.hours:12 initial]
	}
 	"day of the week"
 	{
		print select 2008..2121 'year [
		    "Sunday" = get to :date.format:"dd-MM-YYYY" ~"25-12-|year|" 'Day
		]
	}
 	"days between dates"
 	{
		daysBetweenDates: function [startDate, endDate][
		    a: to :date.format: "dd/MM/yyyy" startDate
		    b: to :date.format: "dd/MM/yyyy" endDate
		
		    return abs b\days - a\days
		]
		
		print [
		    "days between the two dates:" 
		    daysBetweenDates "01/01/2019" "19/10/2019"
		]
	}
 	"department numbers"
 	{
		loop 1..7 'x [
		    loop 1..7 'y [
		        loop 1..7 'z [
		            if all? @[
		                even? x
		                12 = sum @[x y z]
		                3 = size unique @[x y z]
		            ] -> print [x y z]
		        ]
		    ]
		]
	}
 	"detect division by zero"
 	{
		try? -> 3/0 
		else -> print "division by zero" 
	}
 	"determine if a string has all the same characters"
 	{
		strings: [
		    "", "   ", "2", "333", ".55", "tttTTT", 
		    "4444   444k", "pépé", "🐶🐶🐺🐶", "🎄🎄🎄🎄"
		]
		
		allSameChars?: function [str][
		    if empty? str -> return ø
		    current: first str
		    loop.with:'i str 'ch [
		        if ch <> current -> return i
		    ]
		    return ø
		]
		
		loop strings 's [
		    prints ["\"" ++ s ++ "\"" ~"(size |size s|):"]
		    firstNotSame: allSameChars? s
		    if? null? firstNotSame -> print "all the same."
		    else -> print ~"first different char `|get s firstNotSame|` at position |firstNotSame|."
		]
	}
 	"determine if a string has all unique characters"
 	{
		strings: [
		    "", ".", "abcABC", "XYZ ZYX",
		    "1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ",
		    "01234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ0X",
		    "hétérogénéité",
		    "🎆🎃🎇🎈", "😍😀🙌💃😍🙌", "🐠🐟🐡🦈🐬🐳🐋🐡"
		]
		
		loop strings 'str [
		    chars: split str
		    prints ["\"" ++ str ++ "\"" ~"(size |size str|):"]
		    
		    if? chars = unique chars ->
		        print "has no duplicates."
		    else [
		        seen: #[]
		        done: false
		
		        i: 0
		        while [and? i<size chars
		                    not? done][
		            ch: chars \ i
		            if? not? key? seen ch [
		                set seen ch i
		            ]
		            else [
		                print ~"has duplicate char `|ch|` on |get seen ch| and |i|"
		                done: true
		            ]
		            i: i+1
		        ]
		    ]
		]
	}
 	"determine if a string is numeric"
 	{
		print numeric? "hello world"
		print numeric? "1234"
		print numeric? "1234 hello world"
		print numeric? "12.34"
		print numeric? "!#@$"
		print numeric? "-1.23"
	}
 	"dot product"
 	{
		dotProduct: function [a,b][
		    [ensure equal? size a size b]
		
		    result: 0
		    loop 0..(size a)-1 'i [
		        result: result + (a \ i) * (b \ i)
		    ]
		    return result
		]
		
		print dotProduct @[1, 3, neg 5] @[4, neg 2, neg 1]
		print dotProduct [1 2 3] [4 5 6]
	}
 	"empty directory"
 	{
		emptyDir?: function [folder]-> empty? list folder
		
		print emptyDir? "."
	}
 	"empty string"
 	{
		s: ""
		
		if empty? s     -> print "the string is empty"
		if 0 = size s   -> print "yes, the string is empty"
		
		s: "hello world"
		
		if not? empty? s    -> print "the string is not empty"
		if 0 < size s       -> print "no, the string is not empty"
	}
 	"ethiopian multiplication"
 	{
		; By @Krenium
		
		halve: $ => [shr & 1]
		double: $ => [shl & 1]
		
		; even? already exists
		
		ethiopian: function [x y][
		    prod: 0
		    while [x > 0][
		        unless even? x [prod: prod + y]
		        x: halve x
		        y: double y
		    ]
		    return prod
		]
		
		print ethiopian 17 34
		print ethiopian 2 3
	}
 	"even or odd"
 	{
		loop (neg 5)..5 [x][
			if? even? x -> print [pad to :string x 4 ": even"]
			else -> print [pad to :string x 4 ": odd"]
		]
	}
 	"execute brainfuck"
 	{
		;
		; Brainf*ck compiler
		; In Arturo
		;
		 
		Tape: [0]
		DataPointer: new 0
		InstructionPointer: new 0
		 
		; Look for jumps in Code an register them
		; in the Jumps table
		 
		precomputeJumps: function [][
		    vstack: new []
		    jumphash: new #[]
		    instrPointer: 0
		 
		    while [instrPointer<CodeLength] [
		        command: get split Code instrPointer
		        if? command="[" -> 'vstack ++ instrPointer
		        else [
		            if command="]" [
		                target: last vstack
		                chop 'vstack
		                set jumphash target instrPointer
		                set jumphash instrPointer target
		            ]
		        ]
		        instrPointer: instrPointer+1
		    ]
		    jumphash
		]
		 
		; Check if current state is valid
		 
		StateIsValid: function [][
		    all? @[
		        0 =< DataPointer 
		        DataPointer < size Tape
		        0 =< InstructionPointer 
		        InstructionPointer < CodeLength
		    ]
		]
		
		; Compile the program
		 
		interpret: function [].export:[DataPointer,InstructionPointer,Tape][
		    while [StateIsValid][
		        command: get split Code InstructionPointer
		        case [command=]
		            when? ["+"] -> set Tape DataPointer (Tape \ DataPointer)+1
		            when? ["-"] -> set Tape DataPointer (Tape \ DataPointer)-1
		            when? [">"] [
		                inc 'DataPointer
		                if DataPointer = size Tape -> Tape: Tape ++ 0
		            ]
		            when? ["<"] -> dec 'DataPointer
		            when? ["."] -> prints to :string to :char Tape \ DataPointer
		            when? [","][
		                inp: to :integer input ""
		                if inp=13 -> inp: 10
		                if inp=3  -> panic "something went wrong!"
		                set Tape DataPointer inp
		            ]
		            when? ["["] ->
		                if 0 = get Tape DataPointer [ InstructionPointer: new get Jumps InstructionPointer ]
		
		            when? ["]"] ->
		                if 0 <> get Tape DataPointer [
		                    InstructionPointer: new get Jumps InstructionPointer
		                ]
		 
		        inc 'InstructionPointer
		    ]
		]
		 
		Code: ""
		if? 1>size arg  -> Code: "++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>."
		else            -> Code: read arg\0
		
		CodeLength: size Code
		Jumps: precomputeJumps
		
		interpret
	}
 	"execute hq9+"
 	{
		hq9: function [source][
		    acc: 0
		    loop split source 'ch [
		        case [(lower ch)=]
		            when? ["h"]-> print "Hello, world!"
		            when? ["q"]-> print source
		            when? ["9"]-> print "99 bottles here ..."
		            when? ["+"]-> acc: acc+1
		            else       []
		
		    ]
		    return acc
		]
		
		acc: hq9 {+qhp;+9Q}
		print ["accumulator:" acc]
	}
 	"extend your language"
 	{
		if2: function [cond1 cond2 both one two none][
			case []
				when? [and? cond1 cond2] -> do both
				when? [cond1] -> do one
				when? [cond2] -> do two
				else  -> do none
		]
		
		if2 false true [print "both"]
					   [print "only first"]
					   [print "only second"]
					   [print "none"]
	}
 	"factorial - fold"
 	{
		factorial: $[n][
		    fold.seed:1 1..n [a,b][a*b]
		]
		
		loop 1..19 [x][
			print ["Factorial of" x "=" factorial x]
		]
	}
 	"factorial - product"
 	{
		factorial: $[n][product 1..n]
		
		loop 1..19 [x][
			print ["Factorial of" x "=" factorial x]
		]
	}
 	"factorial - recursive"
 	{
		factorial: function [n][
			if? n > 0 -> n * factorial n-1
			else 	  -> 1
		] 
		
		loop 1..19 [x]->
			print ["Factorial of" x "=" factorial x]
	}
 	"factors of an integer"
 	{
		factors: $[num][
			select 1..num [x][
				(num%x)=0
			]
		]
		
		print factors 36
	}
 	"fasta format"
 	{
		parseFasta: function [data][
		    result: #[]
		    current: ø
		    loop split.lines data 'line [
		        if? `>` = first line [
		            current: slice line 1 (size line)-1
		            set result current ""
		        ]
		        else ->
		            set result current (get result current)++line
		    ]
		    return result
		]
		
		text: {
		    >Rosetta_Example_1
		    THERECANBENOSPACE
		    >Rosetta_Example_2
		    THERECANBESEVERAL
		    LINESBUTTHEYALLMUST
		    BECONCATENATED    
		}
		
		inspect.muted parseFasta text
	}
 	"file extension is in extensions list"
 	{
		fileExtensions: map ["zip" "rar" "7z" "gz" "archive" "A##"] => ["." ++ lower]
		 
		hasExtension?: function [file][
		    in? extract.extension lower file
		        fileExtensions
		]
		 
		files: ["MyData.a##" "MyData.tar.Gz" "MyData.gzip" "MyData.7z.backup" "MyData..." "MyData"]
		
		loop files 'file ->
		    print [file "=> hasExtension?:" hasExtension? file]
	}
 	"filter"
 	{
		arr: [1 2 3 4 5 6 7 8 9 10]
		
		print select arr [x][even? x]
	}
 	"find the last sunday of each month"
 	{
		lastSundayForMonth: function [m,y][
		    ensure -> in? m 1..12
		
		    daysOfMonth: @[0 31 (leap? y)? -> 28 -> 27 31 30 31 30 31 31 30 31 30 31]
		    loop range get daysOfMonth m 1 [d][
		        dt: to :date.format:"yyyy-M-dd" ~"|y|-|m|-|d|"
		        if dt\Day = "Sunday" -> return dt
		    ]
		]
		
		getLastSundays: function [year][
		    loop 1..12 'month [
		        print to :string.format:"yyyy-MM-dd" lastSundayForMonth month year
		    ]
		]
		
		getLastSundays 2013
	}
 	"find the missing permutation"
 	{
		perms: [
		    "ABCD" "CABD" "ACDB" "DACB" "BCDA" "ACBD" "ADCB" "CDAB" "DABC" 
		    "BCAD" "CADB" "CDBA" "CBAD" "ABDC" "ADBC" "BDCA" "DCBA" "BACD" 
		    "BADC" "BDAC" "CBDA" "DBCA" "DCAB"
		]
		
		allPerms: map permutate split "ABCD" => join
		
		print first difference allPerms perms
	}
 	"first-class functions"
 	{
		cube: function [x] -> x^3
		croot: function [x] -> x^(1//3)
		
		names: ["sin/asin", "cos/acos", "cube/croot"]
		funclist: @[var 'sin, var 'cos, var 'cube]
		invlist:  @[var 'asin, var 'acos, var 'croot]
		
		num: 0.5
		
		loop 0..2 'f [
		    result: call funclist \ f @[num]
		    print [names \ f "=>" call invlist \ f @[result]]
		]
	}
 	"fizzbuzz"
 	{
		loop 1..100 [x][
			case []
				when? [0=x%15] -> print "FizzBuzz"
				when? [0=x%3]  -> print "Fizz"
				when? [0=x%5]  -> print "Buzz"
				else  		   -> print x
		]
	}
 	"flatten a list"
 	"print flatten [[1], 2, [[3, 4], 5], [[[]]], [[[6]]], 7, 8, []]"
 	"function composition"
 	{
		compose: function [f,g] ->
		    return function [x].import:[f,g][
		        call f @[call g @[x]]
		    ]
		
		splitupper: compose 'split 'upper
		
		print call 'splitupper ["done"]
	}
 	"function definition"
 	{
		multiply: $[x,y][x*y]
		
		print multiply 3 7
		
		multiply2: function [x,y][
			return x*y
		]
		
		print multiply2 3 7
	}
 	"gapful numbers"
 	{
		gapful?: function [n][
		    s: to :string n
		    divisor: to :integer (first s) ++ last s
		    0 = n % divisor
		]
		
		specs: [100  30, 1000000  15, 1000000000 10, 7123 25]
		
		loop specs [start,count][
		    print "----------------------------------------------------------------"
		    print ["first" count "gapful numbers starting from" start]
		    print "----------------------------------------------------------------"
		    i: start
		    took: 0
		    while [took < count][
		        if gapful? i [
		            prints i
		            prints " "
		            took: took + 1
		        ]
		        i: i + 1
		    ]
		    print "\n"
		]
	}
 	"generate lower case ascii alphabet"
 	{
		lcase: map 97..122 [x][to :char x]
		
		print lcase
	}
 	"gray code"
 	{
		toGray: function [n]-> xor n shr n 1
		fromGray: function [n][
		    p: n
		    while [n > 0][
		        n: shr n 1
		        p: xor p n
		    ] 
		    return p
		]
		
		loop 0..31 'num [
		    encoded: toGray num
		    decoded: fromGray encoded
		
		    print [
		        pad to :string num 2 ":" 
		        pad as.binary num 5 "=>" 
		        pad as.binary encoded 5 "=>" 
		        pad as.binary decoded 5 ":" 
		        pad to :string decoded 2
		    ]
		]
	}
 	"greatest common divisor"
 	"print gcd [10 15]"
 	"greatest element of a list"
 	{
		arr: [5 4 2 9 7 3]
		
		print max arr
	}
 	"greatest subsequential sum"
 	{
		subarraySum: function [arr][
		    curr: 0
		    mx: 0
		    fst: size arr
		    lst: 0
		    currFst: 0
		
		    loop.with: 'i arr [e][
		        curr: curr + e
		        if e > curr [
		            curr: e
		            currFst: i
		        ]
		        if curr > mx [
		            mx: curr
		            fst: currFst
		            lst: i
		        ]
		    ]
		    if? lst > fst -> return @[mx, slice arr fst lst]
		    else -> return [0, []]
		]
		
		sequences: @[
		    @[1, 2, 3, 4, 5, neg 8, neg 9, neg 20, 40, 25, neg 5]
		    @[neg 1, neg 2, 3, 5, 6, neg 2, neg 1, 4, neg 4, 2, neg 1]
		    @[neg 1, neg 2, neg 3, neg 4, neg 5]
		    @[]
		]
		
		loop sequences 'seq [
		    print [pad "sequence:" 15 seq]
		    processed: subarraySum seq
		    print [pad "max sum:" 15 first processed]
		    print [pad "subsequence:" 15 last processed "\n"]
		]
	}
 	"happy numbers"
 	{
		ord0: to :integer `0`
		happy?: function [x][
		    n: x
		    past: new []
		
		    while [n <> 1][
		        s: to :string n
		        n: 0
		        loop s 'c [
		            i: (to :integer c) - ord0
		            n: n + i * i
		        ]
		        if contains? past n -> return false
		        'past ++ n
		    ]
		    return true
		]
		
		loop 0..31 'x [
		    if happy? x -> print x
		]
	}
 	"hash from two arrays"
 	{
		h: dictionary.raw flatten combine [a b c d] [1 2 3 4]
		print h
	}
 	"hello world - newbie"
 	{
		print "Hello world!!"
	}
 	"hello world - newline omission"
 	{
		prints "Goodbye, World!"
	}
 	"hello world - text"
 	{
		print "Hello world!"
	}
 	"here document"
 	{
		print {:
		    The “Red Death” had long devastated the country. 
		    No pestilence had ever been so fatal, or so hideous. 
		
		    Blood was its Avator and its seal—
		        the redness and the horror of blood. 
		
		    There were sharp pains, 
		        and sudden dizziness, 
		            and then profuse bleeding at the pores, 
		                with dissolution. 
		                
		    The scarlet stains upon the body 
		    and especially upon the face of the victim, 
		    were the pest ban 
		    which shut him out from the aid 
		    and from the sympathy of his fellow-men. 
		
		    And the whole seizure, 
		    progress and termination of the disease, 
		    were the incidents of half an hour.
		:}
	}
 	"higher-order functions"
 	{
		doSthWith: function [x y f][
			f x y
		]
		
		print [ "add:" doSthWith 2 3 $[x y][x+y] ]
		print [ "multiply:" doSthWith 2 3 $[x y][x*y] ]
	}
 	"iban"
 	{
		ibanSize: #[
		    AL: 28, AD: 24, AT: 20, AZ: 28, BE: 16
		    BH: 22, BA: 20, BR: 29, BG: 22, CR: 21, HR: 21, CY: 28
		    CZ: 24, DK: 18, DO: 28, EE: 20, FO: 18, FI: 18, FR: 27
		    GE: 22, DE: 22, GI: 23, GR: 27, GL: 18, GT: 28, HU: 28
		    IS: 26, IE: 22, IL: 23, IT: 27, KZ: 20, KW: 30, LV: 21
		    LB: 28, LI: 21, LT: 20, LU: 20, MK: 19, MT: 31, MR: 27
		    MU: 30, MC: 27, MD: 24, ME: 22, NL: 18, NO: 15, PK: 24
		    PS: 29, PL: 28, PT: 25, RO: 24, SM: 27, SA: 24, RS: 22
		    SK: 24, SI: 19, ES: 24, SE: 24, CH: 21, TN: 24, TR: 26
		    AE: 23, GB: 22, VG: 24 
		]
		 
		base36: (map 0..9 'x -> to :string x) ++ 
		         map 97..122 'x -> upper to :string to :char x
		 
		valid?: function [iban][
		    iban: replace iban " " ""
		    if not? contains? iban .regex "[0-9A-Z]+" -> return false
		    if not? (size iban)=ibanSize \ slice iban 0 1 -> return false
		 
		    iban: (slice iban 4 (size iban)-1) ++ slice iban 0 3
		    iban: join map split iban 'ch -> to :string index base36 ch
		    iban: to :integer iban
		
		    return 1=iban%97
		]
		 
		loop ["GB82 WEST 1234 5698 7654 32" 
		      "GB82 TEST 1234 5698 7654 32"] 'ib 
		      -> print [ib "=> valid?" valid? ib]
	}
 	"increment a numerical string"
 	{
		num: "12349"
		
		print ["The next number is:" (to :integer num)+1]
	}
 	"integer overflow"
 	{
		big32bit: 2147483646
		big64bit: 9223372036854775808
		
		print type big32bit
		print type big64bit
		
		print big32bit + 1
		print big64bit + 1
		
		print big32bit * 2
		print big64bit * 2
	}
 	"integer roots"
 	{
		iroot: function [b n][
		    if b<2 -> return b
		 
		    n1: n-1
		    n2: n
		    n3: n1
		    c: 1
		    d: (n3+b)/n2
		    e: ((n3*d) + b/d^n1)/n2
		    while [and? c<>d c<>e][
		        c: d
		        d: e
		        e: ((n3*e) + b/e^n1)/n2
		    ]
		    if d<e -> return d
		    return e
		]
		 
		print ["3rd root of 8:" iroot 8 3]
		print ["3rd root of 9:" iroot 9 3]
		print ["First 2001 digits of the square root of 2:" iroot (100^2000)*2 2]
	}
 	"introspection"
 	{
		if not? sys\version > 0.9.0 -> panic "version too old!"
		
		bloop: 3 - 5
		
		if? set? 'bloop -> "variable 'bloop' is set"
		else            -> "variable 'bloop' is not set"
		
		if set? 'abs -> print ["the absolute value of bloop is:" abs bloop]
		
		print [
		    "The sum of all globally defined integers is:"
		    sum map select keys symbols 'sym -> integer? var sym
		                                'sym -> var sym
		]
	}
 	"isbn13 check digit"
 	{
		validISBN?: function [isbn][
		    currentCheck: to :integer to :string last isbn
		    isbn: map split chop replace isbn "-" "" => [to :integer]
		
		    s: 0
		    loop.with:'i isbn 'n [
		        if? even? i -> s: s + n
		        else -> s: s + 3*n
		    ]
		    checkDigit: 10 - s % 10
		    return currentCheck = checkDigit
		]
		
		tests: [
		    "978-1734314502" "978-1734314509"
		    "978-1788399081" "978-1788399083"
		]
		
		loop tests 'test [
		    print [test "=>" validISBN? test]
		]
	}
 	"jewels and stones"
 	{
		count: function [jewels,stones][
		    size select split stones => [in? & jewels]
		]
		
		print count "aA" "aAAbbbb"
	}
 	"josephus problem"
 	{
		josephus: function [n,k][
		    p: new 0..n-1
		    i: 0
		    seq: []
		
		    while [0 < size p][
		        i: (i+k-1) % size p
		        append 'seq p \ i
		        remove 'p .index i
		    ]
		    print ["Prisoner killing order:" chop seq]
		    print ["Survivor:" last seq]
		    print ""
		]
		
		print "josephus 5 2 =>" 
		josephus 5 2
		
		print "josephus 41 3 =>"
		josephus 41 3
	}
 	"json"
 	{
		print read.json {{ "foo": 1, "bar": [10, "apples"] }}
		
		object: #[
			name: "john"
			surname: "doe"
			address: #[
				number: 10
				street: "unknown"
				country: "Spain"
		    ]
			married: false
		]
		
		print write.json ø object 
	}
 	"last friday of each month"
 	{
		lastFridayForMonth: function [m][
		    ensure -> in? m 1..12
		
		    daysOfMonth: [0 31 27 31 30 31 30 31 31 30 31 30 31]
		    loop range get daysOfMonth m 1 [d][
		        dt: to :date.format:"yyyy-M-dd" ~"2012-|m|-|d|"
		        if dt\Day = "Friday" -> return dt
		    ]
		]
		
		loop 1..12 'month [
		    print to :string.format:"yyyy-MM-dd" lastFridayForMonth month
		]
	}
 	"leap year"
 	{
		years: [
		    1600 1660 1724 1788 1848 1912 1972 
		    2032 2092 2156 2220 2280 2344 2348
		    1698 1699 1700 1750 1800 1810 1900 
		    1901 1973 2100 2107 2200 2203 2289
		]
		
		print select years => leap?
	}
 	"least common multiple"
 	{
		lcm: function [x,y][
		    x * y / gcd @[x y]
		]
		
		print lcm 12 18
	}
 	"letter frequency"
 	{
		source: {
		The Red Death had long devastated the country. 
		No pestilence had ever been so fatal, or so hideous. 
		Blood was its Avator and its seal—the redness and the horror of blood. 
		There were sharp pains, and sudden dizziness, 
		and then profuse bleeding at the pores, with dissolution. 
		The scarlet stains upon the body and especially upon the face of the victim, 
		were the pest ban which shut him out from the aid and from the sympathy of his fellow-men. 
		And the whole seizure, progress and termination of the disease, 
		were the incidents of half an hour.
		}
		
		valid: as.agnostic [a b c d e f g h i j k l m n o p q r s t u v w x y z]
		frequencies: #[]
		
		loop split lower source 'ch [
		    if in? to :literal ch valid [
		        if not? key? frequencies ch -> 
		            set frequencies ch 0
		
		        set frequencies ch (get frequencies ch)+1
		    ]
		]
		
		inspect.muted frequencies
	}
 	"levenshtein distance"
 	{
		print levenshtein "kitten" "sitting"
	}
 	"literals - floating point"
 	{
		pi: 3.14
		print [pi "->" type pi]
	}
 	"literals - integer"
 	{
		num: 18966
		
		print [num "->" type num]
	}
 	"literals - string"
 	{
		str: "Hello world"
		
		print [str "->" type str]
		
		fullLineStr: « This is a full-line string
		
		print [fullLineStr "->" type fullLineStr]
		
		multiline: {
		    This
		    is a multi-line
		    string
		}
		
		print [multiline "->" type multiline]
		
		verbatim: {:
		    This is 
		    a verbatim
		    multi-line
		    string
		:}
		
		print [verbatim "->" type verbatim]
	}
 	"logical operations"
 	{
		logic: function [a b][
			print ["a AND b =" and? a b]
			print ["a OR b =" or? a b]
			print ["NOT a = " not? a]
		]
		 
		logic true false
	}
 	"long literals, with continuations - using concatenations"
 	{
		revDate: "2021-02-05"
		 
		elementString:
		    "hydrogen helium lithium beryllium boron carbon nitrogen oxygen fluorine " ++
		    "neon sodium magnesium aluminum silicon phosphorous sulfur chlorine argon " ++
		    "potassium calcium scandium titanium vanadium chromium manganese iron "  ++
		    "cobalt nickel copper zinc gallium germanium arsenic selenium bromine "  ++
		    "krypton rubidium strontium yttrium zirconium niobium molybdenum "  ++
		    "technetium ruthenium rhodium palladium silver cadmium indium tin "  ++
		    "antimony tellurium iodine xenon cesium barium lanthanum cerium "  ++
		    "praseodymium neodymium promethium samarium europium gadolinium terbium "  ++
		    "dysprosium holmium erbium thulium ytterbium lutetium hafnium tantalum "  ++
		    "tungsten rhenium osmium iridium platinum gold mercury thallium lead "  ++
		    "bismuth polonium astatine radon francium radium actinium thorium "  ++
		    "protactinium uranium neptunium plutonium americium curium berkelium "  ++
		    "californium einsteinium fermium mendelevium nobelium lawrencium "  ++
		    "rutherfordium dubnium seaborgium bohrium hassium meitnerium darmstadtium "  ++
		    "roentgenium copernicium nihonium flerovium moscovium livermorium "  ++
		    "tennessine oganesson"
		
		elements: split.words elementString
		
		print ["Last revision date:" revDate]
		print ["Number of elements:" size elements]
		print ["Last element in list:" last elements]
	}
 	"long literals, with continuations - using string blocks"
 	{
		revDate: "2021-02-05"
		 
		elementString: {
		    hydrogen helium lithium beryllium boron carbon nitrogen oxygen fluorine
		    neon sodium magnesium aluminum silicon phosphorous sulfur chlorine argon
		    potassium calcium scandium titanium vanadium chromium manganese iron
		    cobalt nickel copper zinc gallium germanium arsenic selenium bromine
		    krypton rubidium strontium yttrium zirconium niobium molybdenum
		    technetium ruthenium rhodium palladium silver cadmium indium tin
		    antimony tellurium iodine xenon cesium barium lanthanum cerium
		    praseodymium neodymium promethium samarium europium gadolinium terbium
		    dysprosium holmium erbium thulium ytterbium lutetium hafnium tantalum
		    tungsten rhenium osmium iridium platinum gold mercury thallium lead
		    bismuth polonium astatine radon francium radium actinium thorium
		    protactinium uranium neptunium plutonium americium curium berkelium
		    californium einsteinium fermium mendelevium nobelium lawrencium
		    rutherfordium dubnium seaborgium bohrium hassium meitnerium darmstadtium
		    roentgenium copernicium nihonium flerovium moscovium livermorium
		    tennessine oganesson
		}
		
		elements: split.words elementString
		
		print ["Last revision date:" revDate]
		print ["Number of elements:" size elements]
		print ["Last element in list:" last elements]
	}
 	"long year"
 	{
		longYear?: function [year][
		    date: to :date .format: "dd/MM/yyyy" ~"01/01/|year|"
		
		    or? date\Day = "Thursday" 
		        and? leap? year
		             date\Day = "Wednesday"
		]
		
		print "Years with 53 weeks between 2000 and 2100:"
		print select 2000..2100 => longYear?
	}
 	"longest common prefix"
 	{
		lcp: function [lst][
			ret: ""
		    idx: 0
		 
		    while [true] [
		        thisLetter: ""
		        loop lst 'word [
		        	if idx=size word -> return ret
		        	if thisLetter="" -> thisLetter: get split word idx
		        	if thisLetter<>get split word idx -> return ret
		        ]
		        ret: ret ++ thisLetter
		        idx: idx + 1
		    ]
		]
		 
		print lcp ["interspecies" "interstellar" "interstate"]
		print lcp ["throne" "throne"]
		print lcp ["throne" "dungeon"]
		print lcp ["throne" "" "throne"]
		print lcp ["cheese"]
		print lcp [""]
		print lcp ["prefix" "suffix"]
		print lcp ["foo" "foobar"]
	}
 	"longest common substring"
 	{
		lcs: function [a,b][
		    lengths: map 0..size a => [map 0..size b => 0]
		    greatestLength: 0
		    result: ""
		    loop.with:'i a 'x [
		        loop.with:'j b 'y [
		            if x=y [
		                if? or? i=0 j=0 ->
		                    set lengths \ i j 0
		                else ->
		                    set lengths \ i j (1 + (lengths \ i-1) \ j-1)
		
		                if greatestLength < (lengths \ i) \ j [
		                    greatestLength: (lengths \ i) \ j
		                    result: slice a (i-greatestLength)+1 i
		                ]
		            ]
		        ]
		    ]
		    return result
		]
		
		print lcs "thisisatest", "testing123testing"
	}
 	"loop over multiple arrays simultaneously"
 	{
		parts: ["abc" "ABC" [1 2 3]]
		
		loop 0..2 'x -> 
		    print ~"|parts\0 \x||parts\1 \x||parts\2 \x|"
	}
 	"loops - continue"
 	{
		loop 1..10 'i [
		    prints i
		    if 0 = i%5 [
		        print ""
		        continue
		    ]
		    prints ", "
		]
	}
 	"loops - do-while"
 	{
		value: 0
		until [
			value: value + 1
			print value
		] [ 0 = value%6 ]
	}
 	"loops - downward for"
 	{
		loop 10..0 'i [
			print i
		]
	}
 	"loops - for"
 	{
		loop 0..5 'x [
			loop 0..x 'y [
				prints "*"
			]
			print ""
		]
	}
 	"loops - for with a specified step"
 	{
		loop 0..10 .step:2 'i [
			print i
		]
	}
 	"loops - foreach"
 	{
		arr: ["one" "two" "three"]
		
		dict: #[	
		    name:		"John"
			surname:	"Doe"
			age:		34
		]
		
		loop arr 'item ->
		    print item
		
		loop dict [key val]->
		    print [key "=>" val]
	}
 	"loops - increment loop index within loop body"
 	{
		i: 42
		n: 0
		
		while [n<42][
			if? prime? i [
				n: n+1
				print ["n =" pad to :string n 2 pad to :string i 20]
				i: i + i
			]
			else [
				i: i + 1
			]
		]
	}
 	"loops - n plus one half"
 	{
		print join.with:", " map 1..10 => [to :string &]
	}
 	"loops - while"
 	{
		i: 1024
		 
		while [i>0] [
			print i
			i: i/2
		]
	}
 	"magic squares of odd order"
 	{
		oddMagicSquare: function [n][
		    ensure -> and? odd? n
		                   n >= 0
		    
		    map 1..n 'i [
		        map 1..n 'j [
		            (n * ((i + (j - 1) + n / 2) % n)) +
		                      (((i - 2) + 2 * j) % n) + 1
		        ]
		    ]
		]
		
		loop [3 5 7] 'n [
		    print ["Size:" n ", Magic sum:" n*(1+n*n)/2 "\n"]
		    loop oddMagicSquare n 'row [
		        loop row 'item [
		            prints pad to :string item 3
		        ]
		        print ""
		    ]
		    print ""
		]
	}
 	"md5"
 	{
		print digest "The quick brown fox jumped over the lazy dog's back"
	}
 	"middle three digits"
 	{
		middleThree: function [num][
		    n: to :string abs num
		    if 3 > size n -> return "Number must have at least three digits"
		    if even? size n -> return "Number must have an odd number of digits"
		
		    middle: ((size n)/2)- 1 
		    return slice n middle middle+2
		]
		
		samples: @[ 
		    123, 12345, 1234567, 987654321, 10001, neg 10001, neg 123, neg 100, 100, neg 12345,
		    1, 2, neg 1, neg 10, 2002, neg 2002, 0 
		]
		
		loop samples 's [
		    print [pad to :string s 10 ":" middleThree s]
		]
	}
 	"modular exponentation"
 	{
		a: 2988348162058574136915891421498819466320163312926952423791023078876139
		b: 2351399303373464486466122544523690094744975233415544072992656881240319
		
		loop [40 80 180 888] 'm ->
		    print ["(a ^ b) % 10 ^" m "=" powmod a b 10^m]
	}
 	"modular inverse"
 	{
		modInverse: function [a,b][
		    if b = 1 -> return 1
		
		    b0: b   x0: 0   x1: 1
		    z: a
		
		    while [z > 1][
		        q: z / b        t: b
		        b: z % b        z: t
		        t: x0           x0: x1 - q * x0
		        x1: t
		    ]
		    (x1 < 0) ? -> x1 + b0 
		               -> x1
		]
		
		print modInverse 42 2017
	}
 	"modulinos - library"
 	{
		; modulinos - 1
		 
		meaningOfLife: function [][
		    42
		]
		
		if standalone? ->
		    print ~"Library: The meaning of life is |meaningOfLife|"
	}
 	"modulinos - main"
 	{
		do.import relative "modulinos - library.art"
		 
		print ~"Life means |meaningOfLife|."
		print "Death means invisible scary skeletons."
	}
 	"morse code"
 	{
		; set the morse code
		 
		code: #[
		    ; letters
		    a: ".-"     b: "-..."   c: "-.-."   d: "-.."    e: "."
		    f: "..-."   g: "--."    h: "...."   i: ".."     j: ".---"
		    k: "-.-"    l: ".-.."   m: "--"     n: "-."     o: "---"
		    p: ".--."   q: "--.-"   r: ".-."    s: "..."    t: "-"
		    u: "..-"    v: "...-"   w: ".--"    x: "-..-"   y: "-.--"
		    z: "--.." 
		    
		    ; digits
		    "0": "-----"
		    "1": ".----"
		    "2": "..---"
		    "3": "...--"
		    "4": "....-"
		    "5": "....."
		    "6": "-...."
		    "7": "--..."
		    "8": "---.."
		    "9": "----."
		]
		 
		; print an encoded message
		 
		str: "hello world 2019"
		out: ""
		
		loop split str 'ch [
		    if not? whitespace? ch -> 'out ++ code \ ch
		    'out ++ " "
		]
		 
		print out
		
	}
 	"multifactorial"
 	{
		multifact: function [n deg][
			if? n =< deg -> n 
			else -> n * multifact n-deg deg
		]
		 
		loop 1..5 'i [
			prints ["Degree" i ":"]
			loop 1..10 'j [
				prints [multifact j i " "]
			]
			print ""
		]
		 
	}
 	"multiplication tables"
 	{
		mulTable: function [n][
		    print ["    |"] ++ map 1..n => [pad to :string & 3]
		    print "----+" ++ join map 1..n => "----"
		    loop 1..n 'x [
		        prints (pad to :string x 3) ++ " |"
		        if x>1 -> loop 1..x-1 'y [prints "    "]
		        loop x..n 'y [prints " " ++ pad to :string x*y 3]
		        print ""
		    ]
		]
		
		mulTable 12
	}
 	"multisplit"
 	{
		print split.by:["==" "!=" "="] "a!===b=!=c"
	}
 	"munchausen numbers"
 	{
		munchausen?: function [n][
		    n = sum map split to :string n 'digit [
		        d: to :integer digit
		        d^d
		    ]
		]
		
		loop 1..5000 'x [
		    if munchausen? x ->
		        print x
		]
	}
 	"mutual recursion"
 	{
		f: $[n][ if? n=0 -> 1 else -> n-m f n-1 ]
		m: $[n][ if? n=0 -> 0 else -> n-f m n-1 ]
		 
		loop 0..20 'i [
			print ["f(" i ")=" f i]
			print ["m(" i ")=" m i]
			print ""
		]
		 
	}
 	"n\'th"
 	{
		suffixes: ["th" "st" "nd" "rd" "th" "th" "th" "th" "th" "th"]
		 
		nth: function [n][
		    if? or? 100 >= n%100
		            20 < n%100 
		            -> (to :string n) ++ "'" ++ suffixes \ n%10
		    else    -> (to :string n) ++ "'th"
		]
		
		loop range.step:250 0 1000 'j [
		    loop j..j+24 'i ->
		        prints (nth i)++" "
		    print ""
		]
	}
 	"named parameters"
 	{
		func: function [x][
		    print ["argument x:" x]
		    print ["attribute foo:" attr 'foo]
		    print ["attribute bar:" attr 'bar]
		    print ""
		]
		
		func 1
		func .foo:"foo" 2
		func .bar:"bar" 3
		func .foo:123 .bar:124 4
		func .bar:124 .foo:123 5
	}
 	"nested function"
 	{
		makeList: function [separator][
		    counter: 1
		
		    makeItem: function [item] .export:[counter][
		        result: ~"|counter||separator||item|"
		        counter: counter+1
		        return result
		    ]
		
		    @[
		        makeItem "first"
		        makeItem "second"
		        makeItem "third"
		    ]
		]
		
		print join.with:"\n" makeList ". "
	}
 	"non-decimal radices - convert"
 	{
		fromBase: function [x,base][
		    if base=2 [ return from.binary x ]
		    if base=8 [ return from.octal x ]
		    if base=16 [ return from.hex x ]
		
		    return to :integer x
		]
		
		toBase: function [x,base][
		    if base=2 [ return as.binary x ]
		    if base=8 [ return as.octal x ]
		    if base=16 [ return as.hex x ]
		
		    return to :string x
		]
		
		loop 1..20 'i ->
		    print [
		        i "base2:" toBase i 2 "base8:" toBase i 8 "base16:" toBase i 16
		    ]
		
		print ""
		
		print ["101 => from base2:" fromBase "101" 2 "from base8:" fromBase "101" 8 "from base16:" fromBase "101" 16]
		print ["123 => from base8:" fromBase "123" 8 "from base16:" fromBase "123" 16]
		print ["456 => from base8:" fromBase "456" 8 "from base16:" fromBase "456" 16]
	}
 	"non-decimal radices - input"
 	{
		print to :integer "10"      ; 10
		
		print from.hex "10"         ; 16
		print from.octal "120"      ; 80
		print from.binary "10101"   ; 21
	}
 	"non-decimal radices - output"
 	{
		loop 0..33 'i ->
		    print [
		        pad as.binary i 6
		        pad as.octal i 2
		        pad to :string i 2
		        pad as.hex i 2
		    ]
	}
 	"null object"
 	{
		v: null
		 
		if v=null -> print "got NULL!"
	}
 	"one-dimensional cellular automata"
 	{
		evolve: function [arr][
		    ary: [0] ++ arr ++ [0]
		    ret: new []
		    loop 1..(size ary)-2 'i [
		        a: ary \ i-1
		        b: ary \ i
		        c: ary \ i+1
		
		        if? 2 = a+b+c -> 'ret ++ 1
		        else          -> 'ret ++ 0
		    ]
		    ret
		]
		
		printIt: function [arr][
		    print replace replace join map arr => [to :string] "0" "_" "1" "#"
		]
		
		arr: [0 1 1 1 0 1 1 0 1 0 1 0 1 0 1 0 0 1 0 0]
		printIt arr
		
		newGen: evolve arr
		while [newGen <> arr][
		    arr: newGen
		    newGen: evolve arr
		    printIt newGen
		]
	}
 	"palindrome detection"
 	{
		palindrome?: $[seq] -> seq = reverse seq
		 
		loop ["abba" "boom" "radar" "civic" "great"] 'wrd [
			print [wrd ": palindrome?" palindrome? wrd]
		]
		 
	}
 	"pangram checker"
 	{
		chars: map 97..122 => [to :string to :char]
		pangram?: function [sentence][
		    every? chars 'ch ->
		        in? ch sentence
		]
		
		print pangram? "this is a sentence"
		print pangram? "The quick brown fox jumps over the lazy dog."
	}
 	"perfect shuffle"
 	{
		perfectShuffle: function [deckSize][
		    deck: 1..deckSize
		    original: new deck
		    halfDeck: deckSize/2
		
		    i: 1
		    while [true][
		        deck: flatten combine first.n: halfDeck deck last.n: halfDeck deck
		        if deck = original -> return i
		        i: i+1
		    ]
		]
		
		loop [8 24 52 100 1020 1024 10000] 's ->
		    print [
		        pad.right join @["Perfect shuffles required for deck size " to :string s ":"] 48
		        perfectShuffle s
		    ]
	}
 	"permutations"
 	"print permutate [1 2 3]"
 	"pernicious numbers"
 	{
		pernicious?: function [n][
		    prime? size filter split as.binary n 'x -> x="0"
		]
		
		i: 1
		found: 0
		while [found<25][
		    if pernicious? i [
		        prints i
		        prints " "
		        found: found + 1
		    ]
		    i: i + 1
		]
		print ""
		print select 888888877..888888888 => pernicious?
	}
 	"population count"
 	{
		popCount: function [num][
		    size select split to :string as.binary num 'x -> x="1"
		]
		
		print "population count for the first thirty powers of 3:"
		print map 0..29 => [popCount 3^&]
		
		print "first thirty evil numbers"
		print take select 0..100 => [even? popCount &] 30
		
		print "first thirty odious numbers"
		print take select 0..100 => [odd? popCount &] 30
		
	}
 	"primality by trial division"
 	{
		isPrime?: function [n][
		    if n=2 -> return true
		    if n=3 -> return true
		    if or? n=<1 0=n%2 -> return false
		 
		    high: to :integer sqrt n
		    loop high..2 .step: 3 'i [
		    	if 0=n%i -> return false
		    ]
		
		    return true
		]
		 
		loop 1..20 'i [
		    print ["isPrime?" i "=" isPrime? i ]
		]
	}
 	"proper divisors"
 	{
		properDivisors: function [x] ->
		    (factors x) -- x
		
		loop 1..10 'x ->
		    print ["proper divisors of" x "=>" properDivisors x]
		
		maxN: 0
		maxProperDivisors: 0
		
		loop 1..20000 'x [
		    pd: size properDivisors x
		    if maxProperDivisors < pd [
		        maxN: x
		        maxProperDivisors: pd
		    ]
		]
		
		print ["The number with the most proper divisors (" maxProperDivisors ") is" maxN]
	}
 	"quickselect algorithm"
 	{
		quickselect: function [a k][
		    arr: new a
		    while ø [
		        indx: random 0 (size arr)-1
		        pivot: arr \ indx
		        remove 'arr .index indx
		        left: select arr 'item -> item<pivot
		        right: select arr 'item -> item>pivot
		
		        case [k]
		            when? [= size left]-> return pivot
		            when? [< size left]-> arr: new left
		            else [
		                k: (k - size left) - 1
		                arr: new right
		            ]
		    ]
		]
		
		v: [9 8 7 6 5 0 1 2 3 4]
		
		print map 0..(size v)-1 'i ->
		    quickselect v i
	}
 	"quine"
 	{
		block: [print ["block:" as .code block "do block"]] do block
	}
 	"real constants and functions"
 	{
		print ["Euler:" epsilon]
		print ["Pi:" pi]
		
		print ["sqrt 2.0:" sqrt 2.0]
		print ["ln 100:" ln 100]
		print ["log(10) 100:" log 100 10]
		print ["exp 3:" exp 3]
		print ["abs -1:" abs neg 1]
		print ["floor 23.536:" floor 23.536]
		print ["ceil 23.536:" ceil 23.536]
		print ["2 ^ 8:" 2 ^ 8]
	}
 	"regular expressions"
 	{
		s: "This is a string"
		 
		if contains? s .regex "string$" -> print "yes, it ends with 'string'"
		 
		replace 's .regex "[as]" "x"
		
		print s
	}
 	"remove duplicate elements"
 	{
		arr: [1 2 3 2 1 2 3 4 5 3 2 1]
		 
		print unique arr
	}
 	"repeat"
 	{
		print "---------------------------"
		print "As a loop"
		print "---------------------------"
		loop 4 'x ->
		    print "Example 1"
		
		repeatFunc: function [f,times][
		    loop times 'x ->
		        do f
		]
		
		print "---------------------------"
		print "With a block param"
		print "---------------------------"
		repeatFunc [print "Example 2"] 4
		
		repeatFunc: function [f,times][
		    loop times 'x ->
		        f
		]
		
		print "---------------------------"
		print "With a function param"
		print "---------------------------"
		repeatFunc $[][print "Example 3"] 4
	}
 	"repeat a string"
 	{
		print repeat "ha" 5
	}
 	"return multiple values"
 	{
		addsub: function [x y]->
		    @[x+y x-y]
		
		a: 33
		b: 12
		
		result: addsub a b
		
		print [a "+" b "=" result\0]
		print [a "-" b "=" result\1]
	}
 	"reverse a string"
 	{
		str: "Hello World"
		
		print reverse str
	}
 	"reverse the gender of a string"
 	{
		reverseGender: function [str][
			ret: new str
			entries: ["She" "she" "Her" "her" "hers" "He" "he" "His" "his" "him"]
			repls: ["He_" "he_" "His_" "his_" "his_" "She_" "she_" "Her_" "her_" "her_"]
		 
		    loop.with:'i entries 'entry ->
		        replace 'ret .regex ~{\b|entry|\b} repls \ i
		    
		    return replace ret "_" ""
		]
		 
		print reverseGender "She was a soul stripper. She took his heart!"
		print reverseGender "He was a soul stripper. He took her heart!"
		print reverseGender "She wants what's hers, he wants her and she wants him!"
		print reverseGender "Her dog belongs to him but his dog is hers!"
	}
 	"reverse words in a string"
 	{
		text: {
		---------- Ice and Fire ------------
		 
		fire, in end will world the say Some
		ice. in say Some
		desire of tasted I've what From
		fire. favor who those with hold I
		 
		... elided paragraph last ...
		 
		Frost Robert -----------------------}
		
		reversed: map split.lines text =>
		    [join.with:" " reverse split.words &]
		
		print join.with:"\n" reversed
	}
 	"roman numerals - decode"
 	{
		syms: #[ M: 1000, D: 500, C: 100, L: 50, X: 10, V: 5, I: 1 ]
		
		fromRoman: function [roman][
			ret: 0
			loop 0..(size roman)-2 'ch [
				valueA: syms \ roman \ ch
				valueB: syms \ roman \ ch+1
		
				if? valueA < valueB -> ret: ret - valueA
			 	else				-> ret: ret + valueA
			]
			return ret + syms \ last roman
		]
		
		loop ["MCMXC" "MMVIII" "MDCLXVI"] 'r -> print [r "->" fromRoman r]
	}
 	"roman numerals - encode"
 	{
		nums: [[1000 "M"] [900 "CM"] [500 "D"] [400 "CD"] [100 "C"] [90 "XC"] 
		        [50 "L"] [40 "XL"] [10 "X"] [9 "IX"] [5 "V"] [4 "IV"] [1 "I"])
		 
		toRoman: function [x][
		   ret: ""
		   idx: 0
		   initial: x
		   loop nums 'num [
		      d: num\0
		      l: num\1
		
		      i: 0 
		      while [i<initial/d] [
		         ret: ret ++ l
		         i: i+1
		      ]
		
		      initial: mod initial d
		   ]
		   return ret
		]
		 
		loop [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 25 30 40
		      50 60 69 70 80 90 99 100 200 300 400 500 600 666 700 800 900
		      1000 1009 1444 1666 1945 1997 1999 2000 2008 2010 2011 2500
		      3000 3999] 'n 
		   -> print [n "->" toRoman n]
		 
	}
 	"s-expressions"
 	{
		code: {
		    ((data "quoted data" 123 4.5)
		     (data (!@# (4.5) "(more" "data)")))
		}
		
		s: first to :block code
		inspect.muted s
		print as.code s
	}
 	"set"
 	{
		a: [1 2 3 4]
		b: [3 4 5 6]
		
		print in? 3 a 
		print contains? b 3
		
		print union a b
		print intersection a b
		print difference a b
		print difference.symmetric a b
		
		print a = b
		
		print subset? [1 3] a
		print subset?.proper [1 3] a
		print subset? [1 3] [1 3]
		print subset?.proper [1 3] [1 3]
		
		print superset? a [1 3]
		print superset?.proper a [1 3]
		print superset? [1 3] [1 3]
		print superset?.proper [1 3] [1 3]
	}
 	"sha-1"
 	{
		print digest.sha "The quick brown fox jumped over the lazy dog's back"
	}
 	"show ascii table"
 	{
		loop 32..127 'num [
		    k: ø
		    case [num]
		        when? [=32]  -> k: "␠"
		        when? [=127] -> k: "␡"
		        else         -> k: to :string to :char num
		
		    prints pad ~"|num|: |k|" 10
		    if 1 = num%6 -> print ""
		]
	}
 	"sort an integer array"
 	{
		arr: [2 3 5 8 4 1 6 9 7]
		sort 'arr ; in-place
		 
		loop arr => print
	}
 	"sort numbers lexicographically"
 	{
		arr: 1..13
		print sort map arr => [to :string]
	}
 	"sort three variables"
 	{
		x: {lions, tigers, and}
		y: {bears, oh my!}
		z: {(from the "Wizard of OZ")}
		
		print join.with:"\n" sort @[x y z]
		
		x: 125
		y: neg 2
		z: pi
		
		print sort @[x y z]
	}
 	"sorting algorithms - bubble sort"
 	{
		bubbleSort: function [items][
		    len: size items
		    loop len [j][
		        i: 1
		        while [i =< len-j] [
		            if (items \ i) < (items \ i-1) [
		                tmp: items \ i
		                set items i get items i - 1
		                set items i - 1 tmp
		            ]
		            i: i + 1
		        ]
		    ]
		    items
		]
		
		print bubbleSort [3 1 2 8 5 7 9 4 6]
	}
 	"sorting algorithms - gnome sort"
 	{
		gnomeSort: function [items][
		    i: 1
		    j: 2
		    arr: new items 
		    while [i < size arr][
		        if? (arr \ i-1) =< arr \ i [
		            i: j
		            j: j + 1
		        ]
		        else [
		            tmp: arr \ i
		            set arr i get arr i-1
		            set arr i-1 tmp
		
		            i: i-1
		            if i=0 [
		                i: j
		                j: j + 1
		            ]
		        ]
		    ]
		    return arr
		]
		
		print gnomeSort [3 1 2 8 5 7 9 4 6]
	}
 	"sorting algorithms - insertion sort"
 	{
		insertionSort: function [items][
		    arr: new items 
		    loop 1..(size items)-1 'i [
		        value: arr \ i
		        j: i - 1
		
		        while [and? -> j >= 0 
		                    -> value < arr \ j]
		        [
		            set arr j+1 get arr j
		            j: j - 1
		        ]
		        set arr j + 1 value
		    ]
		    return arr
		]
		
		print insertionSort [3 1 2 8 5 7 9 4 6]
	}
 	"sorting algorithms - pancake sort"
 	{
		pancakeSort: function [items][
		    arr: new items
		    len: size arr
		    loop (len-1)..1 'endIdx [
		        maxim: max slice arr 0 endIdx
		        maximIdx: index arr maxim
		        if maximIdx=endIdx -> continue
		
		        if maximIdx > 0 [
		            arr: (reverse slice arr 0 maximIdx) ++ slice arr maximIdx+1 (size arr)-1
		        ]
		
		        arr: (reverse slice arr 0 endIdx) ++ slice arr endIdx+1 (size arr)-1
		    ]
		    arr
		]
		
		print pancakeSort [3 1 2 8 5 7 9 4 6]
	}
 	"sorting algorithms - quicksort"
 	{
		quickSort: function [items][
			if 2 > size items -> return items
			
			pivot: first items
			left:  select slice items 1 (size items)-1 'x -> x < pivot
			right: select slice items 1 (size items)-1 'x -> x >= pivot
		
			((quickSort left) ++ pivot) ++ quickSort right
		]
		
		print quickSort [3 1 2 8 5 7 9 4 6]
	}
 	"sorting algorithms - selection sort"
 	{
		selectionSort: function [items][
		    sorted: new []
		    tmp: new items
		    while [not? empty? tmp][
		        minIndex: index tmp min tmp
		        'sorted ++ tmp \ minIndex
		        remove 'tmp .index minIndex
		    ]
		    return sorted
		]
		
		print selectionSort [3 1 2 8 5 7 9 4 6]
	}
 	"split a character string based on change of character"
 	{
		parts: [] current: ""
		loop split {gHHH5YY++///\} 'ch [
		    if? or? empty? current
		            contains? current ch -> 'current ++ ch
		    else [
		        'parts ++ current
		        current: new ch
		    ]
		]
		'parts ++ current
		print parts
	}
 	"square but not cube"
 	{
		squares: map 1..100 => [&^2]
		cubes: map 1..100 => [&^3]
		
		print "Square but not cube:"
		print first.n:30 select squares => [not? in? & cubes]
		print "Square and cube:" 
		print first.n:3 select squares => [in? & cubes]
	}
 	"stack"
 	{
		Stack: $[]-> []
		
		pushTo:     function [st val]-> 'st ++ val
		popStack:   function [st]     [
		    result: last st
		    remove 'st .index (size st)-1 
		    return result
		]
		emptyStack: function [st]-> empty 'st
		printStack: function [st]-> print st
		
		st: new Stack
		
		pushTo st "one"
		pushTo st "two"
		pushTo st "three"
		printStack st
		
		print popStack st
		printStack st
		
		emptyStack st
		print ["finally:" st]
	}
 	"string append"
 	{
		print join ["Hello" "World"]
		
		a: "Hello"
		'a ++ "World"
		print a
		
		b: "Hello"
		append 'b "World"
		print b
		
		c: "Hello"
		print append c "World"
	}
 	"string case"
 	{
		str: "alphaBETA"
		
		print ["uppercase  :" upper str]
		print ["lowercase  :" lower str]
		print ["capitalize :" capitalize str]
	}
 	"string comparison"
 	{
		loop [["YUP" "YUP"] ["YUP" "Yup"] ["bot" "bat"] ["aaa" "zz"]] 'x [
		    print [x\0 "="  x\1 "=>" x\0 =  x\1]
		    print [x\0 "=" x\1 "(case-insensitive) =>" (upper x\0) = upper x\1]
		    print [x\0 "<>" x\1 "=>" x\0 <> x\1]
		    print [x\0 ">"  x\1 "=>" x\0 >  x\1]
		    print [x\0 ">=" x\1 "=>" x\0 >= x\1]
		    print [x\0 "<"  x\1 "=>" x\0 <  x\1]
		    print [x\0 "=<" x\1 "=>" x\0 =< x\1]
		    print "----"
		]
	}
 	"string concatenation"
 	{
		str1: "Hello "
		str2: "World"
		 
		print str1 ++ str2 ++ "!"
	}
 	"string interpolation (included)"
 	{
		sizeOfLamb: "little"
		
		print ~"Mary had a |sizeOfLamb| lamb."
	}
 	"string length - character length"
 	{
		str: "Hello World"
		
		print ["length =" size str]	
	}
 	"string matching"
 	{
		print prefix? "abcd" "ab"
		print prefix? "abcd" "cd"
		print suffix? "abcd" "ab"
		print suffix? "abcd" "cd"
		
		print contains? "abcd" "ab"
		print contains? "abcd" "xy"
		
		print in? "ab" "abcd"
		print in? "xy" "abcd"
		
		print index "abcd" "bc"
		print index "abcd" "xy"
	}
 	"string prepend"
 	{
		a: "World"
		a: "Hello" ++ a
		print a
		
		b: "World"
		b: append "Hello" b
		print a
		
		c: "World"
		prefix 'c "Hello"
		print c
		
		d: "World"
		print prefix d "Hello"
	}
 	"strip a set of characters from a string"
 	{
		stripChars: function [str, chars]->
		    join select split str => [not? in? & split chars]
		
		print stripChars "She was a soul stripper. She took my heart!" "aei"
	}
 	"strip control codes and extended characters from a string"
 	{
		str: {string of ☺☻♥♦⌂, may include control characters and other    ♫☼§►↔◄░▒▓█┌┴┐±÷²¬└┬┘ilk.}
		
		print "with extended characters"
		print join select split str 'x ->
		    not? in? to :integer to :char x (0..31)++127
		
		print "without extended characters"
		print join select split str 'x ->
		    and? ascii? x
		         not? in? to :integer to :char x (0..31)++127
	}
 	"strip whitespace from a string - top and tail"
 	{
		str: "     Hello World     "
		
		print [pad "strip all:"      15  ">" strip str       "<"]
		print [pad "strip leading:"  15  ">" strip.start str "<"]
		print [pad "strip trailing:" 15  ">" strip.end str   "<"]
	}
 	"substitution cipher"
 	{
		key: {:]kYV}(!7P$n5_0i R:?jOWtF/=-pe'AD&@r6%ZXs"v*N[#wSl9zq2^+g;LoB`aGh{3.HIu4fbK)mU8|dMET><,Qc\C1yxJ:}
		 
		encode: function [str][
		    bs: new []
		    loop split str 'ch ->
		        'bs ++ to :string key \ (to :integer to :char ch)-32
		    return join bs
		]
		
		decode: function [str][
		    bs: new []
		    loop split str 'ch ->
		        'bs ++ to :string to :char (index key ch)+32
		    return join bs
		]
		
		s: "The quick brown fox jumps over the lazy dog, who barks VERY loudly!"
		
		enc: encode s
		print ["encoded:" enc]
		print ["decoded:" decode enc]
	}
 	"substring"
 	{
		str: "abcdefgh"
		n: 2
		m: 3
		
		; starting from n=2 characters in and m=3 in length
		print slice str n-1 n+m-2
		
		; starting from n characters in, up to the end of the string
		print slice str n-1 (size str)-1
		
		; whole string minus last character
		print slice str 0 (size str)-2
		
		; starting from a known character char="d" 
		; within the string and of m length
		print slice str index str "d" m+(index str "d")-1
		
		; starting from a known substring chars="cd" 
		; within the string and of m length
		print slice str index str "cd" m+(index str "cd")-1
	}
 	"substring - top and tail"
 	{
		knight: "knight"
		socks: "socks"
		brooms: "brooms"
		
		print drop knight 1                     ; strip first character
		print slice knight 1 (size knight)-1    ; alternate way to strip first character
		
		print chop socks                        ; strip last character
		print take socks (size socks)-1         ; alternate way to strip last character
		print slice socks 0 (size socks)-2      ; yet another way to strip last character
		
		print chop drop brooms 1                ; strip both first and last characters
		print slice brooms 1 (size brooms)-2    ; alternate way to strip both first and last characters
	}
 	"sum and product of an array"
 	{
		arr: 1..10
		
		print ["Sum =" sum arr]
		print ["Product =" product arr]
	}
 	"sum digits of an integer"
 	{
		sumDigits: function [n base][
			result: 0
			while [n>0][
				result: result + n%base
				n: n/base
		    ]
			return result
		]
		 
		print sumDigits 1 10
		print sumDigits 12345 10
		print sumDigits 123045 10
		print sumDigits from.hex "0xfe" 16
		print sumDigits from.hex "0xf0e" 16
	}
 	"sum multiples of 3 and 5"
 	{
		sumMul35: function [n][
			sum select 1..n-1 [x][or? 0=x%3 0=x%5]
		]
		
		print sumMul35 1000
	}
 	"sum of a series"
 	{
		series: map 1..1000 => [1.0/&^2]
		print [sum series]
	}
 	"sum of squares"
 	{
		arr: 1..10
		
		print sum map arr [x][x^2]
	}
 	"symmetric difference"
 	{
		a: ["John" "Bob" "Mary" "Serena"]
		b: ["Jim" "Mary" "John" "Bob"]
		 
		print difference.symmetric a b
	}
 	"temperature conversion"
 	{
		convertKelvins: function [k][
		    #[
		        celcius:    k - 273.15
		        fahrenheit: (k * 9/5.0)-459.67
		        rankine:    k * 9/5.0
		    ]
		]
		
		print convertKelvins 100
	}
 	"terminal control - display an extended character"
 	{
		print "£"
	}
 	"tokenize a string"
 	{
		str: "Hello,How,Are,You,Today"
		
		print join.with:"." split.by:"," str
	}
 	"tokenize a string with escaping"
 	{
		tokenize: function [s sep esc][
			escaping: 0
		
			loop 0..(size s)-1 [i][
				chr: (split s)\i
		
				if? escaping=1 [
					prints chr
					escaping: 0
				]
				else [
					case [chr]
						when? [=sep] [print ""]
						when? [=esc] [escaping: 1]
						else [prints chr]
				]
			]
			print ""
		]
		
		str: "one^|uno||three^^^^|four^^^|^cuatro|" 
		tokenize str "|" "^"
		
	}
 	"towers of hanoi"
 	{
		hanoi: function [n f dir via][
			if n>0 [
				hanoi n-1 f via dir
				print ["Move disk" n "from" f "to" dir]
				hanoi n-1 via dir f
			]
		]
		 
		hanoi 3 'L 'M 'R
	}
 	"trigonometric functions"
 	{
		pi: 4*atan 1.0
		
		radians: pi/4
		degrees: 45.0
		
		print "sine"
		print [sin radians, sin degrees*pi/180]
		
		print "cosine"
		print [cos radians, cos degrees*pi/180]
		
		print "tangent"
		print [tan radians, tan degrees*pi/180]
		
		print "arcsine"
		print [asin sin radians, (asin sin radians)*180/pi]
		
		print "arccosine"
		print [acos cos radians, (acos cos radians)*180/pi]
		
		print "arctangent"
		print [atan tan radians, (atan tan radians)*180/pi]
		
	}
 	"undefined values"
 	{
		undef: null
		
		print undef
	}
 	"url decoding"
 	{
		print decode.url "http%3A%2F%2Ffoo%20bar%2F"
		print decode.url "google.com/search?q=%60Abdu%27l-Bah%C3%A1"
	}
 	"url encoding"
 	{
		encoded: encode.url.slashes "http://foo bar/"
		print encoded
	}
 	"variadic function"
 	{
		;-------------------------------------------
		; a quasi-variadic function
		;-------------------------------------------
		variadic: function [args][
		    loop args 'arg [
		        print arg
		    ]
		]
		
		; calling function with one block param
		; and the arguments inside
		
		variadic ["one" 2 "three"]
		
		;-------------------------------------------
		; a function with optional attributes
		;-------------------------------------------
		variable: function [args][
		    print ["args:" args]
		    if? attr? "with" [
		        print ["with:" attr "with"]
		    ]
		    else [
		        print "without attributes"
		    ]
		]
		
		variable "yes"
		variable.with:"something" "yes!"
	}
 	"zig-zag matrix"
 	{
		zigzag: function [n][
		    result: map 1..n 'x -> map 1..n => 0
		
		    x: 1, y: 1, v: 0, d: 1
		
		    while [v < n^2][
		        if? all? @[1 =< x x =< n 1 =< y y =< n][
		            set get result (y-1) (x-1) v
		            x: x + d, y: y - d, v: v + 1
		        ]
		        else[if? x > n [x: n, y: y + 2, d: neg d]
		            else[if? y > n [x: x + 2, y: n, d: neg d]
		                else[if? x < 1 [x: 1, d: neg d]
		                    else[if y < 1 [y: 1, d: neg d]
		                    ]
		                ]
		            ]
		        ]
		    ]
		    result
		]
		
		zz: zigzag 5
		loop zz 'row -> print map row 'col [pad to :string col 3]
	}
]
