; /*********************************
;  * Brainf*ck compiler
;  * In Art:uro
;  *********************************/
 
Tape: [0]
DataPointer: 0
InstructionPointer: 0
 
; Look for jumps in Code an register them
; in the Jumps table
 
precomputeJumps: function [][
    vstack: new []
    jumphash: new #[]
    instrPointer: 0
 
    while [instrPointer<CodeLength] [
        command: get split Code instrPointer
        if? command="[" -> vstack: vstack ++ instrPointer
        else [
            if command="]" [
                target: last vstack
                chop 'vstack
                set jumphash to :string target instrPointer
                set jumphash to :string instrPointer target
            ]
        ]
        instrPointer: instrPointer+1
    ]
    jumphash
]
 
; Check if current state is valid
 
StateIsValid: function [][
    all? @[
        0 =< DataPointer 
        DataPointer < size Tape
        0 =< InstructionPointer 
        InstructionPointer < CodeLength
    ]
]
 
; Compile the program
 
interpret: function [].export:[DataPointer,InstructionPointer,Tape][
    while [StateIsValid][
        command: get split Code InstructionPointer
        case [command=]
            when? ["+"] -> set Tape DataPointer (Tape \ DataPointer)+1
            when? ["-"] -> set Tape DataPointer (Tape \ DataPointer)-1
            when? [">"] [
                DataPointer: DataPointer + 1
                if DataPointer = size Tape -> Tape: Tape ++ 0
            ]
            when? ["<"] -> DataPointer - 1
            when? ["."] -> prints to :string to :char Tape \ DataPointer
            when? [","][
                inp: to :integer input ""
                if inp=13 -> inp: 10
                if inp=3  -> panic "something went wrong!"
                set Tape DataPointer inp
            ]
            when? ["["][
                if 0 = get Tape DataPointer -> InstructionPointer: get Jumps to :string InstructionPointer
            ]
            when? ["]"][
                if 0 <> get Tape DataPointer -> InstructionPointer: get Jumps to :string InstructionPointer
            ]
        ; if command="+" -> Tape.[DataPointer]: Tape.[DataPointer]+1
        ; if command="-" -> Tape.[DataPointer]: Tape.[DataPointer]-1
        ; if command=">" { DataPointer: DataPointer+1, if DataPointer=[size Tape] -> Tape: Tape+0 }
        ; if command="<" -> DataPointer: DataPointer-1
        ; if command="." -> prints [char Tape.[DataPointer]]
        ; if command="," {
        ;     inp: toNumber|input ~
        ;     if inp=13 { inp: 10 }
        ;     if inp=3  { panic "something went wrong!" }
        ;     Tape.DataPointer: inp
        ; }
        ; if command="[" {
        ;     if Tape.[DataPointer]=0 -> InstructionPointer: Jumps.[toString InstructionPointer]
        ; }
        ; if command="]" {
        ;     if Tape.[DataPointer]!=0 -> InstructionPointer: Jumps.[toString InstructionPointer]
        ; }
 
        InstructionPointer: InstructionPointer+1
    ]
]
 
if 1>size arg -> panic "Not enough arguments - Usage: bfc <script>"
 
Code: read arg\0
CodeLength: size Code
Jumps: precomputeJumps

interpret