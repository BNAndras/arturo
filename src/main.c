/*****************************************************************
 * Arturo :VM
 * 
 * Programming Language + Compiler
 * (c) 2019-2020 Yanis Zafir√≥pulos (aka Dr.Kameleon)
 *
 * @file: src/main.c
 *****************************************************************/

#include "arturo.h"

/**************************************
  Helpers
 **************************************/

void showHelp(){
	showVersion();

	printf("\e[1;37musage:\e[00m arturo [options] <filename> [args...]\n\n");

	printf("\e[1;36mcommand\e[00m\n");
	printf("    -h           - show (this) help information\n");
	printf("    -v           - show version\n\n");
	
	printf("\e[1;36moptions\e[00m\n");
    printf("    -i PATH      - set include path\n");
    printf("    -s SIZE      - set VM stack size\n");
    printf("\n");
    printf("    -b           - print generated bytecode\n");
    printf("    -c           - compile only\n");
    printf("    -o           - optimize code\n");
    printf("    -x           - execute object file\n");
	printf("\n");
}

/**************************************
  The Main Entry
 **************************************/

#define GG(v)    ((mpz_t*)(v & UNMASK))

Value addNumbers(int a, int b) {
    Int32 res;
    if (addWillOverflow(a,b,&res)) {
        printf("overflow\n");
        mpz_t* ret = malloc(sizeof(mpz_t));
        mpz_init_set_si(*ret,a);
        mpz_add_ui(*ret,*ret,b);
        return toG(ret);
    }
    else {
        printf("normal addition\n");
        return toI(res);
    }
}

int main(int argc, char** argv) {
    // process command-line arguments
    
	char* includePath = NULL;
    unsigned int stackSize = 0;
    bool compileOnly = false;
    bool executeObject = false;
    bool doOptimize = false;
    bool doDebugBytecode = false;

	int opt; 

	while((opt = getopt(argc, argv, "hvi:s:cxbo")) != -1) {  
        switch(opt) {  
        	case 'h':
        		showHelp();
        		exit(0);
        	case 'v':
        		showVersion();
        		exit(0);
        	case 'i':
        		includePath = optarg;
        		break;
            case 's': {
                char* endp = NULL;
                long l = -1;
                if (!optarg ||  ((l=strtol(optarg, &endp, 10)),(endp && *endp))) {
                    printf("expecting valid SIZE argument for option -s\n");
                    exit(1);
                }
                stackSize = (int)l;
                break;
            }
            case 'c':
                compileOnly = true;
                break;
            case 'x':
                executeObject = true;
                break;
            case 'b':
                doDebugBytecode = true;
                break;
            case 'o':
                doOptimize = true;
                break;
        	default:
        		exit(1);
        }  
    }  

    int extraArgs = argc-optind;
    Env = (Environment){
        .littleEndian = IS_LITTLE_ENDIAN,
        .include = includePath,
        .stackSize = (stackSize==0 ? STACK_SIZE : stackSize),
        .optimize = doOptimize,
        .debugBytecode = doDebugBytecode,
        .argv = argv,
        .argi = optind
    };

    if (compileOnly && executeObject) {
        cmdlineError("cannot use -c and -x simultaneously");
    }

    if (!extraArgs) {
        if (compileOnly || executeObject) {
            cmdlineError("cannot use -c or -x without an input file");
        }
        if (doOptimize) {
            cmdlineError("extraneous argument -O found");
        }
    	replStart();
    }
    else {
        if (compileOnly) {
            FILE* script = fopen(argv[optind], "r");
            vmCompileScript(script, argv[optind]);
        }
        else if (executeObject) {
            (void)vmRunObject(argv[optind]);
        }
        else {
            FILE* script = fopen(argv[optind], "r");
            (void)vmRunScript(script);
        }
    }

    return 0;
}

/****************************************
   This is the end,
   my only friend, the end...
 ****************************************/