stdSym: #[]
stdLib: #.raw
        flatten sort unique
            map select couple keys symbols values symbols 
                'entry -> function?.builtin entry\1 
                'entry [
                    i: info.get entry\0
                    if key? i 'alias -> stdSym\[to :symbol i\alias]: entry\0
                    @[to :word entry\0, i\module]
                ]

inspect stdLib
inspect stdSym

inspect stdLib\[to :word "function"]

; ;---------------------------------------

; tmpFolder: arg\0
; entryName: arg\1
; target: extract.filename entryName

; ;---------------------------------------

; stdLib: map select stdLib 'entry [
;     result: false
;     if function?.builtin entry\1 -> result: true
;     result
; ] 'entry -> to :word entry\0
; stdLib: sort unique stdLib

; symAliases: #[]
; loop keys symbols 'ss [
;     inf: info.get ss
;     if key? inf 'alias ->
;         symAliases\[inf\alias]: ss
; ]

; getAliasedFunction: function [s][
;     loop keys symbols 'declared [
;         if throws? [
;             inf: info.get declared
;             if and? [key? inf 'alias][inf\alias = to :string s] -> return declared
;         ] -> return null
;     ]
;     return null
; ]

; getFunctionsInBlock: function [code][
;     'result ++ select to :block code => word?
;     'result ++ select to :block code => symbol?
;     loop select to :block code 'item -> or? inline? item block? item 'bl ->
;         getFunctionsInBlock bl
; ]

; getImportsInBlock: function [imports, filename, code].inline [
;     codeBlock: (string? code)? -> to :block read code
;                                -> code
;     loop.with:'ci codeBlock 'item [
;         inspect item
;         if and? [word? item][item = first [import]][
;             print "yes it's an import"
;             inspect codeBlock
;             print ["ci:" ci, "dec size codeBlock:" dec size codeBlock]
;             if ci < dec size codeBlock [
;                 print "IN HERE"
;                 nextie: codeBlock\[ci+1]
;                 subf: (filename = "")? -> ""
;                                        -> filename ++ "/"
;                 inspect nextie
;                 if or? string? nextie literal? nextie [
;                     print ["Normal import found:" nextie]
;                     'imports ++ @[@[subf, read import._path nextie]]
;                     getImportsInBlock imports subf read import._path nextie
;                 ]

;                 if or? [nextie = first [relative]][nextie = first [./]][
;                     print ["Relative import found:" to :string codeBlock\[ci+2]]
;                     'imports ++ @[@[subf ++ to :string codeBlock\[ci+2], read to :string codeBlock\[ci+2]]]
;                     getImportsInBlock imports subf ++ to :string codeBlock\[ci+2], read to :string codeBlock\[ci+2]
;                 ]

;                 ;inspect imports
;             ]
;         ]
;         if or? inline? item block? item ->
;             getImportsInBlock imports filename item
;     ]
; ]

; getFunctions: function [scr][
;     code: to :block read scr
;     result: new []

;     getFunctionsInBlock code

;     if zero? size result -> return [[][]]

;     funcs: select sort unique result => word?

;     syms: select sort unique result => symbol?
;     syms: select syms 'sym -> key? symAliases to :string sym
;     syms: map syms 'sym -> to :word symAliases\[to :string sym]

;     ffs: select sort unique funcs ++ syms 'ss ->
;         and? [contains? keys symbols to :string ss][function?.builtin var to :literal ss]
;     non: (sort unique funcs ++ syms)--ffs

;     return ffs
; ]

; funcs: to [:string] getFunctions entryName entryName
; modules: unique ["Core", "Exceptions", "Logic", "Numbers"] ++ map funcs 'ff [
;     i: info.get ff
;     i\module
; ]

; totalImports: []
; getImportsInBlock totalImports "" entryName

; inspect totalImports

; write ~"|tmpFolder|/|target|._entry" read entryName
; write.json ~"|tmpFolder|/|target|._data" #.raw flatten totalImports
; write.json ~"|tmpFolder|/|target|._modules" modules
; write.json ~"|tmpFolder|/|target|._functions" funcs
; print color #green "Done."
