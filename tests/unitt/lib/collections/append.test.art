import {unitt}!

inplaceEquivalence: $[value :any func :literal params :block][
    ;; returns: [reference, inplaced]
    @[
        call func append @[value] params
        returnInplaced value func params
    ]
] 

returnInplaced: $[value :any func :literal params :block][
    inplaced: new value
    call func ['inplaced] ++ params
    return inplaced
]



suite "Test :binary operations" [

    integers: [0 1]
    binaries: map integers 'x -> to :binary x

    ; ===== ===== Property-based ===== =====

    test.prop ":binary ++ :binary results in :binary" [
        loop permutate.repeated new binaries 'entries [
            a: first entries
            b: last entries
            assert -> binary? append a b
        ]
    ]
    
    test.prop ":binary ++ :integer results in :binary" [
        sample: $[x] -> flatten permutate.repeated x 
        binaries: sample binaries
        integers: sample integers
        
        loop couple binaries integers 'entries [
            a: first entries
            b: last entries
            assert -> binary? append a b
        ]
    ]
    
    test.prop ":binary ++ :binary results in :binary" [
        [a b]: new binaries
        
        assert -> binary? append a b
    ]

    ; ===== ===== Examples ===== =====

    test ":binary ++ :binary | 00 ++ 01 = 00 01" [
        [a b]: new binaries
        correct: to :binary [0 1]
        assert -> correct = a ++ b
    ]
    
    test ":binary ++ :integer | 00 ++ 1 = 00 01" [
        a: first new binaries
        b: 1
        correct: to :binary [0 1]
        assert -> correct = a ++ b
    ]

    ; ===== ===== Testing in-place equivalence ===== =====

    test.prop ":binary ++ :binary | in-place has the same behavior" [
        [a b]: new binaries

        [ref inp]: inplaceEquivalence (a) 'append @[b]
        assert -> ref = inp
    ]
   
    test.prop ":binary ++ :integer | in-place has the same behavior" [
        [a]: first new binaries
        b: 1

        [ref inp]: inplaceEquivalence (a) 'append @[b]
        assert -> ref = inp
    ]

]


suite "Test :string operations" [

    ; ===== ===== Property-based ===== =====

    test.prop ":string appending results in :string" [
        assert -> string? "Art" ++ "uro" 
    ]
   
    test.prop ":char appending results in :string" [
        assert -> string? 'H' ++ 'i' 
    ]

    test.prop ":string and :char appending are seamless" [
        assert -> equal? "Artur" ++ "o" "Artur" ++ 'o' 
    ]

    ; ===== ===== Examples ===== =====
    
    test {"Art" ++ "uro" = "Arturo"} [
        assert -> "Arturo" = "Art" ++ "uro"
    ]

    test {"Artur" ++ 'o' = "Arturo"} [
        assert -> "Arturo" = "Artur" ++ 'o'
    ]

    ; ===== ===== Testing in-place equivalence ===== =====

    test.prop ":string ++ :string | in-place has the same behavior" [
        [reference inplaced]: inplaceEquivalence "Art" 'append ["uro"]
        assert -> reference = inplaced
    ]
    
    test.prop ":string ++ :char | in-place has the same behavior" [
        [reference inplaced]: inplaceEquivalence "Artur" 'append ['o']
        assert -> reference = inplaced
    ]
    
    test.prop ":char ++ :char | in-place has the same behavior" [
        [reference inplaced]: inplaceEquivalence 'H' 'append ['i']
        assert -> reference = inplaced
    ]

]


suite "Test :block operations" [

    interpreted: ["Arturo" "Ruby" "Python" "Wren"]
    compiled: ["C" "C++" "Nim" "Rust" "Smalltalk"]
    languages: shuffle (append interpreted compiled)

    ; ===== ===== Property-based ===== =====

    test.prop ":block appending results in :block" [
        assert -> block? [] ++ []
        assert -> block? interpreted ++ compiled
    ]
    
    test.prop "appending between :blocks does not nest it" [
        a: @[sample languages]
        b: @[sample languages]
        res: @[first a first b]

        assert -> res = append a b
        assert -> [] = append [] []
        assert -> all? map (append a b) 'x -> not? block? x
    ]

    test.prop "appending :blocks of :T results in :blocks of :T" [
        assert -> all? map ["Arturo"] ++ ["Python"] => string?
        assert -> all? map [1] ++ [2] => integer?
        assert -> all? map [1:2] ++ [2:3] => rational?
    ]

    test.prop "append empty block with 'x results into [x]" [
        number: random 0 85
        res: @[number] 
        assert -> res = [] ++ number
    ]

    test.prop "append empty blocks results on empty block" [
        assert -> empty? [] ++ []
        assert -> [] = [] ++ []
    ]

    ; ===== ===== Examples ===== =====
    
    test {["A" "r" "t"] = ["A" "r"] ++ ["t"]} [
        assert -> ["A" "r" "t"] = ["A" "r"] ++ ["t"]
    ]

    ; ===== ===== Testing in-place equivalence ===== =====

    test.prop ":block ++ :any | in-place has the same behavior" [
        [reference inplaced]: inplaceEquivalence [a b c] 'append -> [d e f]
        assert -> reference = inplaced

        [reference inplaced]: inplaceEquivalence [a b c] 'append [5]
        assert -> reference = inplaced
    ]

]