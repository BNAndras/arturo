; helper function
debug: $[variable][
    print[variable type variable]
]

topic: $[topic :string] [
    print ""
    print ~">> |topic|"
    print ""
]

; ==> Tests

; -- 'append
topic "append"
do [

    ; Arturo doesn't supports in-place for :binary
    topic "append - :binary < :binary :binary"
    do [
        bin0: to :binary 0
        bin1: to :binary 1
        debug append bin0 bin1
    ]

    ; Arturo doesn't supports in-place for :binary
    topic "append - :binary < :binary :integer"
    do [
        bin0: to :binary 0
        int1: 1
        debug append bin0 int1
    ]

    ; :string < :string ++ :string
    topic "append - :string < :string + :string"
    do [

        a: "Art"
        debug append "Art" "uro"
        append 'a "uro", debug a

        b: "Lang"
        debug "Lang" ++ "uage"
        'b ++ "uage", debug b

    ]

    ; :string < :string ++ :char
    topic "append - :string < :string + :char"
    do [

        a: "Artur"
        debug append "Artur" `o`
        append 'a `o`, debug a

        b: "Languag"
        debug "Languag" ++ `e`
        'b ++ `e`, debug b

    ]

    ; :string < :char ++ :char
    topic "append - :string < :char + :char"
    do [

        a: `a`
        debug append `a` `b`
        append 'a `b`, debug a

        b: `c`
        debug `c` ++ `d`
        'b ++ `d`, debug b

    ]

    ; :string < :char ++ :string
    topic "append - :string < :char + :string"
    do [

        a: `a`
        debug append `a` "rt"
        append 'a "rt", debug a

        b: `l`
        debug `l` ++ "ang"
        'b ++ "ang", debug b

    ]

    ; [:string] < [:string] ++ :string
    topic "append - [:string] < [:string] + :string"
    do [

        a: ["A" "r" "t" "u" "r"]
        debug append ["A" "r" "t" "u" "r"]    "o"
        append 'a "o", debug a

        b: ["L" "a" "n" "g" "u" "a" "g"]
        debug ["L" "a" "n" "g" "u" "a" "g"] ++ "e"
        'b ++ "e", debug b

        ; Testing precedence
        c: ["A" "r" "t"]
        debug append ["A" "r" "t"] append "u" append "r"    "o"
        append 'c append "u" append "r" "o", debug c

        d: ["L" "a" "n" "g"]
        debug ["L" "a" "n" "g"] ++ "u" ++ "a" ++ "g" ++ "e"
        'd ++ "u" ++ "a" ++ "g" ++ "e", debug d

    ]

    ; [:string] < [:string] ++ [:string]
    topic "append - [:string] < [:string] + [:string]"
    do [

        a: ["A" "r" "t"]
        debug append ["A" "r" "t"] ["u" "r" "o"]
        append 'a ["u" "r" "o"], debug a

        b: ["L" "a" "n" "g"]
        debug ["L" "a" "n" "g"] ++ ["u" "a" "g" "e"]
        'b ++ ["u" "a" "g" "e"], debug b

    ]

    ; [:integer] < [:integer] ++ [:integer] | :integer
    topic "append - [:integer] < [:integer] + [:integer]|:integer"
    do [

        a: [1 2 3]
        debug append [1 2 3] [4 5 6]
        'a ++ [4 5 6], debug a

        debug append [1 2 3 4 5 6] 7
        'a ++ 7, debug a

    ]
]


; -- 'chop
topic "chop"
do [

    ; with :string
    debug chop "Artu"
    debug chop chop chop "Arturo"

    debug chop.times: 3 "Arturo" ; returns Art :string
    
    s1: "Arturo"
    chop.times: 3 's1, debug s1 ; returns Art :string
    s2: "Artu"
    chop 's2, debug s2
    

    ; with :block
    debug chop [1 2 3 4]
    debug chop chop [1 2 3 4 5]

    b1: [1 2 3 4 5]
    chop.times: 2 'b1, debug b1 ; returns [1 2 3] :block
    debug chop.times: 2 [1 2 3 4 5] ; returns [1 2 3] :block

    b2: [1 2 3 4]
    chop 'b2, debug b2

]

; -- combine
; does not work with literal types
topic "combine"
do [

    debug combine [A B C]
    debug combine [[A B] [C D]]

    debug combine.by:2 [A B C] 
    debug combine.repeated [A B C]
    debug combine.repeated.by:2 [A B C]

    debug combine.count [A B C]
    debug combine.count.repeated.by:2 [A B C]

]

topic "contains?"
do [

    topic "contains? - with :string"
    str: "Arturo"
    debug contains? str "Art"         ; :string
    debug contains? str `t`           ; :char
    debug contains? str {/[Art]/}     ; :regex
    debug contains? str "Football"
    debug contains?.at:0 str "Art"
    debug contains?.at:2 str "Art"


    topic "contains? - with :block"
    block: ["Arturo" "Python" "Ruby"]
    debug contains? block "Arturo"
    debug contains? block "F#"
    debug contains?.at: 0 block "Arturo"
    debug contains?.at: 2 block "Python"

    topic "contains? - with nested :block"
    nested: [
        ["Arturo" "Python" "Ruby"] 
        ["C" "C++" "Nim"]]
    debug contains? nested "Arturo"
    debug contains? nested ["C" "C++" "Nim"]
    debug contains?.at: 0 nested ["C" "C++" "Nim"]
    debug contains?.at: 1 nested "Python"

    topic "contains? - with :range"
    range: 1..10
    debug contains? range 5
    debug contains? range 0

    topic "contains? - with :dictionary"
    dict: #[ name: "John" surname: "Doe"]
    debug contains? keys dict "name"
    debug contains?.at:0 keys dict "name"
    debug contains?.at:1 keys dict "name"
    debug contains? keys dict "id"
    debug contains? dict "John"
    debug contains?.at:0 dict "John"
    debug contains?.at:1 dict "John"
    debug contains? dict "Jane"

]


; -- 'couple
topic "couple"
do [

    ; With the same amount
    debug couple ["one" "two" "three"] [1 2 3]

    ; With different amounts
    bigger: ["one" "two" "three" "I'm out"]
    smaller: [1 2 3]

    debug couple bigger smaller
    debug couple smaller bigger

]

; Does not work with literals
topic "decouple"
do [

    c: [[1 "one"] [2 "two"] [3 "three"]]
    debug decouple c

]


; -- 'drop
topic "drop"
do [

    a: "Arturo"
    debug drop "Arturo" 2
    drop 'a 2, debug a

    b: [ 4 3 2 1 2 3 4 5 ]
    debug drop [ 4 3 2 1 2 3 4 5 ] 3
    drop 'b 3, debug b

]


; -- 'empty
topic "empty"
do [

    b1: ["Arturo" "C" "Python" "Ruby"]
    b2: [1 2 3 4 5 6 7 8 9 10]
    b3: ['north 'south 'east 'west]
    s: "Arturo"
    d: #[ name: "John" surname: "Doe"]

    print "before empty"
    debug b1, debug b2, debug b3
    debug s,  debug d

    empty 'b1, empty 'b2, empty 'b3
    empty 's,  empty 'd

    print "after empty"
    debug b1, debug b2, debug b3
    debug s,  debug d

]

topic "empty?"
do [

    debug empty? "" 
    debug empty? "Arturo" 
    debug empty? [] 
    debug empty? ['north 'south 'east 'west]
    debug empty? #[]
    debug empty? #[ name: "John" surname: "Doe"]

]


; -- 'extend
topic "extend"
do [

    person: #[ name: "john" surname: "doe" ]
    debug person
    debug extend person #[ age: 35 ]

    jane: #[ name: "jane" surname: "doe" ]
    debug jane
    extend 'jane #[ age: 35 ]
    debug jane

]


; -- 'first
topic "first"
do [

    debug first "Arturo"
    debug first.n: 3 "Arturo"

    debug first ["one" "two" "three"]
    debug first.n: 2 ["one" "two" "three"]

    ; This code is recorginized as an :integer
    ; instead of :range
    ; debug first 0..10
    ; debug first.n: 6 0..10

]


; -- 'flatten
topic "flatten"
do [

    arr: [[1 2 3] [4 5 6]]

    debug flatten arr
    debug arr
    flatten 'arr, debug arr

    arr2: [[4 5 6] [1 2 3]]

    debug flatten [1 [2 3] [4 [5 6]]]
    debug flatten.once [1 [2 3] [4 [5 6]]]
    flatten.once 'arr2, debug arr2

]


; -- 'get
topic "get"
do [

    ; TODO:
    ; add for :range, :object, :store, :date, :binary, :bytecode

    user: #[
        name: "John"
        surname: "Doe"
    ]

    debug user\name
    debug user\["name"]
    debug get user 'name
    debug get user 'surname
    debug user\["surname"]

    user\name: "Jane"
    debug get user 'name

    arr: ["zero" "one" "two"]
    debug arr\0
    debug get arr 0

    arr\[0]: "first"
    debug arr

    d: to :date .format: "MMM dd" "Jan 15"
    debug get d 'day
    debug get d 'Month

    name: "John Doe"
    namesInitial: get name 0
    surnamesInitial: get name 5

    debug namesInitial
    debug surnamesInitial

]

topic "in?"
do [

    topic "in? - with :string"
    str: "Arturo"
    debug in? "Art"      str ; :string
    debug in? `t`        str ; :char
    debug in? {/[Art]/}  str ; :regex
    debug in? "Football" str
    debug in?.at:0 "Art" str
    debug in?.at:2 "Art" str


    topic "in? - with :block"
    block: ["Arturo" "Python" "Ruby"]
    debug in? "Arturo"       block
    debug in? "F#"           block
    debug in?.at: 0 "Arturo" block
    debug in?.at: 2 "Python" block

    topic "in? - with nested :block"
    nested: [
        ["Arturo" "Python" "Ruby"] 
        ["C" "C++" "Nim"]]
    debug in? "Arturo"                nested
    debug in? ["C" "C++" "Nim"]       nested
    debug in?.at: 0 ["C" "C++" "Nim"] nested
    debug in?.at: 1 "Python"          nested

    ; range is returning an integer
    ; topic "in? - with :range"
    ; range: 1..10
    ; debug in? 5 range
    ; debug in? 0 range

    topic "in? - with :dictionary"
    dict: #[ name: "John" surname: "Doe"]
    debug in?"name"       keys dict
    debug in?.at:0 "name" keys dict
    debug in?.at:1 "name" keys dict
    debug in? "id"        keys dict
    debug in? "John"      dict
    debug in?.at:0 "John" dict
    debug in?.at:1 "John" dict
    debug in? dict "Jane" dict

]


; -- 'index
topic "index"
do [

    user: #[
        name: "John"
        surname: "Doe"
    ]

    debug index "hello" "e"
    debug index [1 2 3] 3
    debug index "hello" "x" ; returns null
    debug index user "John"
    debug index user "Doe"
    ; range is returning an integer
    ; debug index 2 0..10

]


; -- 'insert
topic "insert"
do [

    ; with :dictionary
    debug insert #[ name: "John" ] "age" 32
    dict: #[ name: "John" ]
    insert 'dict "name" "Joe, Again", debug dict

    ; with :block
    debug insert [1 2 3 4] 0 "zero"
    debug insert [1 2 6 7 8 9 10] 2 [3 4 5]
    arr: [1 2 3 4]
    insert 'arr 0 0, debug arr

    ; with :string
    debug insert "heo" 2 "ll"
    str1: "Auro"
    insert 'str1 1 "rt", debug str1
    
    ; with :string & :char
    ; Can't insert :char
    ; debug insert "helo" 2 `l`
    ; str2: "uby"
    ; insert 'str2 0 `R`, debug str2

]

topic "key?"
do [
    ; TODO: test with :object
    user: #[ name: "John" surname: "Doe" ]
    debug key? user 'name
    debug key? user "name"
    debug key? user 'age
    debug key? user "age"
]


; -- 'keys
topic "keys"
do [
    ; TODO: test with :object
    user: #[ name: "John" surname: "Doe" ]
    debug keys user
]


; -- 'last
topic "last"
do [

    debug last "Arturo"
    debug last.n: 3 "Arturo"

    debug last ["one" "two" "three"]
    debug last.n: 2 ["one" "two" "three"]

    ; This code is recorginized as an :integer
    ; instead of :range
    ; debug last 0..10
    ; debug last.n: 6 0..10

]


; -- 'max
topic "max"
do [

    debug max [4 2 8 5 1 9]
    debug max.index [4 2 8 5 1 9]
    debug max ["Granada" "Manchester" "Boston"]
    debug max.index ["Granada" "Manchester" "Boston"]
    ; This code is recorginized as an :integer
    ; instead of :range
    ; debug max 0..10
    ; debug max.index 0..10

]


; -- 'min
topic "min"
do [

    debug min [4 2 8 5 1 9]
    debug min.index [4 2 8 5 1 9]
    debug min ["Granada" "Manchester" "Boston"]
    debug min.index ["Granada" "Manchester" "Boston"]
    ; This code is recorginized as an :integer
    ; instead of :range
    ; debug max 0..10
    ; debug max.index 0..10

]

topic "one?"
do [

    topic "one? - with :integer"
    debug one? 4-3
    debug one? 5  

    topic "one? - with :floating"
    debug one? 1.0
    debug one? 0.0

    topic "one? - with :string"
    debug one? "A"
    debug one? "Arturo"

    topic "one? - with :block"
    debug one? ["apple"] 
    debug one? ["apple" "pear"] 

    topic "one? - with :range"
    ; returns false, is it right?
    debug one? 0..1
    debug one? 0..10

    topic "one? - with :dictionary"
    ; returns false, is it right?
    debug one? [ name: "John" ]
    debug one? [ name: "John" surname: "Doe" ]

    ; TODO
    ; topic "one? - with :object"

    topic "one? - with :null"
    ; returns false, is it right?
    debug one? null

]


; -- 'permutate
topic "permutate"
do [

    debug permutate [A B C]
    debug permutate [[1 2 3] [4 5 6]]

    debug permutate.by: 2 [A B C]
    debug permutate.repeated [A B C]
    debug permutate.repeated.by: 2 [A B C]

    debug permutate.count [A B C]
    debug permutate.count.repeated.by: 2 
        [A B C]

]

topic "prepend"
do [

    ; Arturo doesn't supports in-place for :binary
    topic "prepend - :binary < :binary :binary"
    do [
        bin0: to :binary 0
        bin1: to :binary 1
        debug prepend bin0 bin1
    ]

    ; Arturo doesn't supports in-place for :binary
    topic "prepend - :binary < :binary :integer"
    do [
        bin0: to :binary 0
        int1: 1
        debug prepend bin0 int1
    ]

    ; :string < :string ++ :string
    topic "prepend - :string < :string + :string"
    do [

        a: "uro"
        debug prepend "uro" "Art"
        prepend 'a "Art", debug a

    ]

    ; :string < :string ++ :char
    topic "prepend - :string < :string + :char"
    do [

        a: "rturo"
        debug prepend "rturo" `A`
        prepend 'a `A`, debug a

    ]

    ; :string < :char ++ :char
    topic "prepend - :string < :char + :char"
    do [

        a: `b`
        debug prepend `b` `a`
        prepend 'a `a`, debug a

    ]

    ; :string < :char ++ :string
    topic "prepend - :string < :char + :string"
    do [

        a: `t`
        debug prepend `t` "ar"
        prepend 'a "ar", debug a

    ]

    ; [:string] < [:string] ++ :string
    topic "prepend - [:string] < [:string] + :string"
    do [

        a: ["r" "t" "u" "r" "o"]
        debug prepend ["r" "t" "u" "r" "o"] "A"
        prepend 'a "A", debug a

        ; Testing precedence
        c: ["u" "r" "o"]
        debug prepend ["u" "r" "o"] prepend "t" prepend "r" "A"
        prepend 'c prepend "t" prepend "r" "A", debug c

    ]

    ; [:string] < [:string] ++ [:string]
    topic "prepend - [:string] < [:string] + [:string]"
    do [

        a: ["u" "r" "o"]
        debug prepend ["u" "r" "o"] ["A" "r" "t"]
        prepend 'a ["A" "r" "t"], debug a

    ]

    ; [:integer] < [:integer] ++ [:integer] | :integer
    topic "prepend - [:integer] < [:integer] + [:integer]|:integer"
    do [

        a: [1 2 3]
        debug prepend [4 5 6] [1 2 3]
        debug prepend [1 2 3 4 5 6] 0
        prepend 'a 0, debug a

    ]

]


; -- 'remove
topic "remove"
do [
    ; default
    topic "remove - default"
    do [

        ; :string
        s1: "Arturo"
        debug remove "Arturo" "uro"
        remove 's1 "uro", debug s1

        s2: "Language"
        debug "Language" -- "uage"
        's2 -- "uage", debug s2

        ; :string -- :char
        s3: "hello"
        debug remove "hello" `l`
        remove 's3 `l`, debug s3

        s4: "hello"
        debug "hello" -- `l`
        's4 -- `l`, debug s4


        ; :block
        debug remove [1 2 3 4] 4
        debug remove [1 2 3 4] [2 4]

        b1: [1 2 3 5 6 4]
        debug [1 2 3 4] -- 4
        debug [1 2 3 4] -- [2 4]
        remove 'b1 [5 6], debug b1

        debug remove [1 6 2 5 3 4 5 6] [5 2]
        debug remove [1 [6 2] 5 3 [6 2] 4 5 6] [6 2]
        
        b2: [1 6 2 5 3 4 5 6]
        b3: [1 [6 2] 5 3 [6 2] 4 5 6]
        remove 'b2 [5 2], debug b2
        remove 'b3 [6 2], debug b3


        ; :dictionary
        debug remove #[name: "John" surname: "Doe"] "John"
        ; Returns SIGSEGV: Illegal storage access. (Attempt to read from nil?)
        ; print #[name: "John" surname: "Doe"] -- "John"
        
        user: #[name: "John" surname: "Doe"]
        user2: #[name: "John" surname: "Wick"]
        remove 'user "John", debug user
        'user2 -- "John", debug user2


    ]

    ; .index
    topic "remove - .index"
    do[

        a: "Arturo"
        ; TODO(COllections/remove) is .index broken?
        ; labels: bug, library
        ; remove.index 3 'a, debug a

    ]

    ; .prefix
    topic "remove - .prefix"
    do [

        a: "test_function.art"
        debug remove.prefix "test_function.art" "test_"
        remove.prefix 'a "test_", debug a

    ]

    ; .suffix
    topic "remove - .suffix"
    do [

        a: "test_function.art"
        debug remove.suffix "test_function.art" ".art"
        remove.suffix 'a ".art", debug a

    ]

    ; .key
    topic "remove - .key"
    do [

        user: #[
            name: "John"
            surname: "Doe"
        ]

        remove.key 'user "surname"
        debug user

    ]

    ; .once
    topic "remove - .once"
    do [

        topic "remove - .once :string"
        debug remove.once "hello" "l"
        ; Is not removing with :char
        ;debug remove.once "hello" `l`
        s1: "hello"
        remove.once 's1 "l", debug s1
        ; Is not removing with :char
        ; s2: "hello"
        ; remove.once 's2 `l`, debug s2
        
        ; :block
        topic "remove - .once :block"
        debug remove.once [1 2 5 3 4 5] 5
        b1: [1 2 5 3 4 5]
        remove.once 'b1 5, debug b1

        ; Testing new behavior from PR #877
        debug remove.once [1 6 2 5 3 4 5 6] [6 2]
        debug remove.once [1 2 [6 2] 5 3 4 5 6] [6 2]
        debug remove.once [1 2 [1 2] 3 4 1 2 [1 2] 3 4]  [1 2]

        b2: [1 6 2 5 3 4 5 6]
        b3: [1 2 [6 2] 5 3 [6 2] 4 5 6]
        b4: [1 2 [1 2] 3 4 1 2 [1 2] 3 4]
        remove.once 'b2 [6 2], debug b2
        remove.once 'b3 [6 2], debug b3
        remove.once 'b4 [1 2], debug b4

        ; :dictionary
        topic "remove - .once :dictionary"
        debug remove.once #[name: "John" surname: "Doe" father: "John"] 
            "John"
        
        user: #[name: "John" surname: "Doe" father: "John"]
        remove.once 'user "John", debug user

    ]

    ; .instance
    topic "remove - .instance"
    do [

        a1: [1 2 [1 2] 1 2 3 [1 2]]
        debug remove.instance [1 2 [1 2] 1 2 3 [1 2]] [1 2]
        remove.instance 'a1 [1 2], debug a1

    ]

    topic "remove - .instance.once"
    do [

        a1: [1 2 [1 2] 1 2 3 [1 2]]
        debug remove.instance.once [1 2 [1 2] 1 2 3 [1 2]] [1 2]
        remove.instance.once 'a1 [1 2], debug a1

    ]
]


; -- 'repeat
topic "repeat"
do [

    debug repeat "hello" 3

    a: "Arturo"
    repeat 'a 3, debug a

    debug repeat [1 2 3] 3
    debug repeat [[1 2 3]] 3
    
    b: [4 5 6]
    repeat 'b 3, debug b

]


; -- 'reverse
topic "reverse"
do [

    ; range is returning an integer

    debug reverse [1 2 3 4 5]
    debug reverse [[1 2 3] [4 5 6] [7 8 9]]
    debug reverse "Manchester"
    ;debug reverse 1..10

    b: [[1 2 3] [4 5 6] [7 8 9]]
    s: "Arturo"
    ; r: 1..10
    reverse 'b, debug b
    reverse 's, debug s
    ;reverse 'r, debug r

    topic "reverse - .exact"
    do [

        ; range is returning an integer

        debug reverse.exact [1 2 3 4 5]
        debug reverse.exact [[1 2 3] [4 5 6] [7 8 9]]
        debug reverse.exact "Manchester"
        ; debug reverse.exact 1..10

        b: [[1 2 3] [4 5 6] [7 8 9]]
        s: "Arturo"
        ; r: 1..10
        reverse.exact 'b, debug b
        reverse.exact 's, debug s
        ; reverse.exact 'r, debug r

    ]

]


topic "rotate"
do [

    ; :block
    debug rotate [2 3 4 5 1] 1 
    b1: [3 4 5 1 2]
    rotate 'b1 2, debug b1

    ; :string
    debug rotate "turoAr" 2
    ; Not working for String literals
    ; s1: "turoAr"
    ; rotate 's1 2, debug s1

    ; -- left
    ; :block
    debug rotate.left [4 5 1 2 3] 2
    b2: [3 4 5 1 2]
    rotate.left 'b2 3
    debug b2

    ; :string
    debug rotate.left "roArtu" 2
    ; Not working for String literals
    ; s2: "oArtur"
    ; rotate.left 's2 1, debug s2

]


; -- 'sample
topic "sample"
do [

    table: ["apple" "appricot" "banana"]
    fruit: sample table

    print type fruit
    print in? fruit table

    ; Broken for ranges
    ; error: cannot perform sample -> :char
    ; alphabet: `a`..`z`
    ; letter: sample alphabet
    ; print type letter
    ; print in? letter alphabet

]


; -- 'set
topic "set"
do [

    ; TODO: test with
    ; :string, :block, :dictionary, 
    ; :object, :store, :binary, :bytecode

    myDict: #[
        name: "John"
        age: 34
    ]

    set myDict 'name "Michael"
    debug myDict

    myDict\name: "Jane"
    debug myDict

    myDict\["name"]: "Christian"
    debug myDict

    arr: [1 2 3 4]
    set arr 0 "one", debug arr

]


; -- 'shuffle
topic "shuffle"
do [

    a: shuffle [1 2 3 4 5 6]
    print size a
    print every? a 'item [ type? item :integer ]

    a: shuffle ["Manchester" "Granada" "Boston" "Davos"]
    print size a
    print every? a 'item [ type? item :string ]

]


; -- 'size
topic "size"
do [

    print size ["one" "two" "three"]
    print size #[name: "John", surname: "Doe"]
    print size "Good morning!"
    print size "Konnichiwa!"
    print size "こんいちわ！"

]


; -- 'slice
topic "slice"
do [

    debug slice "Arturo" 0 2
    debug slice ["Arturo" "Python" "Ruby" "C" "C++" "Nim" "Wren"] 3 5

    a: ["Arturo" "Python" "Ruby" "C" "C++" "Nim" "Wren"]
    b: "Arturo"

    slice 'a 3 5, debug a
    slice 'b 0 2, debug b

]


; -- 'sort
topic "sort"
do [

    ; default
    topic "sort - default"
    do [

        debug sort [5 4 3 2 1]
        debug sort ["Ruby" "Arturo" "Python"]

        a: [5 4 3 2 1]
        b: ["Ruby" "Arturo" "Python"]
        sort 'a, debug a
        sort 'b, debug b

    ]

    ; .values
    topic "sort - .values"
    do [

        user: #[
            name: "John"
            surname: "Doe"
            id: "012568"
            city: "Manchester"
            age: 45
        ]

        sort.values 'user, debug user

    ]

    ; .as
    topic "sort - .as"
    do [

        ; How to use it?

        debug sort.as: 'es ["uno","dos","tres","Uno","Dos","Tres","pero","pértiga","perversión","ábaco","abismo","aberración"]

    ]

    ; .sensitive
    topic "sort - .sensitive"
    do [

        debug sort.sensitive
            ["Ruby" "python" "Arturo" "ruby" "arturo" "Python"]

        a: ["Ruby" "python" "Arturo" "ruby" "arturo" "Python"]
        sort.sensitive 'a, debug a

    ]

    ; descending
    topic "sort - .descending"
    do [

        debug sort.descending [5 3 2 1 4]
        debug sort.descending ["Ruby" "Arturo" "Python"]

        a: [5 4 3 2 1]
        b: ["Ruby" "Arturo" "Python"]
        sort.descending 'a, debug a
        sort.descending 'b, debug b

    ]

    ; .by
    topic "sort - .by"
    do [

        user1: #[ name: "John" surname: "Doe" ]
        user2: #[ name: "Jane" surname: "Doe" ]
        user3: #[ name: "John" surname: "Wick" ]
        user4: #[ name: "Arnold" surname: "Schwarzenegger" ]

        arr: @[user1 user2 user3 user4]
        debug sort.by: "surname" arr
        debug sort.by: 'name arr

    ]
]


; -- 'split
topic "split"
do [

    ; default
    a: "Arturo"
    debug split "Arturo"

    debug split [[1 2 3] [4 5 6] [7 8]]

    topic "split - .path"
    do [

        ; They should return the same result
        (sys\os = "windows")? [
            ; Accepts \\ and / paths
            debug split.path "directory\\wofilerld"
            debug split.path "\\usr\\bin"

            p1: "directory\\wofilerld\\"
            p2: "\\usr\\bin"
        ][
            ; Accepts / paths
            debug split.path "directory/wofilerld"
            debug split.path "/usr/bin"

            p1: "directory/wofilerld/"
            p2: "/usr/bin"
        ]

        debug split.path p1
        debug split.path p2
        split.path 'p1, debug p1
        split.path 'p2, debug p2

        ; tests the Unix's default path and Windows' alternative
        ; Since, you can use it on Msys, for instance
        ; it gives the same result in both
        debug split.path "/usr/bin/"
        debug split.path "/usr/bin"
        debug split.path "usr/bin/"

    ]

    topic "split - .words & .lines"
    do [

        debug split.words "Hello World!"
        debug split.lines "Hi\nmy\nname\nis..."

    ]

    topic "split - .by"
    do [

        debug split.by: "/" "directory/file.ext"

        csv: "id;nickname;name;age"
        split.by: ";" 'csv, debug csv

    ]

    topic "split - .at"
    do [

        debug split.at: 5 "Hello, World"
        debug split.at: 4 [
            "Arnold" "Andreas" "Paul" "Ricard" "Linus"
            "Yanis" "Helena" "Eva" "Blanca"
        ]

        a: [
            "Arnold" "Andreas" "Paul" "Ricard" "Linus"
            "Yanis" "Helena" "Eva" "Blanca"
        ]
        split.at: 4 'a, debug a

    ]

    topic "split - .every"
    do [

        debug split.every: 3 "split collection to components"
        debug split.every: 3 [
            "Arnold" "Andreas" "Paul" "Ricard" "Linus"
            "Yanis" "Helena" "Eva" "Blanca"
        ]


        b: ["Arnold" "Andreas" "Paul" 
            "Ricard" "Linus" "Yanis" 
            "Helena" "Eva" "Blanca"
        ]
        split.every: 3 'b, debug b

        city: split.every: 3 "Manchester"
        print [city, size city\0, size city\1, size city\2, size city\3]

        lang: split.every: 4 "Arturo"
        print [lang, size lang\0, size lang\1]

        city2: "Manchester"
        lang2: "Arturo"
        split.every: 3 'city2
        split.every: 4 'lang2
        print [city2, size city2\0, size city2\1, size city2\2, size city2\3]
        print [lang2, size lang2\0 size, lang2\1]

    ]

]


; -- squeeze
topic "squeeze"
do [

    debug squeeze [1 1 2 3 4 2 3 4 4 5 5 6 7]
    debug squeeze [1 [4 2 3] 1 2 3 [4 2 3] 4 4 5 5 [6 7] [6 7]]
    ; It doesn't squeeze the repeated blocks

    debug squeeze "hello world"

    arr: [4 2 1 1 3 6 6]
    squeeze 'arr, debug arr

]

; -- take
topic "take"
do [

    debug take "some text" 7
    debug take ["Arnold" "Andreas" "Paul"] 2

    arr: 1..10
    take 'arr 3, debug arr

]


; -- unique
topic "unique"
do [
    debug unique [1 2 4 1 3 2]

    a: [1 2 4 1 3 2 5 6 5 7 4]
    unique 'a, a, debug a

    id1: unique.id [1 2 4 1 3 2]
    id2: unique.id [1 2 4 1 3 2 5 6 5 7 4]

    print id1 <> id2

]


; -- values
topic "values"
do [

    user: #[
        name: "John"
        surname: "Doe"
        id: "012568"
        city: "Manchester"
        age: 45
    ]

    debug values user

]
