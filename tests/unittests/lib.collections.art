; helper function
debug: $[variable][
    print[variable type variable]
]

; -- 'append
; :string < :string ++ :string
do [

    a: "Art"
    debug append "Art" "uro"
    append 'a "uro", debug a

    b: "Lang"
    debug "Lang" ++ "uage"
    'b ++ "uage", debug b

]

; :string < :string ++ :char
do [

    a: "Artur"
    debug append "Artur" `o`
    append 'a `o`, debug a

    b: "Languag"
    debug "Languag" ++ `e`
    'b ++ `e`, debug b

]

; :string < :char ++ :char
do [

    a: `a`
    debug append `a` `b`
    append 'a `b`, debug a

    b: `c`
    debug `c` ++ `d`
    'b ++ `d`, debug b

]

; :string < :char ++ :string
do [

    a: `a`
    debug append `a` "rt"
    append 'a "rt", debug a

    b: `l`
    debug `l` ++ "ang"
    'b ++ "ang", debug b

]

; [:string] < [:string] ++ :string
do [

    a: ["A" "r" "t" "u" "r"]
    debug append ["A" "r" "t" "u" "r"]    "o"
    append 'a "o", debug a

    b: ["L" "a" "n" "g" "u" "a" "g"]
    debug ["L" "a" "n" "g" "u" "a" "g"] ++ "e"
    'b ++ "e", debug b

    ; Testing precedence
    c: ["A" "r" "t"]
    debug append ["A" "r" "t"] append "u" append "r"    "o"
    append 'c append "u" append "r" "o", debug c

    d: ["L" "a" "n" "g"]
    debug ["L" "a" "n" "g"] ++ "u" ++ "a" ++ "g" ++ "e"
    'd ++ "u" ++ "a" ++ "g" ++ "e", debug d

]

; [:string] < [:string] ++ [:string]
do [

    a: ["A" "r" "t"]
    debug append ["A" "r" "t"] ["u" "r" "o"]
    append 'a ["u" "r" "o"], debug a

    b: ["L" "a" "n" "g"]
    debug ["L" "a" "n" "g"] ++ ["u" "a" "g" "e"]
    'b ++ ["u" "a" "g" "e"], debug b

]

; [:integer] < [:integer] ++ [:integer] | :integer
do [

    a: [1 2 3]
    debug append [1 2 3] [4 5 6]
    'a ++ [4 5 6], debug a

    debug append [1 2 3 4 5 6] 7
    'a ++ 7, debug a

]

print ""

; -- 'chop
do [

    a: "Arturo"
    debug chop "Artu"
    debug chop chop chop "Arturo"
    ; -- remove me on future
    ; chop chop chop 'a, debug a
    ; I can't do it, but:

    ; TODO(Collections/chop) add times Attribute to remove multiple items
    ; labels: library
    ; Also, times should accepts literals too

    ; -- uncomment me on future
    ; debug chop.times 3 "Arturo" ; returns Art :string
    ; chop.times 3 'a, debug a ; returns Art :string

    b: [1 2 3 4 5]
    debug chop [1 2 3 4]
    debug chop chop [1 2 3 4 5]

    ; -- uncomment me on future
    ; debug chop.times 2 "[1 2 3 4 5] ; returns [1 2 3] :block
    ; chop.times 2 'b, debug b ; returns [1 2 3] :block

    c: "Artu"
    d: [1 2 3 4]
    chop 'c, debug c
    chop 'd, debug d

]

print ""

; -- 'combine
do [

    ; With the same amount
    debug combine ["one" "two" "three"] [1 2 3]

    ; With different amounts
    bigger: ["one" "two" "three" "I'm out"]
    smaller: [1 2 3]

    debug combine bigger smaller
    debug combine smaller bigger

]

print ""

; -- 'drop
do [

    a: "Arturo"
    debug drop "Arturo" 2
    drop 'a 2, debug a

    b: [ 4 3 2 1 2 3 4 5 ]
    debug drop [ 4 3 2 1 2 3 4 5 ] 3
    drop 'b 3, debug b

]