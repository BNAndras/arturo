; helper function
debug: $[variable][
    print[variable type variable]
]

topic: $[topic :string] -> print ~"\n>> |topic|"
passed: $[] -> print "[+] passed!"


; ==> Tests

topic « equal?
do [
    
    topic « equal? - :integer :floating :rational
    
    ensure -> equal? 1 1
    ensure -> equal? 1 1.0
    ensure -> equal? 1 to :rational @[1 1]
    ensure -> equal? 1 to :rational @[5 5]
    ensure -> not? equal? 1 2
    ensure -> not? equal? 1 2.0
    ensure -> not? equal? 1 :rational @[1 2]
    ensure -> 1 = 1
    ensure -> 1 = 1.0
    ensure -> 1 = to :rational @[1 1]
    ensure -> 1 = to :rational @[5 5]
    ensure -> not? 1 = 2
    ensure -> not? 1 = 2.0
    ensure -> not? 1 = :rational @[1 2]
    passed
    
    ensure -> equal? 1.0 1
    ensure -> equal? 1.0 1.0
    ensure -> equal? 1.0 to :rational @[1 1]
    ensure -> equal? 1.0 to :rational @[5 5]
    ensure -> not? equal? 1.0 2
    ensure -> not? equal? 1.0 2.0
    ensure -> not? equal? 1.0 to :rational @[1 2]
    ensure -> 1.0 = 1
    ensure -> 1.0 = 1.0
    ensure -> 1.0 = to :rational @[1 1]
    ensure -> 1.0 = to :rational @[5 5]
    ensure -> not? 1.0 = 2
    ensure -> not? 1.0 = 2.0
    ensure -> not? 1.0 = to :rational @[1 2]
    passed
    
    ensure -> equal? to :rational @[5 5] 1
    ensure -> equal? to :rational @[5 5] 1.0
    ensure -> equal? to :rational @[5 5] to :rational @[1 1]
    ensure -> not? equal? to :rational @[5 5] 2
    ensure -> not? equal? to :rational @[5 5] 2.0
    ensure -> not? equal? to :rational @[5 5] to :rational @[1 2]
    ensure -> (to :rational @[5 5]) = 1
    ensure -> (to :rational @[5 5]) = 1.0
    ensure -> (to :rational @[5 5]) = to :rational @[1 1]
    ensure -> not? (to :rational @[5 5]) = 2
    ensure -> not? (to :rational @[5 5]) = 2.0
    ensure -> not? (to :rational @[5 5]) = to :rational @[1 2]
    passed
    
    topic « equal? - :quantity
    
    ensure -> equal? 1:usd 1
    ensure -> equal? 1:m   1
    ensure -> equal? 1:m2  1
    ensure -> equal? 1:m3  1
    ensure -> equal? 1:c   1
    ensure -> equal? 1:f   1
    ensure -> 1:usd = 1
    ensure -> 1:m   = 1
    ensure -> 1:m2  = 1
    ensure -> 1:m3  = 1
    ensure -> 1:c   = 1
    ensure -> 1:f   = 1
    passed
    
    ensure -> equal? 1 1:usd
    ensure -> equal? 1 1:m
    ensure -> equal? 1 1:m2
    ensure -> equal? 1 1:m3
    ensure -> equal? 1 1:c
    ensure -> equal? 1 1:f
    ensure -> 1 = 1:usd
    ensure -> 1 = 1:m
    ensure -> 1 = 1:m2
    ensure -> 1 = 1:m3
    ensure -> 1 = 1:c
    ensure -> 1 = 1:f
    passed
    
    ensure -> equal? 1:usd 1.0
    ensure -> equal? 1:m   1.0
    ensure -> equal? 1:m2  1.0
    ensure -> equal? 1:m3  1.0
    ensure -> equal? 1:c   1.0
    ensure -> equal? 1:f   1.0
    ensure -> 1:usd = 1.0
    ensure -> 1:m   = 1.0
    ensure -> 1:m2  = 1.0
    ensure -> 1:m3  = 1.0
    ensure -> 1:c   = 1.0
    ensure -> 1:f   = 1.0
    passed
    
    ensure -> equal? 1.0 1:usd
    ensure -> equal? 1.0 1:m
    ensure -> equal? 1.0 1:m2
    ensure -> equal? 1.0 1:m3
    ensure -> equal? 1.0 1:c
    ensure -> equal? 1.0 1:f
    ensure -> 1.0 = 1:usd
    ensure -> 1.0 = 1:m
    ensure -> 1.0 = 1:m2
    ensure -> 1.0 = 1:m3
    ensure -> 1.0 = 1:c
    ensure -> 1.0 = 1:f
    passed
    
    ensure -> equal? 1:usd to :rational @[5 5]
    ensure -> equal? 1:m   to :rational @[5 5]
    ensure -> equal? 1:m2  to :rational @[5 5]
    ensure -> equal? 1:m3  to :rational @[5 5]
    ensure -> equal? 1:c   to :rational @[5 5]
    ensure -> equal? 1:f   to :rational @[5 5]
    ensure -> 1:usd = to :rational @[5 5]
    ensure -> 1:m   = to :rational @[5 5]
    ensure -> 1:m2  = to :rational @[5 5]
    ensure -> 1:m3  = to :rational @[5 5]
    ensure -> 1:c   = to :rational @[5 5]
    ensure -> 1:f   = to :rational @[5 5]
    passed
    
    ensure -> equal? to :rational @[5 5] 1:usd
    ensure -> equal? to :rational @[5 5] 1:m
    ensure -> equal? to :rational @[5 5] 1:m2
    ensure -> equal? to :rational @[5 5] 1:m3
    ensure -> equal? to :rational @[5 5] 1:c
    ensure -> equal? to :rational @[5 5] 1:f
    ensure -> (to :rational @[5 5]) = 1:usd
    ensure -> (to :rational @[5 5]) = 1:m
    ensure -> (to :rational @[5 5]) = 1:m2
    ensure -> (to :rational @[5 5]) = 1:m3
    ensure -> (to :rational @[5 5]) = 1:c
    ensure -> (to :rational @[5 5]) = 1:f
    passed
    
    ensure -> not? equal? 2:usd 1
    ensure -> not? equal? 2 1:usd
    ensure -> not? equal? 2:usd 1.0
    ensure -> not? equal? 2.0 1:usd
    ensure -> not? equal? 2:usd to :rational @[5 5]
    ensure -> not? equal? to :rational @[2 5] 1:usd
    passed
    
    ensure -> equal? 1.5:m 150:cm 
    ensure -> not? equal? 2:m 2:cm
    passed 
    
    topic « equal? - :null
    
    ensure -> equal? null null
    ensure -> equal? null ø
    ensure -> equal? ø ø
    ensure -> equal? ø null
    ensure -> not? equal? ø 1
    ensure -> not? equal? ø 1.0
    ensure -> not? equal? ø "ø"
    ensure -> not? equal? ø `ø`
    ensure -> null = null
    ensure -> null = ø
    ensure -> ø = ø
    ensure -> ø = null
    ensure -> not? ø = 1
    ensure -> not? ø = 1.0
    ensure -> not? ø = "ø"
    ensure -> not? ø = `ø`
    passed
    
    topic « equal? - :logical
    
    ensure -> equal? true true
    ensure -> equal? true (1 > 0)
    ensure -> not? equal? true maybe
    ensure -> not? equal? true false
    ensure -> true = true
    ensure -> true = (1 > 0)
    ensure -> not? true = maybe
    ensure -> not? true = false
    passed
    
    topic « equal? - :complex
    
    ensure -> equal? to :complex [0 2] ((to :complex [1 2]) - 1) 
    ensure -> not? equal? to :complex [1 2] to :complex @[neg 1 2] 
    ensure -> not? equal? to :complex [1 2] 1
    ensure -> not? equal? 1 to :complex [1 2]
    ensure -> (to :complex [0 2]) = ((to :complex [1 2]) - 1) 
    ensure -> not? (to :complex [1 2]) = to :complex @[neg 1 2] 
    ensure -> not? (to :complex [1 2]) = 1
    ensure -> not? 1 = to :complex [1 2]
    passed
    
    topic « equal? - :version
    
    ensure -> equal? 1.2.3 1.2.3
    ensure -> not? equal? 1.2.3 1.2.3-pre
    ensure -> not? equal? 1.2.3 1.2.3-dev
    ensure -> 1.2.3 = 1.2.3
    ensure -> not? 1.2.3 = 1.2.3-pre
    ensure -> not? 1.2.3 = 1.2.3-dev
    passed
    
    topic « equal? - :type
    
    ensure -> equal? :string type "a"
    ensure -> equal? :integer type 1
    ensure -> equal? :floating type 1.5
    passed
    
    ensure -> not? equal? :string :integer
    ensure -> not? equal? :string :char
    ensure -> not? equal? :integer :floating
    passed
    
    topic « equal? - :char
    
    ensure -> equal? `a` `a`
    ensure -> not? equal? `a` "a" 
    ensure -> not? equal? `a` `b`
    ensure -> not? equal? `1` 1
    ensure -> not? equal? "a" `a` 
    ensure -> not? equal? `b` `a`
    ensure -> not? equal? 1   `1`
    ensure -> `a` = `a`
    ensure -> not? `a` = "a" 
    ensure -> not? `a` = `b`
    ensure -> not? `1` =  1
    ensure -> not? "a" = `a` 
    ensure -> not? `b` = `a`
    ensure -> not?  1  = `1`
    passed 
    
    topic « equal? - :string
    
    ensure -> equal? "Art" "Arturo" -- "uro"
    ensure -> not? equal? "A" "B"
    ensure -> not? equal? "Art" "Bob"
    ensure -> not? equal? "a"    `a` 
    ensure -> not? equal? "10"   10 
    ensure -> not? equal? "10"   10
    ensure -> not? equal? ["help"] [help]
    ensure -> not? equal? ["a"]    [a: "a"]
    ensure -> not? equal? "help"   'help
    ensure -> not? equal? ["help"] [.help]
    ensure -> not? equal? ["help"] ['help: "help"]
    ensure -> "Art" = "Arturo" -- "uro"
    ensure -> not? "a"      = `a` 
    ensure -> not? "10"     = 10 
    ensure -> not? "10"     = 10
    ensure -> not? ["help"] = [help]
    ensure -> not? ["a"]    = [a: "a"]
    ensure -> not? "help"   = 'help
    ensure -> not? ["help"] = [.help]
    ensure -> not? ["help"] = ['help: "help"]
    passed
    
    topic « equal? - :word
    
    ensure -> equal? [word] [word]
    ensure -> not? equal? [word] [otherWord]
    ensure -> not? equal? [word] ["word"]
    ensure -> not? equal? [word] [word: word]
    ensure -> not? equal? [word] ['word]
    ; ensure -> not? equal? [word] [.word]
    ensure -> not? equal? [word] [.word: word]
    passed
    
    topic « equal? - :label
    
    ensure -> equal? [label: value] [label: value]
    ensure -> not? equal? [label: value] [label: value2]
    ensure -> not? equal? [label: value] [label2: value]
    ensure -> not? equal? [label: value] ["label"]
    ensure -> not? equal? ["label": value] ["label"]
    ensure -> not? equal? [label: value] ["value"]
    ensure -> not? equal? [label: "value"] ["value"]
    ensure -> not? equal? [label: "value"] ["label" "value"]
    ensure -> not? equal? [label: "value"] [label]
    ensure -> not? equal? [label: "value"] [value]
    ensure -> not? equal? [label: "value"] [label value]
    ensure -> not? equal? [label: 'world] ['label]
    ensure -> not? equal? [label: 'world] ['word]
    ensure -> not? equal? [label: 'world] ['label 'word]
    ensure -> not? equal? [label: .attr] [.label]
    ensure -> not? equal? [label: .attr] [.attr]
    ; ensure -> not? equal? [label: .attr: "a"] [.label: .attr: "a"]
    ensure -> not? equal? [label: .attr: "a"] [.label: "a"]
    ensure -> not? equal? [label: .attr: "a"] [.attr: "a"]
    passed
    
    topic « equal? - :literal
    
    ensure -> equal? 'literal 'literal
    ensure -> not? equal? 'literal 'other
    ensure -> not? equal? 'literal "literal"
    ensure -> not? equal? ['literal] ["literal"]
    ensure -> not? equal? ['literal] [literal]
    ensure -> not? equal? ['literal] [.literal]
    ensure -> not? equal? ['literal] [literal: 'literal]
    passed
    
    topic « equal? - :attribute
    
    ensure -> equal? [.attr] [.attr]
    ensure -> not? equal? [.attr] ["attr"]
    ; ensure -> not? equal? [.attr] [attr]
    ensure -> not? equal? [.attr] [attr: .attr]
    ensure -> not? equal? [.attr] ['attr]
    ensure -> not? equal? [.attr] [.other]
    ensure -> not? equal? [.attr] [.attr: .attr]
    passed
    
    topic « equal? - :attributeLabel
    
    ensure -> equal? [.attr: value] [.attr: value]
    ensure -> not? equal? [.attr: value] ["attr"]
    ensure -> not? equal? [.attr: value] ["value"]
    ensure -> not? equal? [.attr: value] ["attr" "value"]
    ; ensure -> not? equal? [.attr: value] [attr]
    ensure -> not? equal? [.attr: value] [attr: .attr:]
    ; ensure -> not? equal? [.attr: value] [attr: value]
    ensure -> not? equal? [.attr: value] [attr: .attr: value]
    ensure -> not? equal? [.attr: value] ['attr]
    ensure -> not? equal? [.attr: value] ['value]
    ensure -> not? equal? [.attr: value] ['attr 'value]
    ensure -> not? equal? [.attr: value] [.attr]
    ensure -> not? equal? [.attr: value] [.value]
    ensure -> not? equal? [.attr: value] [.other: value]
    ensure -> not? equal? [.attr: value] [.attr: other]
    passed
    
    topic « equal? - :path
    
    a: #[name: "John", surname: "Doe"]
    b: @["Joe" "Jane" "Jesse"]
    
    ensure -> equal? a\name "John" 
    ensure -> equal? a\surname "Doe" 
    ensure -> not? equal? a\name "Jane" 
    ensure -> not? equal? a\name 1
    
    ensure -> equal? b\0 "Joe" 
    ensure -> equal? b\1 "Jane" 
    ensure -> equal? b\2 "Jesse" 
    ensure -> not? equal? b\2 "Walter" 
    
    ensure -> equal? [b\0] [b\0]
    ensure -> equal? [a\name] [a\name]
    ensure -> not? equal? [b\0] [b\1]
    ensure -> not? equal? [a\name] [a\surname]
    passed
    
    topic « equal? - :pathLabel
       
    ensure -> equal? [a\name: "John"] [a\name: "John"]
    ensure -> not? equal? [a\surname: "Doe"] [b\surname: "Doe" ]
    ensure -> not? equal? [a\name: "John"] [b\name: "Jane"]
    ensure -> not? equal? [a\name: "John"] [b\name: "John"]
    passed
    
    topic « equal? - :symbol
    
    ensure -> equal? [+] [+]
    ensure -> not? equal? [+] [-]
    ensure -> not? equal? [+] [++]
    ensure -> not? equal? [+] [`+`]
    ensure -> not? equal? [+] [{+}]
    ensure -> not? equal? [+] ["+"]
    ensure -> not? equal? [+] [plus]
    ensure -> not? equal? [+] ['+]
    passed
    
    topic « equal? - :regex
    
    ensure -> regex? {/[A-Z]/}
    ensure -> equal? {/[A-Z]/} {/[A-Z]/} 
    ensure -> not? equal? {/[A-Z]/} {/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]/}
    ensure -> not? equal? {/[A-Z]/} {[A-Z]}
    ensure -> not? equal? {/[A-Z]/} "/[A-Z]/"
    passed

    topic « equal? - :binary
    
    ensure -> equal? "48 65 6C 6C 6F 20 77 6F 72 6C 64"
        ~{|to :binary "Hello world"|}
    ensure -> equal? "00" ~{|to :binary 0|}
    ensure -> equal? "01" ~{|to :binary 1|}
    ensure -> equal? "0A" ~{|to :binary 10|}
    ensure -> equal? "05" ~{|to :binary 5|}
    a: to :binary 0
    ensure -> not? equal? a 0
    passed

    topic « equal? - :bytecode
    
    x: to :bytecode [["print"][1 112 155]]
    
    ensure -> equal? x to :bytecode [["print"][1 112 155]]
    ensure -> not? equal? x to :bytecode [["print"][2 112 155]]
    ensure -> not? equal? x [["print"][2 112 155]]
    passed

    topic « equal? - :inline
    
    a: [(1 + 1)], b: [(1 + 1)] 
    ensure -> equal? a\0 b\0
    c: [(2 + 1)] 
    ensure -> not? equal? a\0 c\0
    d: [(3 - 1)] 
    ensure -> not? equal? a\0 d\0   ; even the calc (3-1) and (1+1) being 2, 
                                    ; they are different inlines 
                                    ; with the same result when evaluated
    e: [(1 + 2 - 1)]
    ensure -> not? equal? a\0 e\0
    ensure -> not? equal? a\0 2
    passed

    topic « equal? - :block
    
    a: [1 + 1]
    ensure -> equal? a [1 + 1]
    ensure -> not? equal? a [2]
    ensure -> not? equal? a 2
    ensure -> not? equal? a [1 ++ 1]
    passed
    
    topic « equal? :range
    
    ensure -> equal? [0 1 2 3 4 5] @0..5
    ensure -> equal? [0 2 4] @0.. .step: 2 5
    ensure -> equal? @range.step: 2 0 5 @range.step: 2 0 4
    ensure -> not? equal? range.step: 2 0 5 range.step: 2 0 4
    passed

    topic « equal? :dictionary
    
    a: #[name: "Walter" surname: "Pinkman"]
    
    ensure -> equal? a #[name: "Walter" surname: "Pinkman"]
    ensure -> not? equal? a #[name: "Jesse" surname: "Pinkman"]
    ensure -> not? equal? a #[name "Jesse" surname "Pinkman"]
    ensure -> not? equal? a [name "Jesse" surname "Pinkman"]
    passed
    
    ensure -> equal? a\name "Walter"
    ensure -> equal? a\surname "Pinkman"
    ensure -> not? equal? a\surname "White"
    passed

    topic « equal? - :object
    
    define :person [name age][  
        init: -> this\name: capitalize this\name
        print: -> 
            render "NAME: |this\name|, AGE: |this\age|"
    ]
    
    define.as: :person :student [name age id][  
        init: -> this\name: capitalize this\name
        print: -> 
            render "NAME: |this\name|, AGE: |this\age|, ID: |this\id|"
    ]
    
    a: to :person ["Joe" 32]
    ensure -> equal? a to :person ["Joe" 32]
    ensure -> not? equal? to :person ["Joe" 32] #[name: "Joe" age: 32]
    ensure -> not? equal? to :person ["Joe" 32] to :student ["Joe" 32 15]
    passed
    
    a\name: "Jane"
    ensure -> equal? a to :person ["Jane" 32]
    passed
    
    topic « equal? - :store
    
    a: store "test.db"
    a\name: "John" a\surname: "Doe"
    b: store "test.db"
    b\name: "John" b\surname: "Doe"
    c: store "test2.db"
    c\name: "John" c\surname: "Doe"
    d: store "test3.db"
    d\name: "Jane" d\surname: "Doe"
    
    ensure -> equal? a a
    ensure -> equal? a b
    ensure -> equal? b a
    ensure -> not? equal? a c 
    ensure -> not? equal? c a 
    ensure -> not? equal? a d 
    ensure -> not? equal? d a 
    ensure -> not? equal? c d 
    ensure -> not? equal? d c 
    passed
    

    topic « equal? - :color
    
    ensure -> equal? #000 #black
    ensure -> equal? #fff #white
    ensure -> equal? #white #white
    ensure -> not? equal? #black #white
    ensure -> not? equal? #white #black
    passed

    topic « equal? - :function
    
    ensure -> equal? var 'print var 'print
    ensure -> not? equal? var 'inspect var 'print
    passed
    
    a: $[name surname][]
    A: $[name][]
    b: $[name][]
    c: $[name surname][]
    
    ensure -> equal? ~"|var 'a|" ~"|$[name surname][]|"
    ensure -> equal? ~"|var 'a|" ~"|var 'c|"
    ensure -> not? equal? ~"|var 'a|" ~"|var 'A|"
    ensure -> not? equal? ~"|var 'a|" ~"|var 'b|"
    passed

    topic « equal? - :database
    
    ; todo: test this

    topic « equal? - :date
    
    a: to :date .format: "MMM dd" "Jan 15"
    b: to :date .format: "MMM dd" "Jan 15"
    c: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    d: now
    
    ensure -> equal? a b 
    ensure -> not? equal? a c 
    ensure -> not? equal? a d
    passed 
    
    ensure -> equal? a\day c\day
    ensure -> equal? a\month c\month
    ensure -> not? equal? a\year c\year
    passed


    topic « equal? - incompatible types
    
    ; NOTES: 
    ; - to avoid repetition some tests may be not explicitly included
    ; - this test part tries to cover the most of possible behaviors,
    ;     including the possility of the Comparison module be rewritten, 
    ;     avoiding future broken changes
    ; - some combinations were not made, because it's considered very
    ;     improbable to happen, even with a future rewrite of 
    ;     the Comparison module
    
    ; for :integer
    ensure -> not? all? @[
        -> equal? 1 null            -> equal? 1 true
        -> equal? 1 false           -> equal? 1 to :complex [1 1]
        -> equal? 1 1.0.0           -> equal? 1 :integer
        -> equal? 1 `1`             -> equal? 1 "1"
        -> equal? [1] [one]         -> equal? [1] [one:]
        -> equal? [1 1] [one: 1]    -> equal? 1 '1
        -> equal? [1] [.1]          -> equal? [1] [.1:]
        -> equal? [1 1] [.1: 1]     -> equal? [1] [one\1]
        -> equal? [1] [one\1:]    -> equal? [1 1] [one\1: 1]
        -> equal? [1] [+]           -> equal? 1 {/1/}
        -> equal? 1 to :binary 1    -> equal? 1 to :binary 1
        -> equal? [1] [(1)]         -> equal? 1 [1]
        -> equal? 1 1..1            -> equal? 1 #[one: 1]
        -> equal? 0 #black          -> equal? 1 var 'one?
    ] passed
    
    ; for :floating
    ensure -> not? all? @[
        -> equal? 1.0 null              -> equal? 1.0 true
        -> equal? 1.0 false             -> equal? 1.0 to :complex [1.0 1.0]
        -> equal? 1.0 1.0.0             -> equal? 1.0 :floating
        -> equal? 1.0 `1`               -> equal? 1.0 "1.0"
        -> equal? [1.0] [one]           -> equal? [1.0] [one: 1.0]
        -> equal? [1.0 1.0] [one: 1.0]  -> equal? 1.0 '1
        -> equal? [1.0] [.1]            -> equal? [1.0] [.1:]
        -> equal? [1.0 1.0] [.1: 1.0]   -> equal? [1.0] [one\1]
        -> equal? [1.0] [one\1:]        -> equal? [1.0 1.0] [one\1: 1.0]
        -> equal? [1.0] [+]             -> equal? 1.0 {/1.0/}
        -> equal? 1.0 to :binary 1.0    -> equal? 1.0 to :binary 1.0
        -> equal? [1.0] [(1.0)]         -> equal? 1.0 [1]
        -> equal? 1.0 1..1              -> equal? 1.0 #[one: 1.0]
        -> equal? 0.0 #black            -> equal? 1.0 var 'one?
    ] passed
    
    ; for :rational
    a: to :rational [1 1]
    ensure -> not? all? @[
        -> equal? a null                    -> equal? a true
        -> equal? a false                   -> equal? a to :complex [1 1]
        -> equal? a 1.0.0                   -> equal? a :rational
        -> equal? a `1`                     -> equal? a "1/1"
        -> equal? @[a] [one]                -> equal? @[a] [one:]
        -> equal? @[a a] [one: 1]           -> equal? 1 '1
        -> equal? @[a] [.1]                 -> equal? @[a] [.1:]
        -> equal? @[a a] [.1: 1]            -> equal? @[a] [one\1]
        -> equal? @[a] [one\1: 1]           -> equal? @[a a] [one\1: 1]
        -> equal? @[a] [+]                  -> equal? a {/1/1/}
        -> equal? a to :binary 1            -> equal? a to :binary 1
        -> equal? @[a] [(1)]                -> equal? a [1]
        -> equal? a 1..1                    -> equal? a #[one: 1]
        -> equal? to :rational [0 0] #black -> equal? a var 'one?
    ] passed
    
    ; for :quantity
    ensure -> not? all? @[
        -> equal? 1:usd null                    -> equal? 1:usd true
        -> equal? 1:usd false                   -> equal? 1:usd to :complex [1 1]
        -> equal? 1:usd 1.0.0                   -> equal? 1:usd :quantity
        -> equal? 1:usd `1`                     -> equal? 1:usd "1USD"
        -> equal? [1:usd] [one]                 -> equal? [1:usd] [one:]
        -> equal? [1:usd 1:usd] [one: 1:usd]    -> equal? 1:usd '1
        -> equal? [1:usd] [.1]                  -> equal? [1:usd] [.1:]
        -> equal? [1:usd 1:usd] [.1: 1:usd]     -> equal? [1:usd] [one\1]
        -> equal? [1:usd] [one\1:]              -> equal? [1:usd 1:usd] [one\1: 1:usd]
        -> equal? [1:usd] [+]                   -> equal? 1:usd {/1USD/}
        -> equal? 1:usd to :binary 1            -> equal? 1:usd to :binary 1
        -> equal? [1:usd] [(1)]                 -> equal? 1:usd [1:usd]
        -> equal? 1:usd 1..1                    -> equal? 1:usd #[one: 1:usd]
        -> equal? 0:usd #black                  -> equal? 1:usd var 'one?
    ] passed
    
    ensure -> not? all? @[ 
        -> equal? 1:m null              -> equal? 1:m true
        -> equal? 1:m false             -> equal? 1:m to :complex [1 1]
        -> equal? 1:m 1.0.0             -> equal? 1:m :quantity
        -> equal? 1:m `1`               -> equal? 1:m "1m"
        -> equal? [1:m] [one]           -> equal? [1:m] [one:]
        -> equal? [1:m 1:m] [one: 1:m]  -> equal? 1:m '1
        -> equal? [1:m] [.1]            -> equal? [1:m] [.1: 1:m]
        -> equal? [1:m 1:m] [.1: 1:m]   -> equal? [1:m] [one\1]
        -> equal? [1:m] [one\1:]        -> equal? [1:m 1:m] [one\1: 1:m]
        -> equal? [1:m] [+]             -> equal? 1:m {/1m/}
        -> equal? 1:m to :binary 1      -> equal? 1:m to :binary 1
        -> equal? [1:m] [(1)]           -> equal? 1:m [1:m]
        -> equal? 1:m 1..1              -> equal? 1:m #[one: 1:m]
        -> equal? 0:m #black            -> equal? 1:m var 'one?
    ] passed
    
    ensure -> not? all? @[ 
        -> equal? 1:m3 null                 -> equal? 1:m3 true
        -> equal? 1:m3 false                -> equal? 1:m3 to :complex [1 1]
        -> equal? 1:m3 1.0.0                -> equal? 1:m3 :quantity
        -> equal? 1:m3 `1`                  -> equal? 1:m3 "1m³"
        -> equal? [1:m3] [one]              -> equal? [1:m3] [one:]
        -> equal? [1:m3 1:m3] [one: 1:m3]   -> equal? 1:m3 '1
        -> equal? [1:m3] [.1]               -> equal? [1:m3] [.1:]
        -> equal? [1:m3 1:m3] [.1: 1:m3]    -> equal? [1:m3] [one\1]
        -> equal? [1:m3] [one\1:]           -> equal? [1:m3 1:m3] [one\1: 1:m3]
        -> equal? [1:m3] [+]                -> equal? 1:m3 {/1m³/}
        -> equal? 1:m3 to :binary 1         -> equal? 1:m3 to :binary 1
        -> equal? [1:m3] [(1)]              -> equal? 1:m3 [1:m3]
        -> equal? 1:m3 1..1                 -> equal? 1:m3 #[one: 1:m3]
        -> equal? 0:m3 #black               -> equal? 1:m3 var 'one?
    ] passed
    
    ensure -> not? all? @[ 
        -> equal? 1:c null              -> equal? 1:c true
        -> equal? 1:c false             -> equal? 1:c to :complex [1 1]
        -> equal? 1:c 1.0.0             -> equal? 1:c :quantity
        -> equal? 1:c `1`               -> equal? 1:c "1°C"
        -> equal? [1:c] [one]           -> equal? [1:c] [one:]
        -> equal? [1:c 1:c] [one: 1:c]  -> equal? 1:c '1
        -> equal? [1:c] [.1]            -> equal? [1:c] [.1:]
        -> equal? [1:c 1:c] [.1: 1:c]   -> equal? [1:c] [one\1]
        -> equal? [1:c] [one\1:]        -> equal? [1:c 1:c] [one\1: 1:c]
        -> equal? [1:c] [+]             -> equal? 1:c {/1°C/}
        -> equal? 1:c to :binary 1      -> equal? 1:c to :binary 1
        -> equal? [1:c] [(1)]           -> equal? 1:c [1:c]
        -> equal? 1:c 1..1              -> equal? 1:c #[one: 1:c]
        -> equal? 0:c #black            -> equal? 1:c var 'one?
    ] passed
    
    ; for :null
    ensure -> not? all? @[
        -> equal? null 0                        -> equal? null 0.0            
        -> equal? null to :rational [0 0]       -> equal? null true
        -> equal? null false                    -> equal? null to :complex [0 0]
        -> equal? null 0.0.0                    -> equal? null :null
        -> equal? null `ø`                      -> equal? null "null"
        -> equal? @[null] [null]                -> equal? @[null] [null:]
        -> equal? @[null null] [null: null]     -> equal? null 'null
        -> equal? @[null] [.null]               -> equal? @[null] [.null:]
        -> equal? @[null null] [.null: null]    -> equal? @[null] [null\null]
        -> equal? @[null] [null\null:]          -> equal? @[null null] [null\null: null]
        -> equal? @[null] [ø]                   -> equal? null {/null/}
        -> equal? null {/ø/}                    -> equal? null to :binary 0   
        -> equal? null to :binary 0             -> equal? @[null] [(null)]         
        -> equal? null [null]                   -> equal? null 0..0            
        -> equal? null #[null: null]            -> equal? null #black          
        -> equal? null var 'null?
    ] passed
    
    ; for :logical
    ensure -> not? all? @[
        -> equal? true 0                        -> equal? true 0.0            
        -> equal? true to :rational [0 0]
        -> equal? true false                    -> equal? true to :complex [0 0]
        -> equal? true 0.0.0                    -> equal? true :true
        -> equal? true `0`                      -> equal? true "true"
        -> equal? @[true] [true]                -> equal? @[true] [true: true]
        -> equal? @[true true] [true: true]     -> equal? true 'true
        -> equal? @[true] [.true]               -> equal? @[true] [.true:]
        -> equal? @[true true] [.true: true]    -> equal? @[true] [true\true]
        -> equal? @[true] [true\true:]          -> equal? @[true true] [true\true: true]
        -> equal? @[true] [ø]                   -> equal? true {/true/}
        -> equal? true to :binary 0             -> equal? true to :binary 0             
        -> equal? @[true] [(true)]              -> equal? true [true]                   
        -> equal? true 0..0                     -> equal? true #[true: true]            
        -> equal? true #black                   -> equal? true var 'true?
    ] passed
    
    ensure -> not? all? @[
        -> equal? false 0                           -> equal? false 0.0            
        -> equal? false to :rational [0 0]
        -> equal? false false                       -> equal? false to :complex [0 0]
        -> equal? false 0.0.0                       -> equal? false :false
        -> equal? false `0`                         -> equal? false "false"
        -> equal? @[false] [false]                  -> equal? @[false] [false:]
        -> equal? @[false false] [false: false]     -> equal? false 'false
        -> equal? @[false] [.false]                 -> equal? @[false] [.false:]
        -> equal? @[false false] [.false: false]    -> equal? @[false] [false\false]
        -> equal? @[false] [false\false:]           -> equal? @[false false] [false\false: false]
        -> equal? @[false] [ø]                      -> equal? false {/false/}
        -> equal? false to :binary 0                -> equal? false to :binary 0                
        -> equal? @[false] [(false)]                -> equal? false [false]                     
        -> equal? false 0..0                        -> equal? false #[false: false]             
        -> equal? false #black                      -> equal? false var 'false?
    ] passed
    
    ensure -> not? all? @[
        -> equal? maybe 0                           -> equal? maybe 0.0            
        -> equal? maybe to :rational [0 0]
        -> equal? maybe maybe                       -> equal? maybe to :complex [0 0]
        -> equal? maybe 0.0.0                       -> equal? maybe :maybe
        -> equal? maybe `0`                         -> equal? maybe "maybe"
        -> equal? @[maybe] [maybe]                  -> equal? @[maybe] [maybe:]
        -> equal? @[maybe maybe] [maybe: maybe]     -> equal? maybe 'maybe
        -> equal? @[maybe] [.maybe]                 -> equal? @[maybe] [.maybe:]
        -> equal? @[maybe maybe] [.maybe: maybe]    -> equal? @[maybe] [maybe\maybe]
        -> equal? @[maybe] [maybe\maybe:]           -> equal? @[maybe maybe] [maybe\maybe: maybe]
        -> equal? @[maybe] [ø]                      -> equal? maybe {/maybe/}
        -> equal? maybe to :binary 0                -> equal? maybe to :binary 0
        -> equal? @[maybe] [(maybe)]                -> equal? maybe [maybe]
        -> equal? maybe 0..0                        -> equal? maybe #[maybe: maybe]             
        -> equal? maybe #black                      -> equal? maybe var 'maybe?
    ] passed
    
    ; for :complex
    a: to :complex [1 1]
    ensure -> not? all? @[
        -> equal? a 1                       -> equal? a 1.0            
        -> equal? a to :rational [1 1]      -> equal? a null                    
        -> equal? a true                    -> equal? a false
        -> equal? a 1.0.0                   -> equal? a :rational
        -> equal? a `1`                     -> equal? a "1.0+1.0i"
        -> equal? @[a] [one]                -> equal? @[a] [one: 1]
        -> equal? @[a a] [one: 1]           -> equal? 1 '1
        -> equal? @[a] [.1]                 -> equal? @[a] [.1:]
        -> equal? @[a a] [.1: 1]            -> equal? @[a] [one\1]
        -> equal? @[a] [one\1:]             -> equal? @[a a] [one\1: 1]
        -> equal? @[a] [+]                  -> equal? a {/1.0+1.0i/}
        -> equal? a to :binary 1            -> equal? a to :binary 1
        -> equal? @[a] [(1)]                -> equal? a [1]
        -> equal? a 1..1                    -> equal? a #[one: 1]
        -> equal? to :complex [0 0] #black  -> equal? a var 'one?
    ] passed
    
    ; for :version
    ensure -> not? all? @[
        -> equal? 1.0.0 1                       -> equal? 1.0.0 1.0          
        -> equal? 1.0.0 to :rational [1 1]      -> equal? 1.0.0 null                    
        -> equal? 1.0.0 true                    -> equal? 1.0.0 false                   
        -> equal? 1.0.0 to :complex [1.0 1.0]   -> equal? 1.0.0 :floating
        -> equal? 1.0.0 `1`                     -> equal? 1.0.0 "1.0.0"
        -> equal? [1.0.0] [one]                 -> equal? [1.0.0] [one:]
        -> equal? [1.0.0 1.0.0] [one: 1.0.0]    -> equal? 1.0.0 '1
        -> equal? [1.0.0] [.1]                  -> equal? [1.0.0] [.1:]
        -> equal? [1.0.0 1.0.0] [.1: 1.0.0]     -> equal? [1.0.0] [one\1]
        -> equal? [1.0.0] [one\1: 1.0.0]        -> equal? [1.0.0 1.0.0] [one\1: 1.0.0]
        -> equal? [1.0.0] [+]                   -> equal? 1.0.0 {/1.0.0/}
        -> equal? 1.0.0 to :binary 1.0          -> equal? 1.0.0 to :binary 1.0
        -> equal? [1.0.0] [(1.0.0)]             -> equal? 1.0.0 [1.0.0]
        -> equal? 1.0.0 1..1                    -> equal? 1.0.0 #[one: 1.0.0]
        -> equal? 0.0.0 #black                  -> equal? 1.0.0 var 'version?
    ] passed
    
    ; for :type
    ensure -> not? all? @[
        -> equal? :1 1                              -> equal? :1 1.0          
        -> equal? :integer 1                        -> equal? :floating 1.0          
        -> equal? :rational to :rational [1 1]      -> equal? :null null                    
        -> equal? :true true                        -> equal? :false false                   
        -> equal? :logical false                    -> equal? :complex to :complex [1 1]   
        -> equal? :version 1.0.0                    -> equal? :T `T`                         
        -> equal? :char `T`                         -> equal? :string ":type"
        -> equal? [:type] [type]                    -> equal? [:word] [word]                     
        -> equal? [:type] [type:]                   -> equal? [:label] [label:]
        -> equal? [:type :type] [type: :type]       -> equal? :1 '1
        -> equal? :literal '1                       -> equal? [:type] [.type]                      
        -> equal? [:attribute] [.type]              -> equal? [:type] [.type:]
        -> equal? [:attributeLabel] [.type: :type]  -> equal? [:type :type] [.type: :type]         
        -> equal? [:type] [type\type]               -> equal? [:path] [type\type]
        -> equal? [:type] [type\type:]              -> equal? [:pathLabel] [type\type:]            
        -> equal? [:type :type] [type\type: :type]  -> equal? [:type] [+]                       
        -> equal? [:symbol] [+]                     -> equal? :type {/:type/}
        -> equal? :regex {/:type/}                  -> equal? :type to :binary 1.0              
        -> equal? :binary to :binary 1.0            -> equal? [:type] [(:type)]                 
        -> equal? [:inline] [(:type)]               -> equal? :type [:type]
        -> equal? :block [:type]                    -> equal? :type 1..1                        
        -> equal? :range 1..1                       -> equal? :type #[type: :type]
        -> equal? :dictionary #[type: :type]        -> equal? :type #black                      
        -> equal? :color #black                     -> equal? :type var 'type?
        -> equal? :function var 'one?
    ] passed
    
    ; for :char
    ensure -> not? all? @[
        -> equal? `1` 1.0          
        -> equal? `1` to :rational [1 1]    -> equal? `ø` null                    
        -> equal? `t` true                  -> equal? `f` false                   
        -> equal? `1` to :complex [1.0 1.0] -> equal? `T` :floating
        -> equal? [`a`] [one]               -> equal? [`a`] [a: `a`]
        -> equal? [`a` `a`] [a: `a`]        -> equal? `a` 'a
        -> equal? [`a`] [.1]                -> equal? [`a`] [.a:]
        -> equal? [`a` `a`] [.a: `a`]       -> equal? [`a`] [a\a]
        -> equal? [`a`] [a\a:]              -> equal? [`a` `a`] [a\a: `a`]
        -> equal? [`+`] [+]                 -> equal? `a` {/a/}
        -> equal? `1` to :binary 1          -> equal? `a` to :binary 1
        -> equal? [`1`] [(`1`)]             -> equal? `a` [`a`]
        -> equal? `1` 1..1                  -> equal? `a` #[a: `a`]
        -> equal? `1` #black                -> equal? `a` var 'char?
    ] passed
    
    ; for :string
    ensure -> not? all? @[
        -> equal? "1" 1                             -> equal? "1/1" to :rational [1 1]          
        -> equal? "1.0" 1.0                         -> equal? "null" null                    
        -> equal? "" null                           -> equal? "true" true                  
        -> equal? "" false                          -> equal? "false" false                   
        -> equal? "1.0+1.0i" to :complex [1.0 1.0]  -> equal? "type" :floating
        -> equal? "floating" :floating              -> equal? ":floating" :floating
        -> equal? "1.0" :floating                   -> equal? ["a"] [a\a]
        -> equal? ["a"] [a\a:]                      -> equal? ["a" "a"] [a\a: "a"]
        -> equal? ["+"] [+]                         -> equal? "a" {/a/}
        -> equal? "01" to :binary 1                 -> equal? "1" to :binary 1
        -> equal? [""] [("")]                       -> equal? "" [""]
        -> equal? "1" 1..1                          -> equal? "a" #[a: "a"]
        -> equal? "#000000" #black                  -> equal? "000000" #black              
        -> equal? "" var 'char?
    ] passed
    
    ; for :word
    ensure -> not? all? @[        
        -> equal? [rational] @[to :rational [1 1]]      -> equal? [null]  @[null]                    
        -> equal? [true]     @[true]                    -> equal? [false] @[false]                   
        -> equal? [complex]  @[to :complex [1.0 1.0]]   -> equal? [type]  @[:floating]  
        -> equal? [floating] @[:floating]               -> equal? [a]     @[a\a]                   
        -> equal? [a]         [a\a:]                    -> equal? [a]     @[{/a/}]                      
        -> equal? [binary]   @[to :binary 1]            -> equal? [one]   @[to :binary 1]              
        -> equal? [word]     @[(word)]                  -> equal? [word]  @[[word]]                      
        -> equal? [range]    @[range 1 1]               -> equal? [a]     @[#[a: `a`]]               
        -> equal? [black]    @[#black ]                 -> equal? [word]  @[var 'word?]              
        -> equal? [var]      @[var 'word?]
    ] passed
    
    ; for :label
    ensure -> not? all? @[
        -> equal? [rational:] @[to :rational [1 1]]     -> equal? [null:]     @[null]                                                        
        -> equal? [true:]     @[true]                   -> equal? [false:]    @[false]                   
        -> equal? [complex:]  @[to :complex [1.0 1.0]]  -> equal? [floating:] @[:floating]
        -> equal? [type:]     @[:floating]              -> equal? [a:]         [a\a]                     
        -> equal? [a:]         [a\a:]                   -> equal? [a:]        @[{/a:/}]                 
        -> equal? [binary:]   @[to :binary 1]           -> equal? [word:]     @[(word:)]                
        -> equal? [label:]    @[[label:]]               -> equal? [a:]        @[#[a: `a`]]               
        -> equal? [black:]    @[#black ]                -> equal? [var:]      @[var 'word?]
        -> equal? [word:]     @[var 'word?]
    ] passed
    
    ; for :literal
    ; NOTE: technically, '+ is not a :literal, but a :symbolLiteral type ;)
    ensure -> not? all? @[
        -> equal? 'integer  1                   -> equal? 'floating 1.0
        -> equal? 'rational to :rational [1 1]  -> equal? 'one      to :rational [1 1]
        -> equal? 'null     null                -> equal? 'true     true    
        -> equal? 'false    false               -> equal? 'complex  to :complex [1.0 1.0]    
        -> equal? 'type     :floating           -> equal? 'floating :floating               
        -> equal? 'a        a\a                 -> equal? '+        +                       
        -> equal? 'a        {/a/}               -> equal? 'binary   to :binary 1            
        -> equal? 'word     ('word)             -> equal? 'word     ['word]                                     
        -> equal? 'range    1..1                -> equal? 'a        #[a: 'a]                
        -> equal? 'black    #black              -> equal? 'word?    var 'word?              
        -> equal? 'var      var 'var
    ] passed
    
    ; for :attribute
    ensure -> not? all? @[           
        -> equal? [.rational] @[to :rational [1 1]]    -> equal? [.null]     @[null]                  
        -> equal? [.true]     @[true]                  -> equal? [.false]    @[false]                 
        -> equal? [.complex]  @[to :complex [1.0 1.0]] -> equal? [.floating] @[:floating]                          
        -> equal? [.a]        @[{/a:/}]                -> equal? [.binary]   @[to :binary 1]          
        -> equal? [.word]     @[(.word:)]              -> equal? [.label]    @[[.label]]                               
        -> equal? [.a]        @[#[a: `a`]]             -> equal? [.black]    @[#black]                
        -> equal? [.var]      @[var 'word?]            -> equal? [.word]     @[var 'word?]
    ] passed
    
    ; for :attributeLabel
    ensure -> not? all? @[           
        -> equal? [.rational:] @[to :rational [1 1]]    -> equal? [.null:]     @[null]                  
        -> equal? [.true:]     @[true]                  -> equal? [.false:]    @[false]                 
        -> equal? [.complex:]  @[to :complex [1.0 1.0]] -> equal? [.floating:] @[:floating]             
        -> equal? [.a:]        @[a\a]                   -> equal? [.a: `a`]    @[a\a: `a`]              
        -> equal? [.plus:]     @[+]                     -> equal? [.a:]        @[{/a:/}]                
        -> equal? [.binary:]   @[to :binary 1]          -> equal? [.word:]     @[(.word:)]               
        -> equal? [.label:]    @[[label:]]              -> equal? [.a:]        @[#[a: `a`]]             
        -> equal? [.black:]    @[#black]                -> equal? [.var:]      @[var 'word?]            
        -> equal? [.word:]     @[var 'word?]
    ] passed
    
    ; for :path & :pathLabel
    ensure -> not? all? @[
        -> equal? [a\b:] [a\b]
        -> equal? [a\b] [a\b:]
    ] passed

    ; for :regex
    ensure -> not? all? @[
        -> equal? {/1/} 1                               -> equal? {/1/1/} to :rational [1 1]          
        -> equal? {/1.0/} 1.0                           -> equal? {/null/} null                    
        -> equal? {//} null                             -> equal? {/true/} true                  
        -> equal? {//} false                            -> equal? {/false/} false                   
        -> equal? {/1.0+1.0i/} to :complex [1.0 1.0]    -> equal? {/type/} :floating
        -> equal? {/floating/} :floating                -> equal? {/:floating/} :floating
        -> equal? {/1.0/} :floating                     -> equal? [{/a/}] [a\a]
        -> equal? [{/a/}] [a\a:]                        -> equal? [{/a/} {/a/}] [a\a: {/a/}]
        -> equal? [{/\+/}] [+]                          -> equal? {/01/} to :binary 1                 
        -> equal? {/1/} to :binary 1                    -> equal? [{//}] [({//})]                     
        -> equal? {//} [""]                             -> equal? {/1/} 1..1                          
        -> equal? {/a/} #[a: "a"]                       -> equal? {/#000000/} #black                  
        -> equal? {/000000/} #black                     -> equal? {/var/} var 'regex?
        -> equal? {/regex?/} var 'regex?
    ] passed
    
    ; for :binary
    ensure -> not? all? @[
        -> equal? to :binary 1 1                    -> equal? to :binary 1 1.0                
        -> equal? to :binary 1 to :rational [1 1]   -> equal? to :binary 1 1:usd                
        -> equal? to :binary 1 1:m                  -> equal? to :binary 1 1:m3                 
        -> equal? to :binary 1 1:c                  -> equal? to :binary 0 null                 
        -> equal? to :binary 0 true                 -> equal? to :binary 0 false                
        -> equal? to :binary 0 maybe                -> equal? to :binary 1 to :complex [1 1]                  
        -> equal? to :binary 1 1.0.0                -> equal? to :binary 1 :type              
        -> equal? to :binary 1 :binary              -> equal? to :binary 1 `1`                  
        -> equal? to :binary "a" `a`                -> equal? to :binary 1 "01"                 
        -> equal? to :binary 1 "1"                  -> equal? @[to :binary 1] [binary]          
        -> equal? @[to :binary 1] [one]             -> equal? @[to :binary 1] [binary:]         
        -> equal? @[to :binary 1][.binary]          -> equal? @[to :binary 1] [.binary:]        
        -> equal? to :binary 1 {/01/}               -> equal? to :binary 1    {/1/}
    ] passed
    
    ; for :range
    ensure -> not? all? @[
        -> equal? 1..1 1                        -> equal? 1..1 1.0
        -> equal? 1..1 a: to :rational [1 1]    -> equal? 1..1 1:usd
        -> equal? 1..1 1:m                      -> equal? 1..1 1:m3  
        -> equal? 1..1 1:c                      -> equal? 0..0 null 
        -> equal? 0..0 true                     -> equal? 0..0 false
        -> equal? 0..0 maybe                    -> equal? 1..1 to :complex [1 1]
        -> equal? 1..1 1.0.0                    -> equal? 1..1 :type                        
        -> equal? 1..1 :range                   -> equal? 1..1 `1` 
        -> equal? 1..1 "1"                      -> equal? 1..1 'range  
        -> equal? 1..1 {/1/}
    ] passed
    
    ; for :dictionary, :object & :date
    define :person [name surname][]
    
    a: to :person ["Walter" "Pinkman"]
    b: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    
    ensure -> not? all? @[
        -> equal? #[name: "Walter" surname: "Pinkman"] a
        -> equal? a #[name: "Walter" surname: "Pinkman"]
        -> equal? #[year: 2023 day: 15 Month: "January"] b
        -> equal? b #[year: 2023 day: 15 Month: "January"]
    ] passed
    
    ; for :color
    ensure -> not? all? @[
        -> equal? #black 0                  -> equal? #black 0.0
        -> equal? #black to :rational [0 0] -> equal? #black 0:usd 
        -> equal? #black 0:m                -> equal? #black 0:m3
        -> equal? #black 0:c                -> equal? #black null 
        -> equal? #black true               -> equal? #black false 
        -> equal? #black maybe              -> equal? #black to :complex [0 0]
        -> equal? #black 0.0.0              -> equal? #black :color
        -> equal? #black `1`                -> equal? #black "#000000"
        -> equal? #black "000000"           -> equal? [#black] [black] 
        -> equal? #black 'black             -> equal? [#black] [.black]
        -> equal? [#black] [.black:]        -> equal? #black  {/#000000/}                 
        -> equal? #black{/000000/} 
    ] passed
    
    ; for :function
    ensure -> not? all? @[
        -> equal? var 'null?     null       -> equal? var 'true?    true  
        -> equal? var 'false?    false      -> equal? var 'maybe?   maybe 
        -> equal? var 'version?  1.0.0      -> equal? var 'type?    :type 
        -> equal? var 'function? :function  -> equal? var 'char?    `a` 
        -> equal? @[var 'word?]  [word]     -> equal? @[var 'word?] [var]      
        -> equal? @[var 'word?]  [var:]     -> equal? @[var 'word?] [word:]    
        -> equal? var 'word?     'word?     -> equal? var 'var      'var       
        -> equal? @[var 'word?]  [.var]     -> equal? @[var 'word?] [.word]    
        -> equal? @[var 'word?]  [.var:]    -> equal? @[var 'word?] [.word:]   
        -> equal? var 'regex?    {/var/}    -> equal? var 'regex?   {/regex?/} 
    ] passed
    
]

topic « notEqual?
do [
    
    topic « notEqual? - :integer :floating :rational
    
    ensure -> not? notEqual? 1 1
    ensure -> not? notEqual? 1 1.0
    ensure -> not? notEqual? 1 to :rational @[1 1]
    ensure -> not? notEqual? 1 to :rational @[5 5]
    ensure -> notEqual? 1 2
    ensure -> notEqual? 1 2.0
    ensure -> notEqual? 1 :rational @[1 2]
    ensure -> not? 1 <> 1
    ensure -> not? 1 <> 1.0
    ensure -> not? 1 <> to :rational @[1 1]
    ensure -> not? 1 <> to :rational @[5 5]
    ensure -> 1 <> 2
    ensure -> 1 <> 2.0
    ensure -> 1 <> :rational @[1 2]
    passed
    
    ensure -> not? notEqual? 1.0 1
    ensure -> not? notEqual? 1.0 1.0
    ensure -> not? notEqual? 1.0 to :rational @[1 1]
    ensure -> not? notEqual? 1.0 to :rational @[5 5]
    ensure -> notEqual? 1.0 2
    ensure -> notEqual? 1.0 2.0
    ensure -> notEqual? 1.0 to :rational @[1 2]
    ensure -> not? 1.0 <> 1
    ensure -> not? 1.0 <> 1.0
    ensure -> not? 1.0 <> to :rational @[1 1]
    ensure -> not? 1.0 <> to :rational @[5 5]
    ensure -> 1.0 <> 2
    ensure -> 1.0 <> 2.0
    ensure -> 1.0 <> to :rational @[1 2]
    passed
    
    ensure -> not? notEqual? to :rational @[5 5] 1
    ensure -> not? notEqual? to :rational @[5 5] 1.0
    ensure -> not? notEqual? to :rational @[5 5] to :rational @[1 1]
    ensure -> notEqual? to :rational @[5 5] 2
    ensure -> notEqual? to :rational @[5 5] 2.0
    ensure -> notEqual? to :rational @[5 5] to :rational @[1 2]
    ensure -> not? (to :rational @[5 5]) <> 1
    ensure -> not? (to :rational @[5 5]) <> 1.0
    ensure -> not? (to :rational @[5 5]) <> to :rational @[1 1]
    ensure -> (to :rational @[5 5]) <> 2
    ensure -> (to :rational @[5 5]) <> 2.0
    ensure -> (to :rational @[5 5]) <> to :rational @[1 2]
    passed
    
    topic « notEqual? - :quantity
    
    ensure -> not? notEqual? 1:usd 1
    ensure -> not? notEqual? 1:m   1
    ensure -> not? notEqual? 1:m2  1
    ensure -> not? notEqual? 1:m3  1
    ensure -> not? notEqual? 1:c   1
    ensure -> not? notEqual? 1:f   1
    ensure -> not? 1:usd <> 1
    ensure -> not? 1:m   <> 1
    ensure -> not? 1:m2  <> 1
    ensure -> not? 1:m3  <> 1
    ensure -> not? 1:c   <> 1
    ensure -> not? 1:f   <> 1
    passed
    
    ensure -> not? notEqual? 1 1:usd
    ensure -> not? notEqual? 1 1:m
    ensure -> not? notEqual? 1 1:m2
    ensure -> not? notEqual? 1 1:m3
    ensure -> not? notEqual? 1 1:c
    ensure -> not? notEqual? 1 1:f
    ensure -> not? 1 <> 1:usd
    ensure -> not? 1 <> 1:m
    ensure -> not? 1 <> 1:m2
    ensure -> not? 1 <> 1:m3
    ensure -> not? 1 <> 1:c
    ensure -> not? 1 <> 1:f
    passed
    
    ensure -> not? notEqual? 1:usd 1.0
    ensure -> not? notEqual? 1:m   1.0
    ensure -> not? notEqual? 1:m2  1.0
    ensure -> not? notEqual? 1:m3  1.0
    ensure -> not? notEqual? 1:c   1.0
    ensure -> not? notEqual? 1:f   1.0
    ensure -> not? 1:usd <> 1.0
    ensure -> not? 1:m   <> 1.0
    ensure -> not? 1:m2  <> 1.0
    ensure -> not? 1:m3  <> 1.0
    ensure -> not? 1:c   <> 1.0
    ensure -> not? 1:f   <> 1.0
    passed
    
    ensure -> not? notEqual? 1.0 1:usd
    ensure -> not? notEqual? 1.0 1:m
    ensure -> not? notEqual? 1.0 1:m2
    ensure -> not? notEqual? 1.0 1:m3
    ensure -> not? notEqual? 1.0 1:c
    ensure -> not? notEqual? 1.0 1:f
    ensure -> not? 1.0 <> 1:usd
    ensure -> not? 1.0 <> 1:m
    ensure -> not? 1.0 <> 1:m2
    ensure -> not? 1.0 <> 1:m3
    ensure -> not? 1.0 <> 1:c
    ensure -> not? 1.0 <> 1:f
    passed
    
    ensure -> not? notEqual? 1:usd to :rational @[5 5]
    ensure -> not? notEqual? 1:m   to :rational @[5 5]
    ensure -> not? notEqual? 1:m2  to :rational @[5 5]
    ensure -> not? notEqual? 1:m3  to :rational @[5 5]
    ensure -> not? notEqual? 1:c   to :rational @[5 5]
    ensure -> not? notEqual? 1:f   to :rational @[5 5]
    ensure -> not? 1:usd <> to :rational @[5 5]
    ensure -> not? 1:m   <> to :rational @[5 5]
    ensure -> not? 1:m2  <> to :rational @[5 5]
    ensure -> not? 1:m3  <> to :rational @[5 5]
    ensure -> not? 1:c   <> to :rational @[5 5]
    ensure -> not? 1:f   <> to :rational @[5 5]
    passed
    
    ensure -> not? notEqual? to :rational @[5 5] 1:usd
    ensure -> not? notEqual? to :rational @[5 5] 1:m
    ensure -> not? notEqual? to :rational @[5 5] 1:m2
    ensure -> not? notEqual? to :rational @[5 5] 1:m3
    ensure -> not? notEqual? to :rational @[5 5] 1:c
    ensure -> not? notEqual? to :rational @[5 5] 1:f
    ensure -> not? (to :rational @[5 5]) <> 1:usd
    ensure -> not? (to :rational @[5 5]) <> 1:m
    ensure -> not? (to :rational @[5 5]) <> 1:m2
    ensure -> not? (to :rational @[5 5]) <> 1:m3
    ensure -> not? (to :rational @[5 5]) <> 1:c
    ensure -> not? (to :rational @[5 5]) <> 1:f
    passed
    
    ensure -> notEqual? 2:usd 1
    ensure -> notEqual? 2 1:usd
    ensure -> notEqual? 2:usd 1.0
    ensure -> notEqual? 2.0 1:usd
    ensure -> notEqual? 2:usd to :rational @[5 5]
    ensure -> notEqual? to :rational @[2 5] 1:usd
    passed
    
    ensure -> not? notEqual? 1.5:m 150:cm 
    ensure -> notEqual? 2:m 2:cm
    passed 
    
    topic « notEqual? - :null
    
    ensure -> not? notEqual? null null
    ensure -> not? notEqual? null ø
    ensure -> not? notEqual? ø ø
    ensure -> not? notEqual? ø null
    ensure -> notEqual? ø 1
    ensure -> notEqual? ø 1.0
    ensure -> notEqual? ø "ø"
    ensure -> notEqual? ø `ø`
    ensure -> not? null <> null
    ensure -> not? null <> ø
    ensure -> not? ø <> ø
    ensure -> not? ø <> null
    ensure -> ø <> 1
    ensure -> ø <> 1.0
    ensure -> ø <> "ø"
    ensure -> ø <> `ø`
    passed
    
    topic « notEqual? - :logical
    
    ensure -> not? notEqual? true true
    ensure -> not? notEqual? true (1 > 0)
    ensure -> notEqual? true maybe
    ensure -> notEqual? true false
    ensure -> not? true <> true
    ensure -> not? true <> (1 > 0)
    ensure -> true <> maybe
    ensure -> true <> false
    passed
    
    topic « notEqual? - :complex
    
    ensure -> not? notEqual? to :complex [0 2] ((to :complex [1 2]) - 1) 
    ensure -> notEqual? to :complex [1 2] to :complex @[neg 1 2] 
    ensure -> notEqual? to :complex [1 2] 1
    ensure -> notEqual? 1 to :complex [1 2]
    ensure -> not? (to :complex [0 2]) <> ((to :complex [1 2]) - 1) 
    ensure -> (to :complex [1 2]) <> to :complex @[neg 1 2] 
    ensure -> (to :complex [1 2]) <> 1
    ensure -> 1 <> to :complex [1 2]
    passed
    
    topic « notEqual? - :version
    
    ensure -> not? notEqual? 1.2.3 1.2.3
    ensure -> notEqual? 1.2.3 1.2.3-pre
    ensure -> notEqual? 1.2.3 1.2.3-dev
    ensure -> not? 1.2.3 <> 1.2.3
    ensure -> 1.2.3 <> 1.2.3-pre
    ensure -> 1.2.3 <> 1.2.3-dev
    passed
    
    topic « notEqual? - :type
    
    ensure -> not? notEqual? :string type "a"
    ensure -> not? notEqual? :integer type 1
    ensure -> not? notEqual? :floating type 1.5
    passed
    
    ensure -> notEqual? :string :integer
    ensure -> notEqual? :string :char
    ensure -> notEqual? :integer :floating
    passed
    
    topic « notEqual? - :char
    
    ensure -> not? notEqual? `a` `a`
    ensure -> notEqual? `a` "a" 
    ensure -> notEqual? `a` `b`
    ensure -> notEqual? `1` 1
    ensure -> notEqual? "a" `a` 
    ensure -> notEqual? `b` `a`
    ensure -> notEqual? 1   `1`
    ensure -> not? `a` <> `a`
    ensure -> `a` <> "a" 
    ensure -> `a` <> `b`
    ensure -> `1` <>  1
    ensure -> "a" <> `a` 
    ensure -> `b` <> `a`
    ensure ->  1  <> `1`
    passed 
    
    topic « notEqual? - :string
    
    ensure -> not? notEqual? "Art" "Arturo" -- "uro"
    ensure -> notEqual? "A" "B"
    ensure -> notEqual? "Art" "Bob"
    ensure -> notEqual? "a"    `a` 
    ensure -> notEqual? "10"   10 
    ensure -> notEqual? "10"   10
    ensure -> notEqual? ["help"] [help]
    ensure -> notEqual? ["a"]    [a: "a"]
    ensure -> notEqual? "help"   'help
    ensure -> notEqual? ["help"] [.help]
    ensure -> notEqual? ["help"] ['help: "help"]
    ensure -> not? "Art" <> "Arturo" -- "uro"
    ensure -> "a"      <> `a` 
    ensure -> "10"     <> 10 
    ensure -> "10"     <> 10
    ensure -> ["help"] <> [help]
    ensure -> ["a"]    <> [a: "a"]
    ensure -> "help"   <> 'help
    ensure -> ["help"] <> [.help]
    ensure -> ["help"] <> ['help: "help"]
    passed
    
    topic « notEqual? - :word
    
    ensure -> not? notEqual? [word] [word]
    ensure -> notEqual? [word] [otherWord]
    ensure -> notEqual? [word] ["word"]
    ensure -> notEqual? [word] [word: word]
    ensure -> notEqual? [word] ['word]
    ; ensure -> notEqual? [word] [.word]
    ensure -> notEqual? [word] [.word: word]
    passed
    
    topic « notEqual? - :label
    
    ensure -> not? notEqual? [label: value] [label: value]
    ensure -> notEqual? [label: value] [label: value2]
    ensure -> notEqual? [label: value] [label2: value]
    ensure -> notEqual? [label: value] ["label"]
    ensure -> notEqual? ["label": value] ["label"]
    ensure -> notEqual? [label: value] ["value"]
    ensure -> notEqual? [label: "value"] ["value"]
    ensure -> notEqual? [label: "value"] ["label" "value"]
    ensure -> notEqual? [label: "value"] [label]
    ensure -> notEqual? [label: "value"] [value]
    ensure -> notEqual? [label: "value"] [label value]
    ensure -> notEqual? [label: 'world] ['label]
    ensure -> notEqual? [label: 'world] ['word]
    ensure -> notEqual? [label: 'world] ['label 'word]
    ensure -> notEqual? [label: .attr] [.label]
    ensure -> notEqual? [label: .attr] [.attr]
    ; ensure -> notEqual? [label: .attr: "a"] [.label: .attr: "a"]
    ensure -> notEqual? [label: .attr: "a"] [.label: "a"]
    ensure -> notEqual? [label: .attr: "a"] [.attr: "a"]
    passed
    
    topic « notEqual? - :literal
    
    ensure -> not? notEqual? 'literal 'literal
    ensure -> notEqual? 'literal 'other
    ensure -> notEqual? 'literal "literal"
    ensure -> notEqual? ['literal] ["literal"]
    ensure -> notEqual? ['literal] [literal]
    ensure -> notEqual? ['literal] [.literal]
    ensure -> notEqual? ['literal] [literal: 'literal]
    passed
    
    topic « notEqual? - :attribute
    
    ensure -> not? notEqual? [.attr] [.attr]
    ensure -> notEqual? [.attr] ["attr"]
    ; ensure -> notEqual? [.attr] [attr]
    ensure -> notEqual? [.attr] [attr: .attr]
    ensure -> notEqual? [.attr] ['attr]
    ensure -> notEqual? [.attr] [.other]
    ensure -> notEqual? [.attr] [.attr: .attr]
    passed
    
    topic « notEqual? - :attributeLabel
    
    ensure -> not? notEqual? [.attr: value] [.attr: value]
    ensure -> notEqual? [.attr: value] ["attr"]
    ensure -> notEqual? [.attr: value] ["value"]
    ensure -> notEqual? [.attr: value] ["attr" "value"]
    ; ensure -> notEqual? [.attr: value] [attr]
    ensure -> notEqual? [.attr: value] [attr: .attr:]
    ; ensure -> notEqual? [.attr: value] [attr: value]
    ensure -> notEqual? [.attr: value] [attr: .attr: value]
    ensure -> notEqual? [.attr: value] ['attr]
    ensure -> notEqual? [.attr: value] ['value]
    ensure -> notEqual? [.attr: value] ['attr 'value]
    ensure -> notEqual? [.attr: value] [.attr]
    ensure -> notEqual? [.attr: value] [.value]
    ensure -> notEqual? [.attr: value] [.other: value]
    ensure -> notEqual? [.attr: value] [.attr: other]
    passed
    
    topic « notEqual? - :path
    
    a: #[name: "John", surname: "Doe"]
    b: @["Joe" "Jane" "Jesse"]
    
    ensure -> not? notEqual? a\name "John" 
    ensure -> not? notEqual? a\surname "Doe" 
    ensure -> notEqual? a\name "Jane" 
    ensure -> notEqual? a\name 1
    
    ensure -> not? notEqual? b\0 "Joe" 
    ensure -> not? notEqual? b\1 "Jane" 
    ensure -> not? notEqual? b\2 "Jesse" 
    ensure -> notEqual? b\2 "Walter" 
    
    ensure -> not? notEqual? [b\0] [b\0]
    ensure -> not? notEqual? [a\name] [a\name]
    ensure -> notEqual? [b\0] [b\1]
    ensure -> notEqual? [a\name] [a\surname]
    passed
    
    topic « notEqual? - :pathLabel
       
    ensure -> not? notEqual? [a\name: "John"] [a\name: "John"]
    ensure -> notEqual? [a\surname: "Doe"] [b\surname: "Doe" ]
    ensure -> notEqual? [a\name: "John"] [b\name: "Jane"]
    ensure -> notEqual? [a\name: "John"] [b\name: "John"]
    passed
    
    topic « notEqual? - :symbol
    
    ensure -> not? notEqual? [+] [+]
    ensure -> notEqual? [+] [-]
    ensure -> notEqual? [+] [++]
    ensure -> notEqual? [+] [`+`]
    ensure -> notEqual? [+] [{+}]
    ensure -> notEqual? [+] ["+"]
    ensure -> notEqual? [+] [plus]
    ensure -> notEqual? [+] ['+]
    passed
    
    topic « notEqual? - :regex
    
    ensure -> regex? {/[A-Z]/}
    ensure -> not? notEqual? {/[A-Z]/} {/[A-Z]/} 
    ensure -> notEqual? {/[A-Z]/} {/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]/}
    ensure -> notEqual? {/[A-Z]/} {[A-Z]}
    ensure -> notEqual? {/[A-Z]/} "/[A-Z]/"
    passed
    
    topic « notEqual? - :binary
    
    ensure -> not? notEqual? "48 65 6C 6C 6F 20 77 6F 72 6C 64"
        ~{|to :binary "Hello world"|}
    ensure -> not? notEqual? "00" ~{|to :binary 0|}
    ensure -> not? notEqual? "01" ~{|to :binary 1|}
    ensure -> not? notEqual? "0A" ~{|to :binary 10|}
    ensure -> not? notEqual? "05" ~{|to :binary 5|}
    a: to :binary 0
    ensure -> notEqual? a 0
    passed
    
    topic « notEqual? - :bytecode
    
    x: to :bytecode [["print"][1 112 155]]
    
    ensure -> not? notEqual? x to :bytecode [["print"][1 112 155]]
    ensure -> notEqual? x to :bytecode [["print"][2 112 155]]
    ensure -> notEqual? x [["print"][2 112 155]]
    passed
    
    topic « notEqual? - :inline
    
    a: [(1 + 1)], b: [(1 + 1)] 
    ensure -> not? notEqual? a\0 b\0
    c: [(2 + 1)] 
    ensure -> notEqual? a\0 c\0
    d: [(3 - 1)] 
    ensure -> notEqual? a\0 d\0 ; even the calc (3-1) and (1+1) being 2, 
                                ; they are different inlines 
                                ; with the same result when evaluated
    e: [(1 + 2 - 1)]
    ensure -> notEqual? a\0 e\0
    ensure -> notEqual? a\0 2
    passed
    
    topic « notEqual? - :block
    
    a: [1 + 1]
    ensure -> not? notEqual? a [1 + 1]
    ensure -> notEqual? a [2]
    ensure -> notEqual? a 2
    ensure -> notEqual? a [1 ++ 1]
    passed
    
    topic « notEqual? :range
    
    ensure -> not? notEqual? [0 1 2 3 4 5] @0..5
    ensure -> not? notEqual? [0 2 4] @0.. .step: 2 5
    ensure -> not? notEqual? @range.step: 2 0 5 @range.step: 2 0 4
    ensure -> notEqual? range.step: 2 0 5 range.step: 2 0 4
    passed
    
    topic « notEqual? :dictionary
    
    a: #[name: "Walter" surname: "Pinkman"]
    
    ensure -> not? notEqual? a #[name: "Walter" surname: "Pinkman"]
    ensure -> notEqual? a #[name: "Jesse" surname: "Pinkman"]
    ensure -> notEqual? a #[name "Jesse" surname "Pinkman"]
    ensure -> notEqual? a [name "Jesse" surname "Pinkman"]
    passed
    
    ensure -> not? notEqual? a\name "Walter"
    ensure -> not? notEqual? a\surname "Pinkman"
    ensure -> notEqual? a\surname "White"
    passed
    
    topic « notEqual? - :object
    
    define :person [name age][  
        init: -> this\name: capitalize this\name
        print: -> 
            render "NAME: |this\name|, AGE: |this\age|"
    ]
    
    define.as: :person :student [name age id][  
        init: -> this\name: capitalize this\name
        print: -> 
            render "NAME: |this\name|, AGE: |this\age|, ID: |this\id|"
    ]
    
    a: to :person ["Joe" 32]
    ensure -> not? notEqual? a to :person ["Joe" 32]
    ensure -> notEqual? to :person ["Joe" 32] #[name: "Joe" age: 32]
    ensure -> notEqual? to :person ["Joe" 32] to :student ["Joe" 32 15]
    passed
    
    a\name: "Jane"
    ensure -> not? notEqual? a to :person ["Jane" 32]
    passed
    
    topic « notEqual? - :store
    
    a: store "test.db"
    a\name: "John" a\surname: "Doe"
    b: store "test.db"
    b\name: "John" b\surname: "Doe"
    c: store "test2.db"
    c\name: "John" c\surname: "Doe"
    d: store "test3.db"
    d\name: "Jane" d\surname: "Doe"
    
    ensure -> not? notEqual? a a
    ensure -> not? notEqual? a b
    ensure -> not? notEqual? b a
    ensure -> notEqual? a c 
    ensure -> notEqual? c a 
    ensure -> notEqual? a d 
    ensure -> notEqual? d a 
    ensure -> notEqual? c d 
    ensure -> notEqual? d c 
    passed
    
    topic « notEqual? - :color
    
    ensure -> not? notEqual? #000 #black
    ensure -> not? notEqual? #fff #white
    ensure -> not? notEqual? #white #white
    ensure -> notEqual? #black #white
    ensure -> notEqual? #white #black
    passed
    
    topic « notEqual? - :function
    
    ensure -> not? notEqual? var 'print var 'print
    ensure -> notEqual? var 'inspect var 'print
    passed
    
    a: $[name surname][]
    A: $[name][]
    b: $[name][]
    c: $[name surname][]
    
    ensure -> not? notEqual? ~"|var 'a|" ~"|$[name surname][]|"
    ensure -> not? notEqual? ~"|var 'a|" ~"|var 'c|"
    ensure -> notEqual? ~"|var 'a|" ~"|var 'A|"
    ensure -> notEqual? ~"|var 'a|" ~"|var 'b|"
    passed
    
    
]

; integer comparisons

print notEqual? 1 1
print 1<>1
print notEqual? 1 2
print 1<>2

print less? 1 1
print 1<1
print less? 1 2
print 1<2

print lessOrEqual? 1 1
print 1=<1
print lessOrEqual? 1 2
print 1=<2

print greater? 1 1
print 1>1
print greater? 2 1
print 2>1

print greaterOrEqual? 1 1
print 1>=1
print greaterOrEqual? 2 1
print 2>=1

; floating comparisons

print 3.0>2
print 1.123 < 1.023

; floating-integer comparisons

print 3.0>2
print 2<3.14

; other types

str: "hello"
print "boom"<>str

print "hello">"iceland"
print "hello"<"iceland"

print [1 2 3 4]>[1 2 3]

a: to :date .format: "YYYY" "2002"
b: to :date .format: "YYYY" "2001"
print a > b
print a < b

a: to :date .format: "MMM dd" "Jan 15"
b: to :date .format: "MMM dd" "Jan 14"
print a > b
print a < b

a: to :date .format: "HH:mm" "13:25"
b: to :date .format: "HH:mm" "12:12"
print a > b
print a < b
