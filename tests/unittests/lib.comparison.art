; helper function
debug: $[variable][
    print[variable type variable]
]

topic: $[topic :string] -> print ~"\n>> |topic|"
passed: $[] -> print "[+] passed!"


; ==> Tests

topic « equal?
do [
    
    topic « equal? - :integer :floating :rational
    
    ensure -> equal? 1 1
    ensure -> equal? 1 1.0
    ensure -> equal? 1 to :rational @[1 1]
    ensure -> equal? 1 to :rational @[5 5]
    ensure -> not? equal? 1 2
    ensure -> not? equal? 1 2.0
    ensure -> not? equal? 1 :rational @[1 2]
    ensure -> 1 = 1
    ensure -> 1 = 1.0
    ensure -> 1 = to :rational @[1 1]
    ensure -> 1 = to :rational @[5 5]
    ensure -> not? 1 = 2
    ensure -> not? 1 = 2.0
    ensure -> not? 1 = :rational @[1 2]
    passed
    
    ensure -> equal? 1.0 1
    ensure -> equal? 1.0 1.0
    ensure -> equal? 1.0 to :rational @[1 1]
    ensure -> equal? 1.0 to :rational @[5 5]
    ensure -> not? equal? 1.0 2
    ensure -> not? equal? 1.0 2.0
    ensure -> not? equal? 1.0 to :rational @[1 2]
    ensure -> 1.0 = 1
    ensure -> 1.0 = 1.0
    ensure -> 1.0 = to :rational @[1 1]
    ensure -> 1.0 = to :rational @[5 5]
    ensure -> not? 1.0 = 2
    ensure -> not? 1.0 = 2.0
    ensure -> not? 1.0 = to :rational @[1 2]
    passed
    
    ensure -> equal? to :rational @[5 5] 1
    ensure -> equal? to :rational @[5 5] 1.0
    ensure -> equal? to :rational @[5 5] to :rational @[1 1]
    ensure -> not? equal? to :rational @[5 5] 2
    ensure -> not? equal? to :rational @[5 5] 2.0
    ensure -> not? equal? to :rational @[5 5] to :rational @[1 2]
    ensure -> (to :rational @[5 5]) = 1
    ensure -> (to :rational @[5 5]) = 1.0
    ensure -> (to :rational @[5 5]) = to :rational @[1 1]
    ensure -> not? (to :rational @[5 5]) = 2
    ensure -> not? (to :rational @[5 5]) = 2.0
    ensure -> not? (to :rational @[5 5]) = to :rational @[1 2]
    passed
    
    
    topic « equal? - :quantity
    
    ensure -> equal? 1:usd 1
    ensure -> equal? 1:m   1
    ensure -> equal? 1:m2  1
    ensure -> equal? 1:m3  1
    ensure -> equal? 1:c   1
    ensure -> equal? 1:f   1
    ensure -> 1:usd = 1
    ensure -> 1:m   = 1
    ensure -> 1:m2  = 1
    ensure -> 1:m3  = 1
    ensure -> 1:c   = 1
    ensure -> 1:f   = 1
    passed
    
    ensure -> equal? 1 1:usd
    ensure -> equal? 1 1:m
    ensure -> equal? 1 1:m2
    ensure -> equal? 1 1:m3
    ensure -> equal? 1 1:c
    ensure -> equal? 1 1:f
    ensure -> 1 = 1:usd
    ensure -> 1 = 1:m
    ensure -> 1 = 1:m2
    ensure -> 1 = 1:m3
    ensure -> 1 = 1:c
    ensure -> 1 = 1:f
    passed
    
    ensure -> equal? 1:usd 1.0
    ensure -> equal? 1:m   1.0
    ensure -> equal? 1:m2  1.0
    ensure -> equal? 1:m3  1.0
    ensure -> equal? 1:c   1.0
    ensure -> equal? 1:f   1.0
    ensure -> 1:usd = 1.0
    ensure -> 1:m   = 1.0
    ensure -> 1:m2  = 1.0
    ensure -> 1:m3  = 1.0
    ensure -> 1:c   = 1.0
    ensure -> 1:f   = 1.0
    passed
    
    ensure -> equal? 1.0 1:usd
    ensure -> equal? 1.0 1:m
    ensure -> equal? 1.0 1:m2
    ensure -> equal? 1.0 1:m3
    ensure -> equal? 1.0 1:c
    ensure -> equal? 1.0 1:f
    ensure -> 1.0 = 1:usd
    ensure -> 1.0 = 1:m
    ensure -> 1.0 = 1:m2
    ensure -> 1.0 = 1:m3
    ensure -> 1.0 = 1:c
    ensure -> 1.0 = 1:f
    passed
    
    ensure -> equal? 1:usd to :rational @[5 5]
    ensure -> equal? 1:m   to :rational @[5 5]
    ensure -> equal? 1:m2  to :rational @[5 5]
    ensure -> equal? 1:m3  to :rational @[5 5]
    ensure -> equal? 1:c   to :rational @[5 5]
    ensure -> equal? 1:f   to :rational @[5 5]
    ensure -> 1:usd = to :rational @[5 5]
    ensure -> 1:m   = to :rational @[5 5]
    ensure -> 1:m2  = to :rational @[5 5]
    ensure -> 1:m3  = to :rational @[5 5]
    ensure -> 1:c   = to :rational @[5 5]
    ensure -> 1:f   = to :rational @[5 5]
    passed
    
    ensure -> equal? to :rational @[5 5] 1:usd
    ensure -> equal? to :rational @[5 5] 1:m
    ensure -> equal? to :rational @[5 5] 1:m2
    ensure -> equal? to :rational @[5 5] 1:m3
    ensure -> equal? to :rational @[5 5] 1:c
    ensure -> equal? to :rational @[5 5] 1:f
    ensure -> (to :rational @[5 5]) = 1:usd
    ensure -> (to :rational @[5 5]) = 1:m
    ensure -> (to :rational @[5 5]) = 1:m2
    ensure -> (to :rational @[5 5]) = 1:m3
    ensure -> (to :rational @[5 5]) = 1:c
    ensure -> (to :rational @[5 5]) = 1:f
    passed
    
    ensure -> not? equal? 2:usd 1
    ensure -> not? equal? 2 1:usd
    ensure -> not? equal? 2:usd 1.0
    ensure -> not? equal? 2.0 1:usd
    ensure -> not? equal? 2:usd to :rational @[5 5]
    ensure -> not? equal? to :rational @[2 5] 1:usd
    passed
    
    ensure -> equal? 1.5:m 150:cm 
    ensure -> not? equal? 2:m 2:cm
    passed 
    
    
    topic « equal? - :null
    
    ensure -> equal? null null
    ensure -> equal? null ø
    ensure -> equal? ø ø
    ensure -> equal? ø null
    ensure -> null = null
    ensure -> null = ø
    ensure -> ø = ø
    ensure -> ø = null
    passed
    
    ensure -> not? equal? ø 1
    ensure -> not? equal? ø 1.0
    ensure -> not? equal? ø "ø"
    ensure -> not? equal? ø `ø`
    ensure -> not? ø = 1
    ensure -> not? ø = 1.0
    ensure -> not? ø = "ø"
    ensure -> not? ø = `ø`
    passed
    
    
    topic « equal? - :logical
    
    ensure -> equal? true true
    ensure -> equal? true (1 > 0)
    ensure -> true = true
    ensure -> true = (1 > 0)
    passed
    
    ensure -> not? equal? true maybe
    ensure -> not? equal? true false
    ensure -> not? true = maybe
    ensure -> not? true = false
    passed
    
    
    topic « equal? - :complex
    
    ensure -> equal? to :complex [0 2] ((to :complex [1 2]) - 1) 
    passed
    
    ensure -> not? equal? to :complex [1 2] to :complex @[neg 1 2] 
    ensure -> not? equal? to :complex [1 2] 1
    ensure -> not? equal? 1 to :complex [1 2]
    ensure -> (to :complex [0 2]) = ((to :complex [1 2]) - 1) 
    ensure -> not? (to :complex [1 2]) = to :complex @[neg 1 2] 
    ensure -> not? (to :complex [1 2]) = 1
    ensure -> not? 1 = to :complex [1 2]
    passed
    
    
    topic « equal? - :version
    
    ensure -> equal? 1.2.3 1.2.3
    ensure -> 1.2.3 = 1.2.3
    passed
    
    ensure -> not? equal? 1.2.3 1.2.3-pre
    ensure -> not? equal? 1.2.3 1.2.3-dev
    ensure -> not? 1.2.3 = 1.2.3-pre
    ensure -> not? 1.2.3 = 1.2.3-dev
    passed
    
    
    topic « equal? - :type
    
    ensure -> equal? :string type "a"
    ensure -> equal? :integer type 1
    ensure -> equal? :floating type 1.5
    passed
    
    ensure -> not? equal? :string :integer
    ensure -> not? equal? :string :char
    ensure -> not? equal? :integer :floating
    passed
    
    
    topic « equal? - :char
    
    ensure -> equal? `a` `a`
    ensure -> `a` = `a`
    passed
    
    ensure -> not? equal? `a` "a" 
    ensure -> not? equal? `a` `b`
    ensure -> not? equal? `1` 1
    ensure -> not? equal? "a" `a` 
    ensure -> not? equal? `b` `a`
    ensure -> not? equal? 1   `1`
    ensure -> not? `a` = "a" 
    ensure -> not? `a` = `b`
    ensure -> not? `1` =  1
    ensure -> not? "a" = `a` 
    ensure -> not? `b` = `a`
    ensure -> not?  1  = `1`
    passed 
    
    
    topic « equal? - :string
    
    ensure -> equal? "Art" "Arturo" -- "uro"
    ensure -> "Art" = "Arturo" -- "uro"
    passed
    
    ensure -> not? equal? "A" "B"
    ensure -> not? equal? "Art" "Bob"
    passed
    
    ensure -> not? equal? "a"    `a` 
    ensure -> not? equal? "10"   10 
    ensure -> not? equal? "10"   10
    ensure -> not? equal? ["help"] [help]
    ensure -> not? equal? ["a"]    [a: "a"]
    ensure -> not? equal? "help"   'help
    ensure -> not? equal? ["help"] [.help]
    ensure -> not? equal? ["help"] ['help: "help"]
    ensure -> not? "a"      = `a` 
    ensure -> not? "10"     = 10 
    ensure -> not? "10"     = 10
    ensure -> not? ["help"] = [help]
    ensure -> not? ["a"]    = [a: "a"]
    ensure -> not? "help"   = 'help
    ensure -> not? ["help"] = [.help]
    ensure -> not? ["help"] = ['help: "help"]
    passed
    
    
    topic « equal? - :word
    
    ensure -> equal? [word] [word]
    ensure -> not? equal? [word] [otherWord]
    ensure -> not? equal? [word] ["word"]
    ensure -> not? equal? [word] [word: word]
    ensure -> not? equal? [word] ['word]
    ; ensure -> not? equal? [word] [.word]
    ensure -> not? equal? [word] [.word: word]
    passed
    
    
    topic « equal? - :label
    
    ensure -> equal? [label: value] [label: value]
    passed
    
    ensure -> not? equal? [label: value] [label: value2]
    ensure -> not? equal? [label: value] [label2: value]
    passed
    
    ensure -> not? equal? [label: value] ["label"]
    ensure -> not? equal? ["label": value] ["label"]
    ensure -> not? equal? [label: value] ["value"]
    ensure -> not? equal? [label: "value"] ["value"]
    ensure -> not? equal? [label: "value"] ["label" "value"]
    passed
    
    ensure -> not? equal? [label: "value"] [label]
    ensure -> not? equal? [label: "value"] [value]
    ensure -> not? equal? [label: "value"] [label value]
    passed
    
    ensure -> not? equal? [label: 'world] ['label]
    ensure -> not? equal? [label: 'world] ['word]
    ensure -> not? equal? [label: 'world] ['label 'word]
    passed
    
    ensure -> not? equal? [label: .attr] [.label]
    ensure -> not? equal? [label: .attr] [.attr]
    ; ensure -> not? equal? [label: .attr: "a"] [.label: .attr: "a"]
    ensure -> not? equal? [label: .attr: "a"] [.label: "a"]
    ensure -> not? equal? [label: .attr: "a"] [.attr: "a"]
    passed
    
    
    topic « equal? - :literal
    
    ensure -> equal? 'literal 'literal
    ensure -> not? equal? 'literal 'other
    ensure -> not? equal? 'literal "literal"
    ensure -> not? equal? ['literal] ["literal"]
    ensure -> not? equal? ['literal] [literal]
    ensure -> not? equal? ['literal] [.literal]
    ensure -> not? equal? ['literal] [literal: 'literal]
    passed
    
    
    topic « equal? - :attribute
    
    ensure -> equal? [.attr] [.attr]
    ensure -> not? equal? [.attr] ["attr"]
    ; ensure -> not? equal? [.attr] [attr]
    ensure -> not? equal? [.attr] [attr: .attr]
    ensure -> not? equal? [.attr] ['attr]
    ensure -> not? equal? [.attr] [.other]
    ensure -> not? equal? [.attr] [.attr: .attr]
    passed
    
    
    topic « equal? - :attributeLabel
    
    ensure -> equal? [.attr: value] [.attr: value]
    passed
    
    ensure -> not? equal? [.attr: value] ["attr"]
    ensure -> not? equal? [.attr: value] ["value"]
    ensure -> not? equal? [.attr: value] ["attr" "value"]
    passed
    
    ; ensure -> not? equal? [.attr: value] [attr]
    ensure -> not? equal? [.attr: value] [attr: .attr:]
    ; ensure -> not? equal? [.attr: value] [attr: value]
    ensure -> not? equal? [.attr: value] [attr: .attr: value]
    passed
    
    ensure -> not? equal? [.attr: value] ['attr]
    ensure -> not? equal? [.attr: value] ['value]
    ensure -> not? equal? [.attr: value] ['attr 'value]
    passed
    
    ensure -> not? equal? [.attr: value] [.attr]
    ensure -> not? equal? [.attr: value] [.value]
    ensure -> not? equal? [.attr: value] [.other: value]
    ensure -> not? equal? [.attr: value] [.attr: other]
    passed
    
    
    topic « equal? - :path
    
    a: #[name: "John", surname: "Doe"]
    b: @["Joe" "Jane" "Jesse"]
    
    ensure -> equal? a\name "John" 
    ensure -> equal? a\surname "Doe" 
    ensure -> not? equal? a\name "Jane" 
    ensure -> not? equal? a\name 1
    passed
    
    ensure -> equal? b\0 "Joe" 
    ensure -> equal? b\1 "Jane" 
    ensure -> equal? b\2 "Jesse" 
    ensure -> not? equal? b\2 "Walter" 
    passed
    
    ensure -> equal? [b\0] [b\0]
    ensure -> equal? [a\name] [a\name]
    ensure -> not? equal? [b\0] [b\1]
    ensure -> not? equal? [a\name] [a\surname]
    passed
    
    
    topic « equal? - :pathLabel
       
    ensure -> equal? [a\name: "John"] [a\name: "John"]
    ensure -> not? equal? [a\surname: "Doe"] [b\surname: "Doe" ]
    ensure -> not? equal? [a\name: "John"] [b\name: "Jane"]
    ensure -> not? equal? [a\name: "John"] [b\name: "John"]
    passed
    
    
    topic « equal? - :symbol
    
    ensure -> equal? [+] [+]
    ensure -> not? equal? [+] [-]
    ensure -> not? equal? [+] [++]
    ensure -> not? equal? [+] [`+`]
    ensure -> not? equal? [+] [{+}]
    ensure -> not? equal? [+] ["+"]
    ensure -> not? equal? [+] [plus]
    ensure -> not? equal? [+] ['+]
    passed
    
    
    topic « equal? - :regex
    
    ensure -> regex? {/[A-Z]/}
    ensure -> equal? {/[A-Z]/} {/[A-Z]/} 
    ensure -> not? equal? {/[A-Z]/} {/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]/}
    ensure -> not? equal? {/[A-Z]/} {[A-Z]}
    ensure -> not? equal? {/[A-Z]/} "/[A-Z]/"
    passed


    topic « equal? - :binary
    
    ensure -> equal? "48 65 6C 6C 6F 20 77 6F 72 6C 64"
        ~{|to :binary "Hello world"|}
    ensure -> equal? "00" ~{|to :binary 0|}
    ensure -> equal? "01" ~{|to :binary 1|}
    ensure -> equal? "0A" ~{|to :binary 10|}
    ensure -> equal? "05" ~{|to :binary 5|}
    passed
    
    a: to :binary 0
    
    ensure -> not? equal? a 0
    ensure -> not? equal? "49 65 6C 6C 6F 20 77 6F 72 6C 64"
        ~{|to :binary "Hello world"|}
    passed


    topic « equal? - :bytecode
    
    x: to :bytecode [["print"][1 112 155]]
    
    ensure -> equal? x to :bytecode [["print"][1 112 155]]
    ensure -> not? equal? x to :bytecode [["print"][2 112 155]]
    ensure -> not? equal? x [["print"][2 112 155]]
    passed


    topic « equal? - :inline
    
    a: [(1 + 1)], b: [(1 + 1)] 
    ensure -> equal? a\0 b\0
    passed
    
    c: [(2 + 1)] 
    ensure -> not? equal? a\0 c\0
    passed
    
    d: [(3 - 1)] 
    ensure -> not? equal? a\0 d\0   ; even the calc (3-1) and (1+1) being 2, 
    passed                          ; they are different inlines 
                                    ; with the same result when evaluated
    
    
    e: [(1 + 2 - 1)]
    ensure -> not? equal? a\0 e\0
    ensure -> not? equal? a\0 2
    passed


    topic « equal? - :block
    
    a: [1 + 1]
    ensure -> equal? a [1 + 1]
    ensure -> not? equal? a [2]
    ensure -> not? equal? a 2
    ensure -> not? equal? a [1 ++ 1]
    passed
    
    
    topic « equal? :range
    
    ensure -> equal? [0 1 2 3 4 5] @0..5
    ensure -> equal? [0 2 4] @0.. .step: 2 5
    ensure -> equal? @range.step: 2 0 5 @range.step: 2 0 4
    ensure -> not? equal? range.step: 2 0 5 range.step: 2 0 4
    passed


    topic « equal? :dictionary
    
    a: #[name: "Walter" surname: "Pinkman"]
    
    ensure -> equal? a #[name: "Walter" surname: "Pinkman"]
    ensure -> not? equal? a #[name: "Jesse" surname: "Pinkman"]
    ensure -> not? equal? a #[name "Jesse" surname "Pinkman"]
    ensure -> not? equal? a [name "Jesse" surname "Pinkman"]
    passed
    
    ensure -> equal? a\name "Walter"
    ensure -> equal? a\surname "Pinkman"
    ensure -> not? equal? a\surname "White"
    passed


    topic « equal? - :object
    
    define :person [name age][  
        init: -> this\name: capitalize this\name
        print: -> 
            render "NAME: |this\name|, AGE: |this\age|"
    ]
    
    define.as: :person :student [name age id][  
        init: -> this\name: capitalize this\name
        print: -> 
            render "NAME: |this\name|, AGE: |this\age|, ID: |this\id|"
    ]
    
    a: to :person ["Joe" 32]
    ensure -> equal? a to :person ["Joe" 32]
    ensure -> not? equal? to :person ["Joe" 32] #[name: "Joe" age: 32]
    ensure -> not? equal? to :person ["Joe" 32] to :student ["Joe" 32 15]
    passed
    
    a\name: "Jane"
    ensure -> equal? a to :person ["Jane" 32]
    passed
    
    
    topic « equal? - :store
    
    a: store "test.db"
    a\name: "John" a\surname: "Doe"
    b: store "test.db"
    b\name: "John" b\surname: "Doe"
    c: store "test2.db"
    c\name: "John" c\surname: "Doe"
    d: store "test3.db"
    d\name: "Jane" d\surname: "Doe"
    
    ensure -> equal? a a
    ensure -> equal? a b
    ensure -> equal? b a
    passed
    
    ensure -> not? equal? a c 
    ensure -> not? equal? c a 
    ensure -> not? equal? a d 
    ensure -> not? equal? d a 
    ensure -> not? equal? c d 
    ensure -> not? equal? d c 
    passed
    

    topic « equal? - :color
    
    ensure -> equal? #000 #black
    ensure -> equal? #fff #white
    ensure -> equal? #white #white
    ensure -> not? equal? #black #white
    ensure -> not? equal? #white #black
    passed


    topic « equal? - :function
    
    ensure -> equal? var 'print var 'print
    ensure -> not? equal? var 'inspect var 'print
    passed
    
    a: $[name surname][]
    A: $[name][]
    b: $[name][]
    c: $[name surname][]
    
    ensure -> equal? ~"|var 'a|" ~"|$[name surname][]|"
    ensure -> equal? ~"|var 'a|" ~"|var 'c|"
    ensure -> not? equal? ~"|var 'a|" ~"|var 'A|"
    ensure -> not? equal? ~"|var 'a|" ~"|var 'b|"
    passed


    topic « equal? - :database
    ; todo: test this


    topic « equal? - :date
    
    a: to :date .format: "MMM dd" "Jan 15"
    b: to :date .format: "MMM dd" "Jan 15"
    c: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    d: now
    
    ensure -> equal? a b 
    ensure -> not? equal? a c 
    ensure -> not? equal? a d
    passed 
    
    ensure -> equal? a\day c\day
    ensure -> equal? a\month c\month
    ensure -> not? equal? a\year c\year
    passed


    topic « equal? - incompatible types
    
    ; NOTES: 
    ; - to avoid repetition some tests may be not explicitly included
    ; - this test part tries to cover the most of possible behaviors,
    ;     including the possility of the Comparison module be rewritten, 
    ;     avoiding future broken changes
    ; - some combinations were not made, because it's considered very
    ;     improbable to happen, even with a future rewrite of 
    ;     the Comparison module
    
    ; for :integer
    
    ensure -> not? every? @[
        -> equal? 1 1
    ] => not?
    
    ensure -> every? @[
        -> equal? 1 null           -> equal? 1 true
        -> equal? 1 false          -> equal? 1 to :complex [1 1]
        -> equal? 1 1.0.0          -> equal? 1 :integer
        -> equal? 1 `1`            -> equal? 1 "1"
        -> equal? [1] [one]        -> equal? [1] [one:]
        -> equal? [1 1] [one: 1]   -> equal? 1 '1
        -> equal? [1] [.1]         -> equal? [1] [.1:]
        -> equal? [1 1] [.1: 1]    -> equal? [1] [one\1]
        -> equal? [1] [one\1:]     -> equal? [1 1] [one\1: 1]
        -> equal? [1] [+]          -> equal? 1 {/1/}
        -> equal? 1 to :binary 1   -> equal? 1 to :binary 1
        -> equal? [1] [(1)]        -> equal? 1 [1]
        -> equal? 1 1..1           -> equal? 1 #[one: 1]
        -> equal? 0 #black         -> equal? 1 var 'one?
    ] => not? passed
    
    ; for :floating
    ensure -> every? @[
        -> equal? 1.0 null              -> equal? 1.0 true
        -> equal? 1.0 false             -> equal? 1.0 to :complex [1.0 1.0]
        -> equal? 1.0 1.0.0             -> equal? 1.0 :floating
        -> equal? 1.0 `1`               -> equal? 1.0 "1.0"
        -> equal? [1.0] [one]           -> equal? [1.0] [one: 1.0]
        -> equal? [1.0 1.0] [one: 1.0]  -> equal? 1.0 '1
        -> equal? [1.0] [.1]            -> equal? [1.0] [.1:]
        -> equal? [1.0 1.0] [.1: 1.0]   -> equal? [1.0] [one\1]
        -> equal? [1.0] [one\1:]        -> equal? [1.0 1.0] [one\1: 1.0]
        -> equal? [1.0] [+]             -> equal? 1.0 {/1.0/}
        -> equal? 1.0 to :binary 1.0    -> equal? 1.0 to :binary 1.0
        -> equal? [1.0] [(1.0)]         -> equal? 1.0 [1]
        -> equal? 1.0 1..1              -> equal? 1.0 #[one: 1.0]
        -> equal? 0.0 #black            -> equal? 1.0 var 'one?
    ] => not? passed
    
    ; for :rational
    a: to :rational [1 1]
    ensure -> every? @[
        -> equal? a null                    -> equal? a true
        -> equal? a false                   -> equal? a to :complex [1 1]
        -> equal? a 1.0.0                   -> equal? a :rational
        -> equal? a `1`                     -> equal? a "1/1"
        -> equal? @[a] [one]                -> equal? @[a] [one:]
        -> equal? @[a a] [one: 1]           -> equal? 1 '1
        -> equal? @[a] [.1]                 -> equal? @[a] [.1:]
        -> equal? @[a a] [.1: 1]            -> equal? @[a] [one\1]
        -> equal? @[a] [one\1: 1]           -> equal? @[a a] [one\1: 1]
        -> equal? @[a] [+]                  -> equal? a {/1/1/}
        -> equal? a to :binary 1            -> equal? a to :binary 1
        -> equal? @[a] [(1)]                -> equal? a [1]
        -> equal? a 1..1                    -> equal? a #[one: 1]
        -> equal? to :rational [1 1] #black -> equal? a var 'one?
    ] => not? passed
    
    ; for :quantity
    ensure -> every? @[
        -> equal? 1:usd null                    -> equal? 1:usd true
        -> equal? 1:usd false                   -> equal? 1:usd to :complex [1 1]
        -> equal? 1:usd 1.0.0                   -> equal? 1:usd :quantity
        -> equal? 1:usd `1`                     -> equal? 1:usd "1USD"
        -> equal? [1:usd] [one]                 -> equal? [1:usd] [one:]
        -> equal? [1:usd 1:usd] [one: 1:usd]    -> equal? 1:usd '1
        -> equal? [1:usd] [.1]                  -> equal? [1:usd] [.1:]
        -> equal? [1:usd 1:usd] [.1: 1:usd]     -> equal? [1:usd] [one\1]
        -> equal? [1:usd] [one\1:]              -> equal? [1:usd 1:usd] [one\1: 1:usd]
        -> equal? [1:usd] [+]                   -> equal? 1:usd {/1USD/}
        -> equal? 1:usd to :binary 1            -> equal? 1:usd to :binary 1
        -> equal? [1:usd] [(1)]                 -> equal? 1:usd [1:usd]
        -> equal? 1:usd 1..1                    -> equal? 1:usd #[one: 1:usd]
        -> equal? 0:usd #black                  -> equal? 1:usd var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> equal? 1:m null              -> equal? 1:m true
        -> equal? 1:m false             -> equal? 1:m to :complex [1 1]
        -> equal? 1:m 1.0.0             -> equal? 1:m :quantity
        -> equal? 1:m `1`               -> equal? 1:m "1m"
        -> equal? [1:m] [one]           -> equal? [1:m] [one:]
        -> equal? [1:m 1:m] [one: 1:m]  -> equal? 1:m '1
        -> equal? [1:m] [.1]            -> equal? [1:m] [.1: 1:m]
        -> equal? [1:m 1:m] [.1: 1:m]   -> equal? [1:m] [one\1]
        -> equal? [1:m] [one\1:]        -> equal? [1:m 1:m] [one\1: 1:m]
        -> equal? [1:m] [+]             -> equal? 1:m {/1m/}
        -> equal? 1:m to :binary 1      -> equal? 1:m to :binary 1
        -> equal? [1:m] [(1)]           -> equal? 1:m [1:m]
        -> equal? 1:m 1..1              -> equal? 1:m #[one: 1:m]
        -> equal? 0:m #black            -> equal? 1:m var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> equal? 1:m3 null                 -> equal? 1:m3 true
        -> equal? 1:m3 false                -> equal? 1:m3 to :complex [1 1]
        -> equal? 1:m3 1.0.0                -> equal? 1:m3 :quantity
        -> equal? 1:m3 `1`                  -> equal? 1:m3 "1m³"
        -> equal? [1:m3] [one]              -> equal? [1:m3] [one:]
        -> equal? [1:m3 1:m3] [one: 1:m3]   -> equal? 1:m3 '1
        -> equal? [1:m3] [.1]               -> equal? [1:m3] [.1:]
        -> equal? [1:m3 1:m3] [.1: 1:m3]    -> equal? [1:m3] [one\1]
        -> equal? [1:m3] [one\1:]           -> equal? [1:m3 1:m3] [one\1: 1:m3]
        -> equal? [1:m3] [+]                -> equal? 1:m3 {/1m³/}
        -> equal? 1:m3 to :binary 1         -> equal? 1:m3 to :binary 1
        -> equal? [1:m3] [(1)]              -> equal? 1:m3 [1:m3]
        -> equal? 1:m3 1..1                 -> equal? 1:m3 #[one: 1:m3]
        -> equal? 0:m3 #black               -> equal? 1:m3 var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> equal? 1:c null              -> equal? 1:c true
        -> equal? 1:c false             -> equal? 1:c to :complex [1 1]
        -> equal? 1:c 1.0.0             -> equal? 1:c :quantity
        -> equal? 1:c `1`               -> equal? 1:c "1°C"
        -> equal? [1:c] [one]           -> equal? [1:c] [one:]
        -> equal? [1:c 1:c] [one: 1:c]  -> equal? 1:c '1
        -> equal? [1:c] [.1]            -> equal? [1:c] [.1:]
        -> equal? [1:c 1:c] [.1: 1:c]   -> equal? [1:c] [one\1]
        -> equal? [1:c] [one\1:]        -> equal? [1:c 1:c] [one\1: 1:c]
        -> equal? [1:c] [+]             -> equal? 1:c {/1°C/}
        -> equal? 1:c to :binary 1      -> equal? 1:c to :binary 1
        -> equal? [1:c] [(1)]           -> equal? 1:c [1:c]
        -> equal? 1:c 1..1              -> equal? 1:c #[one: 1:c]
        -> equal? 0:c #black            -> equal? 1:c var 'one?
    ] => not? passed
    
    ; for :null
    ensure -> every? @[
        -> equal? null 0                        -> equal? null 0.0            
        -> equal? null to :rational [1 1]       -> equal? null true
        -> equal? null false                    -> equal? null to :complex [0 0]
        -> equal? null 0.0.0                    -> equal? null :null
        -> equal? null `ø`                      -> equal? null "null"
        -> equal? @[null] [null]                -> equal? @[null] [null:]
        -> equal? @[null null] [null: null]     -> equal? null 'null
        -> equal? @[null] [.null]               -> equal? @[null] [.null:]
        -> equal? @[null null] [.null: null]    -> equal? @[null] [null\null]
        -> equal? @[null] [null\null:]          -> equal? @[null null] [null\null: null]
        -> equal? @[null] [ø]                   -> equal? null {/null/}
        -> equal? null {/ø/}                    -> equal? null to :binary 0   
        -> equal? null to :binary 0             -> equal? @[null] [(null)]         
        -> equal? null [null]                   -> equal? null 0..0            
        -> equal? null #[null: null]            -> equal? null #black          
        -> equal? null var 'null?
    ] => not? passed
    
    ; for :logical
    ensure -> every? @[
        -> equal? true 0                        -> equal? true 0.0            
        -> equal? true to :rational [1 1]       -> equal? true to :complex [0 0]
        -> equal? true 0.0.0                    -> equal? true :true
        -> equal? true `0`                      -> equal? true "true"
        -> equal? @[true] [true]                -> equal? @[true] [true: true]
        -> equal? @[true true] [true: true]     -> equal? true 'true
        -> equal? @[true] [.true]               -> equal? @[true] [.true:]
        -> equal? @[true true] [.true: true]    -> equal? @[true] [true\true]
        -> equal? @[true] [true\true:]          -> equal? @[true true] [true\true: true]
        -> equal? @[true] [ø]                   -> equal? true {/true/}
        -> equal? true to :binary 0             -> equal? true to :binary 0             
        -> equal? @[true] [(true)]              -> equal? true [true]                   
        -> equal? true 0..0                     -> equal? true #[true: true]            
        -> equal? true #black                   -> equal? true var 'true?
    ] => not? passed
    
    ensure -> every? @[
        -> equal? false 0                           -> equal? false 0.0            
        -> equal? false to :rational [1 1]          -> equal? false to :complex [0 0]
        -> equal? false 0.0.0                       -> equal? false :false
        -> equal? false `0`                         -> equal? false "false"
        -> equal? @[false] [false]                  -> equal? @[false] [false:]
        -> equal? @[false false] [false: false]     -> equal? false 'false
        -> equal? @[false] [.false]                 -> equal? @[false] [.false:]
        -> equal? @[false false] [.false: false]    -> equal? @[false] [false\false]
        -> equal? @[false] [false\false:]           -> equal? @[false false] [false\false: false]
        -> equal? @[false] [ø]                      -> equal? false {/false/}
        -> equal? false to :binary 0                -> equal? false to :binary 0                
        -> equal? @[false] [(false)]                -> equal? false [false]                     
        -> equal? false 0..0                        -> equal? false #[false: false]             
        -> equal? false #black                      -> equal? false var 'false?
    ] => not? passed
    
    ensure -> every? @[
        -> equal? maybe 0                           -> equal? maybe 0.0            
        -> equal? maybe to :rational [1 1]          -> equal? maybe to :complex [0 0]
        -> equal? maybe 0.0.0                       -> equal? maybe :maybe
        -> equal? maybe `0`                         -> equal? maybe "maybe"
        -> equal? @[maybe] [maybe]                  -> equal? @[maybe] [maybe:]
        -> equal? @[maybe maybe] [maybe: maybe]     -> equal? maybe 'maybe
        -> equal? @[maybe] [.maybe]                 -> equal? @[maybe] [.maybe:]
        -> equal? @[maybe maybe] [.maybe: maybe]    -> equal? @[maybe] [maybe\maybe]
        -> equal? @[maybe] [maybe\maybe:]           -> equal? @[maybe maybe] [maybe\maybe: maybe]
        -> equal? @[maybe] [ø]                      -> equal? maybe {/maybe/}
        -> equal? maybe to :binary 0                -> equal? maybe to :binary 0
        -> equal? @[maybe] [(maybe)]                -> equal? maybe [maybe]
        -> equal? maybe 0..0                        -> equal? maybe #[maybe: maybe]             
        -> equal? maybe #black                      
    ] => not? passed
    
    ; for :complex
    a: to :complex [1 1]
    ensure -> every? @[
        -> equal? a 1                       -> equal? a 1.0            
        -> equal? a to :rational [1 1]      -> equal? a null                    
        -> equal? a true                    -> equal? a false
        -> equal? a 1.0.0                   -> equal? a :rational
        -> equal? a `1`                     -> equal? a "1.0+1.0i"
        -> equal? @[a] [one]                -> equal? @[a] [one:]
        -> equal? @[a a] [one: 1]           -> equal? 1 '1
        -> equal? @[a] [.1]                 -> equal? @[a] [.1:]
        -> equal? @[a a] [.1: 1]            -> equal? @[a] [one\1]
        -> equal? @[a] [one\1:]             -> equal? @[a a] [one\1: 1]
        -> equal? @[a] [+]                  -> equal? a {/1.0+1.0i/}
        -> equal? a to :binary 1            -> equal? a to :binary 1
        -> equal? @[a] [(1)]                -> equal? a [1]
        -> equal? a 1..1                    -> equal? a #[one: 1]
        -> equal? to :complex [0 0] #black  -> equal? a var 'one?
    ] => not? passed
    
    ; for :version
    ensure -> every? @[
        -> equal? 1.0.0 1                       -> equal? 1.0.0 1.0          
        -> equal? 1.0.0 to :rational [1 1]      -> equal? 1.0.0 null                    
        -> equal? 1.0.0 true                    -> equal? 1.0.0 false                   
        -> equal? 1.0.0 to :complex [1.0 1.0]   -> equal? 1.0.0 :floating
        -> equal? 1.0.0 `1`                     -> equal? 1.0.0 "1.0.0"
        -> equal? [1.0.0] [one]                 -> equal? [1.0.0] [one:]
        -> equal? [1.0.0 1.0.0] [one: 1.0.0]    -> equal? 1.0.0 '1
        -> equal? [1.0.0] [.1]                  -> equal? [1.0.0] [.1:]
        -> equal? [1.0.0 1.0.0] [.1: 1.0.0]     -> equal? [1.0.0] [one\1]
        -> equal? [1.0.0] [one\1:]              -> equal? [1.0.0 1.0.0] [one\1: 1.0.0]
        -> equal? [1.0.0] [+]                   -> equal? 1.0.0 {/1.0.0/}
        -> equal? 1.0.0 to :binary 1.0          -> equal? 1.0.0 to :binary 1.0
        -> equal? [1.0.0] [(1.0.0)]             -> equal? 1.0.0 [1.0.0]
        -> equal? 1.0.0 1..1                    -> equal? 1.0.0 #[one: 1.0.0]
        -> equal? 0.0.0 #black                  -> equal? 1.0.0 var 'version?
    ] => not? passed
    
    ; for :type
    ensure -> every? @[
        -> equal? :1 1                              -> equal? :1 1.0          
        -> equal? :integer 1                        -> equal? :floating 1.0          
        -> equal? :rational to :rational [1 1]      -> equal? :null null                    
        -> equal? :true true                        -> equal? :false false                   
        -> equal? :logical false                    -> equal? :complex to :complex [1 1]   
        -> equal? :version 1.0.0                    -> equal? :T `T`                         
        -> equal? :char `T`                         -> equal? :string ":type"
        -> equal? [:type] [type]                    -> equal? [:word] [word]                     
        -> equal? [:type] [type:]                   -> equal? [:label] [label:]
        -> equal? [:type :type] [type: :type]       -> equal? :1 '1
        -> equal? :literal '1                       -> equal? [:type] [.type]                      
        -> equal? [:attribute] [.type]              -> equal? [:type] [.type:]
        -> equal? [:attributeLabel] [.type:]        -> equal? [:type :type] [.type: :type]         
        -> equal? [:type] [type\type]               -> equal? [:path] [type\type]
        -> equal? [:type] [type\type:]              -> equal? [:pathLabel] [type\type:]            
        -> equal? [:type :type] [type\type: :type]  -> equal? [:type] [+]                       
        -> equal? [:symbol] [+]                     -> equal? :type {/:type/}
        -> equal? :regex {/:type/}                  -> equal? :type to :binary 1.0              
        -> equal? :binary to :binary 1.0            -> equal? [:type] [(:type)]                 
        -> equal? [:inline] [(:type)]               -> equal? :type [:type]
        -> equal? :block [:type]                    -> equal? :type 1..1                        
        -> equal? :range 1..1                       -> equal? :type #[type: :type]
        -> equal? :dictionary #[type: :type]        -> equal? :type #black                      
        -> equal? :color #black                     -> equal? :type var 'type?
        -> equal? :function var 'one?
    ] => not? passed
    
    ; for :char
    ensure -> every? @[
        -> equal? `1` 1.0          
        -> equal? `1` to :rational [1 1]    -> equal? `ø` null                    
        -> equal? `t` true                  -> equal? `f` false                   
        -> equal? `1` to :complex [1.0 1.0] -> equal? `T` :floating
        -> equal? [`a`] [one]               -> equal? [`a`] [a: `a`]
        -> equal? [`a` `a`] [a: `a`]        -> equal? `a` 'a
        -> equal? [`a`] [.1]                -> equal? [`a`] [.a:]
        -> equal? [`a` `a`] [.a: `a`]       -> equal? [`a`] [a\a]
        -> equal? [`a`] [a\a:]              -> equal? [`a` `a`] [a\a: `a`]
        -> equal? [`+`] [+]                 -> equal? `a` {/a/}
        -> equal? `1` to :binary 1          -> equal? `a` to :binary 1
        -> equal? [`1`] [(`1`)]             -> equal? `a` [`a`]
        -> equal? `1` 1..1                  -> equal? `a` #[a: `a`]
        -> equal? `1` #black                -> equal? `a` var 'char?
    ] => not? passed
    
    ; for :string
    ensure -> every? @[
        -> equal? "1" 1                             -> equal? "1/1" to :rational [1 1]          
        -> equal? "1.0" 1.0                         -> equal? "null" null                    
        -> equal? "" null                           -> equal? "true" true                  
        -> equal? "" false                          -> equal? "false" false                   
        -> equal? "1.0+1.0i" to :complex [1.0 1.0]  -> equal? "type" :floating
        -> equal? "floating" :floating              -> equal? ":floating" :floating
        -> equal? "1.0" :floating                   -> equal? ["a"] [a\a]
        -> equal? ["a"] [a\a:]                      -> equal? ["a" "a"] [a\a: "a"]
        -> equal? ["+"] [+]                         -> equal? "a" {/a/}
        -> equal? "01" to :binary 1                 -> equal? "1" to :binary 1
        -> equal? [""] [("")]                       -> equal? "" [""]
        -> equal? "1" 1..1                          -> equal? "a" #[a: "a"]
        -> equal? "#000000" #black                  -> equal? "000000" #black              
        -> equal? "" var 'char?
    ] => not? passed
    
    ; for :word
    ensure -> every? @[        
        -> equal? [rational] @[to :rational [1 1]]      -> equal? [null]  @[null]                    
        -> equal? [true]     @[true]                    -> equal? [false] @[false]                   
        -> equal? [complex]  @[to :complex [1.0 1.0]]   -> equal? [type]  @[:floating]  
        -> equal? [floating] @[:floating]               -> equal? [a]      [a\a]                   
        -> equal? [a]         [a\a:]                    -> equal? [a]     @[{/a/}]                      
        -> equal? [binary]   @[to :binary 1]            -> equal? [one]   @[to :binary 1]              
        -> equal? [word]      [(word)]                  -> equal? [word]  @[[word]]                      
        -> equal? [range]    @[range 1 1]               -> equal? [a]     @[#[a: `a`]]               
        -> equal? [black]    @[#black ]                 -> equal? [word]  @[var 'word?]              
        -> equal? [var]      @[var 'word?]
    ] => not? passed
    
    ; for :label
    ensure -> every? @[
        -> equal? [rational:] @[to :rational [1 1]]     -> equal? [null:]     @[null]                                                        
        -> equal? [true:]     @[true]                   -> equal? [false:]    @[false]                   
        -> equal? [complex:]  @[to :complex [1.0 1.0]]  -> equal? [floating:] @[:floating]
        -> equal? [type:]     @[:floating]              -> equal? [a:]         [a\a]                     
        -> equal? [a:]         [a\a:]                   -> equal? [a:]        @[{/a:/}]                 
        -> equal? [binary:]   @[to :binary 1]           -> equal? [word:]      [(word:)]                
        -> equal? [label:]    @[[label:]]               -> equal? [a:]        @[#[a: `a`]]               
        -> equal? [black:]    @[#black ]                -> equal? [var:]      @[var 'word?]
        -> equal? [word:]     @[var 'word?]
    ] => not? passed
    
    ; for :literal
    ; NOTE: technically, '+ is not a :literal, but a :symbolLiteral type ;)
    ensure -> every? @[
        -> equal? 'integer  1                   -> equal? 'floating 1.0
        -> equal? 'rational to :rational [1 1]  -> equal? 'one      to :rational [1 1]
        -> equal? 'null     null                -> equal? 'true     true    
        -> equal? 'false    false               -> equal? 'complex  to :complex [1.0 1.0]    
        -> equal? 'type     :floating           -> equal? 'floating :floating               
        -> equal? ['a]        [a\a]             -> equal? ['+]      [+]                       
        -> equal? 'a        {/a/}               -> equal? 'binary   to :binary 1            
        -> equal? ['word]   [('word)]           -> equal? 'word     ['word]                                     
        -> equal? 'range    1..1                -> equal? 'a        #[a: 'a]                
        -> equal? 'black    #black              -> equal? 'word?    var 'word?              
        -> equal? 'var      var 'var
    ] => not? passed
    
    ; for :attribute
    ensure -> every? @[           
        -> equal? [.rational] @[to :rational [1 1]]    -> equal? [.null]     @[null]                  
        -> equal? [.true]     @[true]                  -> equal? [.false]    @[false]                 
        -> equal? [.complex]  @[to :complex [1.0 1.0]] -> equal? [.floating] @[:floating]                          
        -> equal? [.a]        @[{/a:/}]                -> equal? [.binary]   @[to :binary 1]          
        -> equal? [.word]      [(.word:)]              -> equal? [.label]    @[[.label]]                               
        -> equal? [.a]        @[#[a: `a`]]             -> equal? [.black]    @[#black]                
        -> equal? [.var]      @[var 'word?]            -> equal? [.word]     @[var 'word?]
    ] => not? passed
    
    ; for :attributeLabel
    ensure -> every? @[           
        -> equal? [.rational:] @[to :rational [1 1]]    -> equal? [.null:]     @[null]                  
        -> equal? [.true:]     @[true]                  -> equal? [.false:]    @[false]                 
        -> equal? [.complex:]  @[to :complex [1.0 1.0]] -> equal? [.floating:] @[:floating]             
        -> equal? [.a:]         [a\a]                   -> equal? [.a: `a`]     [a\a: `a`]              
        -> equal? [.plus:]      [+]                     -> equal? [.a:]        @[{/a:/}]                
        -> equal? [.binary:]   @[to :binary 1]          -> equal? [.word:]      [(.word:)]               
        -> equal? [.label:]    @[[label:]]              -> equal? [.a:]        @[#[a: `a`]]             
        -> equal? [.black:]    @[#black]                -> equal? [.var:]      @[var 'word?]            
        -> equal? [.word:]     @[var 'word?]
    ] => not? passed
    
    ; for :path & :pathLabel
    ensure -> every? @[
        -> equal? [a\b:] [a\b]
        -> equal? [a\b] [a\b:]
    ] => not? passed

    ; for :regex
    ensure -> every? @[
        -> equal? {/1/} 1                               -> equal? {/1/1/} to :rational [1 1]          
        -> equal? {/1.0/} 1.0                           -> equal? {/null/} null                    
        -> equal? {//} null                             -> equal? {/true/} true                  
        -> equal? {//} false                            -> equal? {/false/} false                   
        -> equal? {/1.0+1.0i/} to :complex [1.0 1.0]    -> equal? {/type/} :floating
        -> equal? {/floating/} :floating                -> equal? {/:floating/} :floating
        -> equal? {/1.0/} :floating                     -> equal? [{/a/}] [a\a]
        -> equal? [{/a/}] [a\a:]                        -> equal? [{/a/} {/a/}] [a\a: {/a/}]
        -> equal? [{/\+/}] [+]                          -> equal? {/01/} to :binary 1                 
        -> equal? {/1/} to :binary 1                    -> equal? [{//}] [({//})]                     
        -> equal? {//} [""]                             -> equal? {/1/} 1..1                          
        -> equal? {/a/} #[a: "a"]                       -> equal? {/#000000/} #black                  
        -> equal? {/000000/} #black                     -> equal? {/var/} var 'regex?
        -> equal? {/regex?/} var 'regex?
    ] => not? passed
    
    ; for :binary
    ensure -> every? @[
        -> equal? to :binary 1 1                    -> equal? to :binary 1 1.0                
        -> equal? to :binary 1 to :rational [1 1]   -> equal? to :binary 1 1:usd                
        -> equal? to :binary 1 1:m                  -> equal? to :binary 1 1:m3                 
        -> equal? to :binary 1 1:c                  -> equal? to :binary 0 null                 
        -> equal? to :binary 0 true                 -> equal? to :binary 0 false                
        -> equal? to :binary 0 maybe                -> equal? to :binary 1 to :complex [1 1]                  
        -> equal? to :binary 1 1.0.0                -> equal? to :binary 1 :type              
        -> equal? to :binary 1 :binary              -> equal? to :binary 1 `1`                  
        -> equal? to :binary "a" `a`                -> equal? to :binary 1 "01"                 
        -> equal? to :binary 1 "1"                  -> equal? @[to :binary 1] [binary]          
        -> equal? @[to :binary 1] [one]             -> equal? @[to :binary 1] [binary:]         
        -> equal? @[to :binary 1][.binary]          -> equal? @[to :binary 1] [.binary:]        
        -> equal? to :binary 1 {/01/}               -> equal? to :binary 1    {/1/}
    ] => not? passed
    
    ; for :range
    ensure -> every? @[
        -> equal? 1..1 1                        -> equal? 1..1 1.0
        -> equal? 1..1 a: to :rational [1 1]    -> equal? 1..1 1:usd
        -> equal? 1..1 1:m                      -> equal? 1..1 1:m3  
        -> equal? 1..1 1:c                      -> equal? 0..0 null 
        -> equal? 0..0 true                     -> equal? 0..0 false
        -> equal? 0..0 maybe                    -> equal? 1..1 to :complex [1 1]
        -> equal? 1..1 1.0.0                    -> equal? 1..1 :type                        
        -> equal? 1..1 :range                   -> equal? 1..1 `1` 
        -> equal? 1..1 "1"                      -> equal? 1..1 'range  
        -> equal? 1..1 {/1/}
    ] => not? passed
    
    ; for :dictionary, :object & :date
    define :person [name surname][]
    
    a: to :person ["Walter" "Pinkman"]
    b: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    
    ensure -> every? @[
        -> equal? #[name: "Walter" surname: "Pinkman"] a
        -> equal? a #[name: "Walter" surname: "Pinkman"]
        -> equal? #[year: 2023 day: 15 Month: "January"] b
        -> equal? b #[year: 2023 day: 15 Month: "January"]
    ] => not? passed
    
    ; for :color
    ensure -> every? @[
        -> equal? #black 0                  -> equal? #black 0.0
        -> equal? #black to :rational [1 1] -> equal? #black 0:usd 
        -> equal? #black 0:m                -> equal? #black 0:m3
        -> equal? #black 0:c                -> equal? #black null 
        -> equal? #black true               -> equal? #black false 
        -> equal? #black maybe              -> equal? #black to :complex [0 0]
        -> equal? #black 0.0.0              -> equal? #black :color
        -> equal? #black `1`                -> equal? #black "#000000"
        -> equal? #black "000000"           -> equal? [#black] [black] 
        -> equal? #black 'black             -> equal? [#black] [.black]
        -> equal? [#black] [.black:]        -> equal? #black  {/#000000/}                 
        -> equal? #black{/000000/} 
    ] => not? passed
    
    ; for :function
    ensure -> every? @[
        -> equal? var 'null?     null       -> equal? var 'true?    true  
        -> equal? var 'false?    false 
        -> equal? var 'version?  1.0.0      -> equal? var 'type?    :type 
        -> equal? var 'function? :function  -> equal? var 'char?    `a` 
        -> equal? @[var 'word?]  [word]     -> equal? @[var 'word?] [var]      
        -> equal? @[var 'word?]  [var:]     -> equal? @[var 'word?] [word:]    
        -> equal? var 'word?     'word?     -> equal? var 'var      'var       
        -> equal? @[var 'word?]  [.var]     -> equal? @[var 'word?] [.word]    
        -> equal? @[var 'word?]  [.var:]    -> equal? @[var 'word?] [.word:]   
        -> equal? var 'regex?    {/var/}    -> equal? var 'regex?   {/regex?/} 
    ] => not? passed
    
]


topic « less?
do [
    
    
    
    
    
]


topic « lessOrEqual?
do [
    
    
    topic « lessOrEqual? - :integer :floating :rational
    
    ensure -> lessOrEqual? 1 2
    ensure -> lessOrEqual? 1 2.0
    ensure -> lessOrEqual? 1 to :rational @[2 1]
    ensure -> 1 =< 2
    ensure -> 1 =< 2.0
    ensure -> 1 =< to :rational @[2 1]
    passed
    
    ensure -> lessOrEqual? 1 1
    ensure -> lessOrEqual? 1 1.0
    ensure -> lessOrEqual? 1 to :rational @[1 1]
    ensure -> 1 =< 1
    ensure -> 1 =< 1.0
    ensure -> 1 =< to :rational @[1 1]
    passed
    
    ensure -> not? lessOrEqual? 2 1
    ensure -> not? lessOrEqual? 2 1.0
    ensure -> not? lessOrEqual? 2 to :rational @[1 1]
    ensure -> not? 2 =< 1
    ensure -> not? 2 =< 1.0
    ensure -> not? 2 =< :rational @[1 1]
    passed
    
    
]


topic « notEqual?
do [
    
    
    topic « notEqual? - :integer :floating :rational
    
    ensure -> not? notEqual? 1 1
    ensure -> not? notEqual? 1 1.0
    ensure -> not? notEqual? 1 to :rational @[1 1]
    ensure -> not? notEqual? 1 to :rational @[5 5]
    ensure -> notEqual? 1 2
    ensure -> notEqual? 1 2.0
    ensure -> notEqual? 1 :rational @[1 2]
    ensure -> not? 1 <> 1
    ensure -> not? 1 <> 1.0
    ensure -> not? 1 <> to :rational @[1 1]
    ensure -> not? 1 <> to :rational @[5 5]
    ensure -> 1 <> 2
    ensure -> 1 <> 2.0
    ensure -> 1 <> :rational @[1 2]
    passed
    
    ensure -> not? notEqual? 1.0 1
    ensure -> not? notEqual? 1.0 1.0
    ensure -> not? notEqual? 1.0 to :rational @[1 1]
    ensure -> not? notEqual? 1.0 to :rational @[5 5]
    ensure -> notEqual? 1.0 2
    ensure -> notEqual? 1.0 2.0
    ensure -> notEqual? 1.0 to :rational @[1 2]
    ensure -> not? 1.0 <> 1
    ensure -> not? 1.0 <> 1.0
    ensure -> not? 1.0 <> to :rational @[1 1]
    ensure -> not? 1.0 <> to :rational @[5 5]
    ensure -> 1.0 <> 2
    ensure -> 1.0 <> 2.0
    ensure -> 1.0 <> to :rational @[1 2]
    passed
    
    ensure -> not? notEqual? to :rational @[5 5] 1
    ensure -> not? notEqual? to :rational @[5 5] 1.0
    ensure -> not? notEqual? to :rational @[5 5] to :rational @[1 1]
    ensure -> notEqual? to :rational @[5 5] 2
    ensure -> notEqual? to :rational @[5 5] 2.0
    ensure -> notEqual? to :rational @[5 5] to :rational @[1 2]
    ensure -> not? (to :rational @[5 5]) <> 1
    ensure -> not? (to :rational @[5 5]) <> 1.0
    ensure -> not? (to :rational @[5 5]) <> to :rational @[1 1]
    ensure -> (to :rational @[5 5]) <> 2
    ensure -> (to :rational @[5 5]) <> 2.0
    ensure -> (to :rational @[5 5]) <> to :rational @[1 2]
    passed
    
    
    topic « notEqual? - :quantity
    
    ensure -> not? notEqual? 1:usd 1
    ensure -> not? notEqual? 1:m   1
    ensure -> not? notEqual? 1:m2  1
    ensure -> not? notEqual? 1:m3  1
    ensure -> not? notEqual? 1:c   1
    ensure -> not? notEqual? 1:f   1
    ensure -> not? 1:usd <> 1
    ensure -> not? 1:m   <> 1
    ensure -> not? 1:m2  <> 1
    ensure -> not? 1:m3  <> 1
    ensure -> not? 1:c   <> 1
    ensure -> not? 1:f   <> 1
    passed
    
    ensure -> not? notEqual? 1 1:usd
    ensure -> not? notEqual? 1 1:m
    ensure -> not? notEqual? 1 1:m2
    ensure -> not? notEqual? 1 1:m3
    ensure -> not? notEqual? 1 1:c
    ensure -> not? notEqual? 1 1:f
    ensure -> not? 1 <> 1:usd
    ensure -> not? 1 <> 1:m
    ensure -> not? 1 <> 1:m2
    ensure -> not? 1 <> 1:m3
    ensure -> not? 1 <> 1:c
    ensure -> not? 1 <> 1:f
    passed
    
    ensure -> not? notEqual? 1:usd 1.0
    ensure -> not? notEqual? 1:m   1.0
    ensure -> not? notEqual? 1:m2  1.0
    ensure -> not? notEqual? 1:m3  1.0
    ensure -> not? notEqual? 1:c   1.0
    ensure -> not? notEqual? 1:f   1.0
    ensure -> not? 1:usd <> 1.0
    ensure -> not? 1:m   <> 1.0
    ensure -> not? 1:m2  <> 1.0
    ensure -> not? 1:m3  <> 1.0
    ensure -> not? 1:c   <> 1.0
    ensure -> not? 1:f   <> 1.0
    passed
    
    ensure -> not? notEqual? 1.0 1:usd
    ensure -> not? notEqual? 1.0 1:m
    ensure -> not? notEqual? 1.0 1:m2
    ensure -> not? notEqual? 1.0 1:m3
    ensure -> not? notEqual? 1.0 1:c
    ensure -> not? notEqual? 1.0 1:f
    ensure -> not? 1.0 <> 1:usd
    ensure -> not? 1.0 <> 1:m
    ensure -> not? 1.0 <> 1:m2
    ensure -> not? 1.0 <> 1:m3
    ensure -> not? 1.0 <> 1:c
    ensure -> not? 1.0 <> 1:f
    passed
    
    ensure -> not? notEqual? 1:usd to :rational @[5 5]
    ensure -> not? notEqual? 1:m   to :rational @[5 5]
    ensure -> not? notEqual? 1:m2  to :rational @[5 5]
    ensure -> not? notEqual? 1:m3  to :rational @[5 5]
    ensure -> not? notEqual? 1:c   to :rational @[5 5]
    ensure -> not? notEqual? 1:f   to :rational @[5 5]
    ensure -> not? 1:usd <> to :rational @[5 5]
    ensure -> not? 1:m   <> to :rational @[5 5]
    ensure -> not? 1:m2  <> to :rational @[5 5]
    ensure -> not? 1:m3  <> to :rational @[5 5]
    ensure -> not? 1:c   <> to :rational @[5 5]
    ensure -> not? 1:f   <> to :rational @[5 5]
    passed
    
    ensure -> not? notEqual? to :rational @[5 5] 1:usd
    ensure -> not? notEqual? to :rational @[5 5] 1:m
    ensure -> not? notEqual? to :rational @[5 5] 1:m2
    ensure -> not? notEqual? to :rational @[5 5] 1:m3
    ensure -> not? notEqual? to :rational @[5 5] 1:c
    ensure -> not? notEqual? to :rational @[5 5] 1:f
    ensure -> not? (to :rational @[5 5]) <> 1:usd
    ensure -> not? (to :rational @[5 5]) <> 1:m
    ensure -> not? (to :rational @[5 5]) <> 1:m2
    ensure -> not? (to :rational @[5 5]) <> 1:m3
    ensure -> not? (to :rational @[5 5]) <> 1:c
    ensure -> not? (to :rational @[5 5]) <> 1:f
    passed
    
    ensure -> notEqual? 2:usd 1
    ensure -> notEqual? 2 1:usd
    ensure -> notEqual? 2:usd 1.0
    ensure -> notEqual? 2.0 1:usd
    ensure -> notEqual? 2:usd to :rational @[5 5]
    ensure -> notEqual? to :rational @[2 5] 1:usd
    passed
    
    ensure -> not? notEqual? 1.5:m 150:cm 
    ensure -> notEqual? 2:m 2:cm
    passed 
    
    
    topic « notEqual? - :null
    
    ensure -> not? notEqual? null null
    ensure -> not? notEqual? null ø
    ensure -> not? notEqual? ø ø
    ensure -> not? notEqual? ø null
    ensure -> not? null <> null
    ensure -> not? null <> ø
    ensure -> not? ø <> ø
    ensure -> not? ø <> null
    passed
    
    ensure -> notEqual? ø 1
    ensure -> notEqual? ø 1.0
    ensure -> notEqual? ø "ø"
    ensure -> notEqual? ø `ø`
    ensure -> ø <> 1
    ensure -> ø <> 1.0
    ensure -> ø <> "ø"
    ensure -> ø <> `ø`
    passed
    
    
    topic « notEqual? - :logical
    
    ensure -> not? notEqual? true true
    ensure -> not? notEqual? true (1 > 0)
    ensure -> not? true <> true
    ensure -> not? true <> (1 > 0)
    passed
    
    ensure -> notEqual? true maybe
    ensure -> notEqual? true false
    ensure -> true <> maybe
    ensure -> true <> false
    passed
    
    
    topic « notEqual? - :complex
    
    ensure -> not? notEqual? to :complex [0 2] ((to :complex [1 2]) - 1) 
    passed
    
    ensure -> notEqual? to :complex [1 2] to :complex @[neg 1 2] 
    ensure -> notEqual? to :complex [1 2] 1
    ensure -> notEqual? 1 to :complex [1 2]
    ensure -> not? (to :complex [0 2]) <> ((to :complex [1 2]) - 1) 
    ensure -> (to :complex [1 2]) <> to :complex @[neg 1 2] 
    ensure -> (to :complex [1 2]) <> 1
    ensure -> 1 <> to :complex [1 2]
    passed
    
    
    topic « notEqual? - :version
    
    ensure -> not? notEqual? 1.2.3 1.2.3
    ensure -> not? 1.2.3 <> 1.2.3
    passed
    
    ensure -> notEqual? 1.2.3 1.2.3-pre
    ensure -> notEqual? 1.2.3 1.2.3-dev
    ensure -> 1.2.3 <> 1.2.3-pre
    ensure -> 1.2.3 <> 1.2.3-dev
    passed
    
    
    topic « notEqual? - :type
    
    ensure -> not? notEqual? :string type "a"
    ensure -> not? notEqual? :integer type 1
    ensure -> not? notEqual? :floating type 1.5
    passed
    
    ensure -> notEqual? :string :integer
    ensure -> notEqual? :string :char
    ensure -> notEqual? :integer :floating
    passed
    
    
    topic « notEqual? - :char
    
    ensure -> not? notEqual? `a` `a`
    ensure -> not? `a` <> `a`
    passed
    
    ensure -> notEqual? `a` "a" 
    ensure -> notEqual? `a` `b`
    ensure -> notEqual? `1` 1
    ensure -> notEqual? "a" `a` 
    ensure -> notEqual? `b` `a`
    ensure -> notEqual? 1   `1`
    ensure -> `a` <> "a" 
    ensure -> `a` <> `b`
    ensure -> `1` <>  1
    ensure -> "a" <> `a` 
    ensure -> `b` <> `a`
    ensure ->  1  <> `1`
    passed 
    
    
    topic « notEqual? - :string
    
    ensure -> not? notEqual? "Art" "Arturo" -- "uro"
    ensure -> not? "Art" <> "Arturo" -- "uro"
    passed
    
    ensure -> notEqual? "A" "B"
    ensure -> notEqual? "Art" "Bob"
    passed
    
    ensure -> notEqual? "a"    `a` 
    ensure -> notEqual? "10"   10 
    ensure -> notEqual? "10"   10
    ensure -> notEqual? ["help"] [help]
    ensure -> notEqual? ["a"]    [a: "a"]
    ensure -> notEqual? "help"   'help
    ensure -> notEqual? ["help"] [.help]
    ensure -> notEqual? ["help"] ['help: "help"]
    ensure -> "a"      <> `a` 
    ensure -> "10"     <> 10 
    ensure -> "10"     <> 10
    ensure -> ["help"] <> [help]
    ensure -> ["a"]    <> [a: "a"]
    ensure -> "help"   <> 'help
    ensure -> ["help"] <> [.help]
    ensure -> ["help"] <> ['help: "help"]
    passed
    
    
    topic « notEqual? - :word
    
    ensure -> not? notEqual? [word] [word]
    ensure -> notEqual? [word] [otherWord]
    ensure -> notEqual? [word] ["word"]
    ensure -> notEqual? [word] [word: word]
    ensure -> notEqual? [word] ['word]
    ; ensure -> notEqual? [word] [.word]
    ensure -> notEqual? [word] [.word: word]
    passed
    
    
    topic « notEqual? - :label
    
    ensure -> not? notEqual? [label: value] [label: value]
    passed
    
    ensure -> notEqual? [label: value] [label: value2]
    ensure -> notEqual? [label: value] [label2: value]
    passed
    
    ensure -> notEqual? [label: value] ["label"]
    ensure -> notEqual? ["label": value] ["label"]
    ensure -> notEqual? [label: value] ["value"]
    ensure -> notEqual? [label: "value"] ["value"]
    ensure -> notEqual? [label: "value"] ["label" "value"]
    passed
    
    ensure -> notEqual? [label: "value"] [label]
    ensure -> notEqual? [label: "value"] [value]
    ensure -> notEqual? [label: "value"] [label value]
    passed
    
    ensure -> notEqual? [label: 'world] ['label]
    ensure -> notEqual? [label: 'world] ['word]
    ensure -> notEqual? [label: 'world] ['label 'word]
    passed
    
    ensure -> notEqual? [label: .attr] [.label]
    ensure -> notEqual? [label: .attr] [.attr]
    ; ensure -> notEqual? [label: .attr: "a"] [.label: .attr: "a"]
    ensure -> notEqual? [label: .attr: "a"] [.label: "a"]
    ensure -> notEqual? [label: .attr: "a"] [.attr: "a"]
    passed
    
    
    topic « notEqual? - :literal
    
    ensure -> not? notEqual? 'literal 'literal
    ensure -> notEqual? 'literal 'other
    ensure -> notEqual? 'literal "literal"
    ensure -> notEqual? ['literal] ["literal"]
    ensure -> notEqual? ['literal] [literal]
    ensure -> notEqual? ['literal] [.literal]
    ensure -> notEqual? ['literal] [literal: 'literal]
    passed
    
    
    topic « notEqual? - :attribute
    
    ensure -> not? notEqual? [.attr] [.attr]
    ensure -> notEqual? [.attr] ["attr"]
    ; ensure -> notEqual? [.attr] [attr]
    ensure -> notEqual? [.attr] [attr: .attr]
    ensure -> notEqual? [.attr] ['attr]
    ensure -> notEqual? [.attr] [.other]
    ensure -> notEqual? [.attr] [.attr: .attr]
    passed
    
    
    topic « notEqual? - :attributeLabel
    
    ensure -> not? notEqual? [.attr: value] [.attr: value]
    passed
    
    ensure -> notEqual? [.attr: value] ["attr"]
    ensure -> notEqual? [.attr: value] ["value"]
    ensure -> notEqual? [.attr: value] ["attr" "value"]
    passed
    
    ; ensure -> notEqual? [.attr: value] [attr]
    ensure -> notEqual? [.attr: value] [attr: .attr:]
    ; ensure -> notEqual? [.attr: value] [attr: value]
    ensure -> notEqual? [.attr: value] [attr: .attr: value]
    passed
    
    ensure -> notEqual? [.attr: value] ['attr]
    ensure -> notEqual? [.attr: value] ['value]
    ensure -> notEqual? [.attr: value] ['attr 'value]
    passed
    
    ensure -> notEqual? [.attr: value] [.attr]
    ensure -> notEqual? [.attr: value] [.value]
    ensure -> notEqual? [.attr: value] [.other: value]
    ensure -> notEqual? [.attr: value] [.attr: other]
    passed
    
    
    topic « notEqual? - :path
    
    a: #[name: "John", surname: "Doe"]
    b: @["Joe" "Jane" "Jesse"]
    
    ensure -> not? notEqual? a\name "John" 
    ensure -> not? notEqual? a\surname "Doe" 
    ensure -> notEqual? a\name "Jane" 
    ensure -> notEqual? a\name 1
    passed
    
    ensure -> not? notEqual? b\0 "Joe" 
    ensure -> not? notEqual? b\1 "Jane" 
    ensure -> not? notEqual? b\2 "Jesse" 
    ensure -> notEqual? b\2 "Walter" 
    passed
    
    ensure -> not? notEqual? [b\0] [b\0]
    ensure -> not? notEqual? [a\name] [a\name]
    ensure -> notEqual? [b\0] [b\1]
    ensure -> notEqual? [a\name] [a\surname]
    passed
    
    
    topic « notEqual? - :pathLabel
       
    ensure -> not? notEqual? [a\name: "John"] [a\name: "John"]
    ensure -> notEqual? [a\surname: "Doe"] [b\surname: "Doe" ]
    ensure -> notEqual? [a\name: "John"] [b\name: "Jane"]
    ensure -> notEqual? [a\name: "John"] [b\name: "John"]
    passed
    
    
    topic « notEqual? - :symbol
    
    ensure -> not? notEqual? [+] [+]
    ensure -> notEqual? [+] [-]
    ensure -> notEqual? [+] [++]
    ensure -> notEqual? [+] [`+`]
    ensure -> notEqual? [+] [{+}]
    ensure -> notEqual? [+] ["+"]
    ensure -> notEqual? [+] [plus]
    ensure -> notEqual? [+] ['+]
    passed
    
    
    topic « notEqual? - :regex
    
    ensure -> regex? {/[A-Z]/}
    ensure -> not? notEqual? {/[A-Z]/} {/[A-Z]/} 
    ensure -> notEqual? {/[A-Z]/} {/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]/}
    ensure -> notEqual? {/[A-Z]/} {[A-Z]}
    ensure -> notEqual? {/[A-Z]/} "/[A-Z]/"
    passed
    
    
    topic « notEqual? - :binary
    
    ensure -> not? notEqual? "48 65 6C 6C 6F 20 77 6F 72 6C 64"
        ~{|to :binary "Hello world"|}
    ensure -> not? notEqual? "00" ~{|to :binary 0|}
    ensure -> not? notEqual? "01" ~{|to :binary 1|}
    ensure -> not? notEqual? "0A" ~{|to :binary 10|}
    ensure -> not? notEqual? "05" ~{|to :binary 5|}
    passed
    
    a: to :binary 0
    
    ensure -> notEqual? a 0
    ensure -> notEqual? "49 65 6C 6C 6F 20 77 6F 72 6C 64"
        ~{|to :binary "Hello world"|}
    passed
    
    
    topic « notEqual? - :bytecode
    
    x: to :bytecode [["print"][1 112 155]]
    
    ensure -> not? notEqual? x to :bytecode [["print"][1 112 155]]
    ensure -> notEqual? x to :bytecode [["print"][2 112 155]]
    ensure -> notEqual? x [["print"][2 112 155]]
    passed
    
    
    topic « notEqual? - :inline
    
    a: [(1 + 1)], b: [(1 + 1)] 
    ensure -> not? notEqual? a\0 b\0
    passed
    
    c: [(2 + 1)] 
    ensure -> notEqual? a\0 c\0
    passed
    
    d: [(3 - 1)] 
    ensure -> notEqual? a\0 d\0 ; even the calc (3-1) and (1+1) being 2, 
    passed                      ; they are different inlines 
                                ; with the same result when evaluated
    
    e: [(1 + 2 - 1)]
    ensure -> notEqual? a\0 e\0
    ensure -> notEqual? a\0 2
    passed
    
    
    topic « notEqual? - :block
    
    a: [1 + 1]
    ensure -> not? notEqual? a [1 + 1]
    ensure -> notEqual? a [2]
    ensure -> notEqual? a 2
    ensure -> notEqual? a [1 ++ 1]
    passed
    
    
    topic « notEqual? :range
    
    ensure -> not? notEqual? [0 1 2 3 4 5] @0..5
    ensure -> not? notEqual? [0 2 4] @0.. .step: 2 5
    ensure -> not? notEqual? @range.step: 2 0 5 @range.step: 2 0 4
    ensure -> notEqual? range.step: 2 0 5 range.step: 2 0 4
    passed
    
    
    topic « notEqual? :dictionary
    
    a: #[name: "Walter" surname: "Pinkman"]
    
    ensure -> not? notEqual? a #[name: "Walter" surname: "Pinkman"]
    ensure -> notEqual? a #[name: "Jesse" surname: "Pinkman"]
    ensure -> notEqual? a #[name "Jesse" surname "Pinkman"]
    ensure -> notEqual? a [name "Jesse" surname "Pinkman"]
    passed
    
    ensure -> not? notEqual? a\name "Walter"
    ensure -> not? notEqual? a\surname "Pinkman"
    ensure -> notEqual? a\surname "White"
    passed
    
    
    topic « notEqual? - :object
    
    define :person [name age][  
        init: -> this\name: capitalize this\name
        print: -> 
            render "NAME: |this\name|, AGE: |this\age|"
    ]
    
    define.as: :person :student [name age id][  
        init: -> this\name: capitalize this\name
        print: -> 
            render "NAME: |this\name|, AGE: |this\age|, ID: |this\id|"
    ]
    
    a: to :person ["Joe" 32]
    ensure -> not? notEqual? a to :person ["Joe" 32]
    ensure -> notEqual? to :person ["Joe" 32] #[name: "Joe" age: 32]
    ensure -> notEqual? to :person ["Joe" 32] to :student ["Joe" 32 15]
    passed
    
    a\name: "Jane"
    ensure -> not? notEqual? a to :person ["Jane" 32]
    passed
    
    
    topic « notEqual? - :store
    
    a: store "test.db"
    a\name: "John" a\surname: "Doe"
    b: store "test.db"
    b\name: "John" b\surname: "Doe"
    c: store "test2.db"
    c\name: "John" c\surname: "Doe"
    d: store "test3.db"
    d\name: "Jane" d\surname: "Doe"
    
    ensure -> not? notEqual? a a
    ensure -> not? notEqual? a b
    ensure -> not? notEqual? b a
    passed
    
    ensure -> notEqual? a c 
    ensure -> notEqual? c a 
    ensure -> notEqual? a d 
    ensure -> notEqual? d a 
    ensure -> notEqual? c d 
    ensure -> notEqual? d c 
    passed
    
    
    topic « notEqual? - :color
    
    ensure -> not? notEqual? #000 #black
    ensure -> not? notEqual? #fff #white
    ensure -> not? notEqual? #white #white
    ensure -> notEqual? #black #white
    ensure -> notEqual? #white #black
    passed
    
    
    topic « notEqual? - :function
    
    ensure -> not? notEqual? var 'print var 'print
    ensure -> notEqual? var 'inspect var 'print
    passed
    
    a: $[name surname][]
    A: $[name][]
    b: $[name][]
    c: $[name surname][]
    
    ensure -> not? notEqual? ~"|var 'a|" ~"|$[name surname][]|"
    ensure -> not? notEqual? ~"|var 'a|" ~"|var 'c|"
    ensure -> notEqual? ~"|var 'a|" ~"|var 'A|"
    ensure -> notEqual? ~"|var 'a|" ~"|var 'b|"
    passed
    
    
    topic « notEqual? - :database
    ; todo: test this
    
    
    topic « notEqual? - :date
    
    a: to :date .format: "MMM dd" "Jan 15"
    b: to :date .format: "MMM dd" "Jan 15"
    c: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    d: now
    
    ensure -> not? notEqual? a b 
    ensure -> notEqual? a c 
    ensure -> notEqual? a d
    passed 
    
    ensure -> not? notEqual? a\day c\day
    ensure -> not? notEqual? a\month c\month
    ensure -> notEqual? a\year c\year
    passed
    
    
    topic « notEqual? - incompatible types
    
    ; NOTES: 
    ; - to avoid repetition some tests may be not explicitly included
    ; - this test part tries to cover the most of possible behaviors,
    ;     including the possility of the Comparison module be rewritten, 
    ;     avoiding future broken changes
    ; - some combinations were not made, because it's considered very
    ;     improbable to happen, even with a future rewrite of 
    ;     the Comparison module
    
    ; for :integer
    
    ensure -> every? @[
        -> notEqual? 1 1
    ] => not?
    
    ensure -> not? every? @[
        -> notEqual? 1 null         -> notEqual? 1 true
        -> notEqual? 1 false        -> notEqual? 1 to :complex [1 1]
        -> notEqual? 1 1.0.0        -> notEqual? 1 :integer
        -> notEqual? 1 `1`          -> notEqual? 1 "1"
        -> notEqual? [1] [one]      -> notEqual? [1] [one:]
        -> notEqual? [1 1] [one: 1] -> notEqual? 1 '1
        -> notEqual? [1] [.1]       -> notEqual? [1] [.1:]
        -> notEqual? [1 1] [.1: 1]  -> notEqual? [1] [one\1]
        -> notEqual? [1] [one\1:]   -> notEqual? [1 1] [one\1: 1]
        -> notEqual? [1] [+]        -> notEqual? 1 {/1/}
        -> notEqual? 1 to :binary 1 -> notEqual? 1 to :binary 1
        -> notEqual? [1] [(1)]      -> notEqual? 1 [1]
        -> notEqual? 1 1..1         -> notEqual? 1 #[one: 1]
        -> notEqual? 0 #black       -> notEqual? 1 var 'one?
    ] => not? passed
    
    ; for :floating
    ensure -> not? every? @[
        -> notEqual? 1.0 null               -> notEqual? 1.0 true
        -> notEqual? 1.0 false              -> notEqual? 1.0 to :complex [1.0 1.0]
        -> notEqual? 1.0 1.0.0              -> notEqual? 1.0 :floating
        -> notEqual? 1.0 `1`                -> notEqual? 1.0 "1.0"
        -> notEqual? [1.0] [one]            -> notEqual? [1.0] [one: 1.0]
        -> notEqual? [1.0 1.0] [one: 1.0]   -> notEqual? 1.0 '1
        -> notEqual? [1.0] [.1]             -> notEqual? [1.0] [.1:]
        -> notEqual? [1.0 1.0] [.1: 1.0]    -> notEqual? [1.0] [one\1]
        -> notEqual? [1.0] [one\1:]         -> notEqual? [1.0 1.0] [one\1: 1.0]
        -> notEqual? [1.0] [+]              -> notEqual? 1.0 {/1.0/}
        -> notEqual? 1.0 to :binary 1.0     -> notEqual? 1.0 to :binary 1.0
        -> notEqual? [1.0] [(1.0)]          -> notEqual? 1.0 [1]
        -> notEqual? 1.0 1..1               -> notEqual? 1.0 #[one: 1.0]
        -> notEqual? 0.0 #black             -> notEqual? 1.0 var 'one?
    ] => not? passed
    
    ; for :rational
    a: to :rational [1 1]
    ensure -> not? every? @[
        -> notEqual? a null                     -> notEqual? a true
        -> notEqual? a false                    -> notEqual? a to :complex [1 1]
        -> notEqual? a 1.0.0                    -> notEqual? a :rational
        -> notEqual? a `1`                      -> notEqual? a "1/1"
        -> notEqual? @[a] [one]                 -> notEqual? @[a] [one:]
        -> notEqual? @[a a] [one: 1]            -> notEqual? 1 '1
        -> notEqual? @[a] [.1]                  -> notEqual? @[a] [.1:]
        -> notEqual? @[a a] [.1: 1]             -> notEqual? @[a] [one\1]
        -> notEqual? @[a] [one\1: 1]            -> notEqual? @[a a] [one\1: 1]
        -> notEqual? @[a] [+]                   -> notEqual? a {/1/1/}
        -> notEqual? a to :binary 1             -> notEqual? a to :binary 1
        -> notEqual? @[a] [(1)]                 -> notEqual? a [1]
        -> notEqual? a 1..1                     -> notEqual? a #[one: 1]
        -> notEqual? to :rational [1 1] #black  -> notEqual? a var 'one?
    ] => not? passed
    
    ; for :quantity
    ensure -> not? every? @[
        -> notEqual? 1:usd null                    -> notEqual? 1:usd true
        -> notEqual? 1:usd false                   -> notEqual? 1:usd to :complex [1 1]
        -> notEqual? 1:usd 1.0.0                   -> notEqual? 1:usd :quantity
        -> notEqual? 1:usd `1`                     -> notEqual? 1:usd "1USD"
        -> notEqual? [1:usd] [one]                 -> notEqual? [1:usd] [one:]
        -> notEqual? [1:usd 1:usd] [one: 1:usd]    -> notEqual? 1:usd '1
        -> notEqual? [1:usd] [.1]                  -> notEqual? [1:usd] [.1:]
        -> notEqual? [1:usd 1:usd] [.1: 1:usd]     -> notEqual? [1:usd] [one\1]
        -> notEqual? [1:usd] [one\1:]              -> notEqual? [1:usd 1:usd] [one\1: 1:usd]
        -> notEqual? [1:usd] [+]                   -> notEqual? 1:usd {/1USD/}
        -> notEqual? 1:usd to :binary 1            -> notEqual? 1:usd to :binary 1
        -> notEqual? [1:usd] [(1)]                 -> notEqual? 1:usd [1:usd]
        -> notEqual? 1:usd 1..1                    -> notEqual? 1:usd #[one: 1:usd]
        -> notEqual? 0:usd #black                  -> notEqual? 1:usd var 'one?
    ] => not? passed
    
    ensure -> not? every? @[ 
        -> notEqual? 1:m null              -> notEqual? 1:m true
        -> notEqual? 1:m false             -> notEqual? 1:m to :complex [1 1]
        -> notEqual? 1:m 1.0.0             -> notEqual? 1:m :quantity
        -> notEqual? 1:m `1`               -> notEqual? 1:m "1m"
        -> notEqual? [1:m] [one]           -> notEqual? [1:m] [one:]
        -> notEqual? [1:m 1:m] [one: 1:m]  -> notEqual? 1:m '1
        -> notEqual? [1:m] [.1]            -> notEqual? [1:m] [.1: 1:m]
        -> notEqual? [1:m 1:m] [.1: 1:m]   -> notEqual? [1:m] [one\1]
        -> notEqual? [1:m] [one\1:]        -> notEqual? [1:m 1:m] [one\1: 1:m]
        -> notEqual? [1:m] [+]             -> notEqual? 1:m {/1m/}
        -> notEqual? 1:m to :binary 1      -> notEqual? 1:m to :binary 1
        -> notEqual? [1:m] [(1)]           -> notEqual? 1:m [1:m]
        -> notEqual? 1:m 1..1              -> notEqual? 1:m #[one: 1:m]
        -> notEqual? 0:m #black            -> notEqual? 1:m var 'one?
    ] => not? passed
    
    ensure -> not? every? @[ 
        -> notEqual? 1:m3 null                 -> notEqual? 1:m3 true
        -> notEqual? 1:m3 false                -> notEqual? 1:m3 to :complex [1 1]
        -> notEqual? 1:m3 1.0.0                -> notEqual? 1:m3 :quantity
        -> notEqual? 1:m3 `1`                  -> notEqual? 1:m3 "1m³"
        -> notEqual? [1:m3] [one]              -> notEqual? [1:m3] [one:]
        -> notEqual? [1:m3 1:m3] [one: 1:m3]   -> notEqual? 1:m3 '1
        -> notEqual? [1:m3] [.1]               -> notEqual? [1:m3] [.1:]
        -> notEqual? [1:m3 1:m3] [.1: 1:m3]    -> notEqual? [1:m3] [one\1]
        -> notEqual? [1:m3] [one\1:]           -> notEqual? [1:m3 1:m3] [one\1: 1:m3]
        -> notEqual? [1:m3] [+]                -> notEqual? 1:m3 {/1m³/}
        -> notEqual? 1:m3 to :binary 1         -> notEqual? 1:m3 to :binary 1
        -> notEqual? [1:m3] [(1)]              -> notEqual? 1:m3 [1:m3]
        -> notEqual? 1:m3 1..1                 -> notEqual? 1:m3 #[one: 1:m3]
        -> notEqual? 0:m3 #black               -> notEqual? 1:m3 var 'one?
    ] => not? passed
    
    ensure -> not? every? @[ 
        -> notEqual? 1:c null              -> notEqual? 1:c true
        -> notEqual? 1:c false             -> notEqual? 1:c to :complex [1 1]
        -> notEqual? 1:c 1.0.0             -> notEqual? 1:c :quantity
        -> notEqual? 1:c `1`               -> notEqual? 1:c "1°C"
        -> notEqual? [1:c] [one]           -> notEqual? [1:c] [one:]
        -> notEqual? [1:c 1:c] [one: 1:c]  -> notEqual? 1:c '1
        -> notEqual? [1:c] [.1]            -> notEqual? [1:c] [.1:]
        -> notEqual? [1:c 1:c] [.1: 1:c]   -> notEqual? [1:c] [one\1]
        -> notEqual? [1:c] [one\1:]        -> notEqual? [1:c 1:c] [one\1: 1:c]
        -> notEqual? [1:c] [+]             -> notEqual? 1:c {/1°C/}
        -> notEqual? 1:c to :binary 1      -> notEqual? 1:c to :binary 1
        -> notEqual? [1:c] [(1)]           -> notEqual? 1:c [1:c]
        -> notEqual? 1:c 1..1              -> notEqual? 1:c #[one: 1:c]
        -> notEqual? 0:c #black            -> notEqual? 1:c var 'one?
    ] => not? passed
    
    ; for :null
    ensure -> not? every? @[
        -> notEqual? null 0                        -> notEqual? null 0.0            
        -> notEqual? null to :rational [1 1]       -> notEqual? null true
        -> notEqual? null false                    -> notEqual? null to :complex [0 0]
        -> notEqual? null 0.0.0                    -> notEqual? null :null
        -> notEqual? null `ø`                      -> notEqual? null "null"
        -> notEqual? @[null] [null]                -> notEqual? @[null] [null:]
        -> notEqual? @[null null] [null: null]     -> notEqual? null 'null
        -> notEqual? @[null] [.null]               -> notEqual? @[null] [.null:]
        -> notEqual? @[null null] [.null: null]    -> notEqual? @[null] [null\null]
        -> notEqual? @[null] [null\null:]          -> notEqual? @[null null] [null\null: null]
        -> notEqual? @[null] [ø]                   -> notEqual? null {/null/}
        -> notEqual? null {/ø/}                    -> notEqual? null to :binary 0   
        -> notEqual? null to :binary 0             -> notEqual? @[null] [(null)]         
        -> notEqual? null [null]                   -> notEqual? null 0..0            
        -> notEqual? null #[null: null]            -> notEqual? null #black          
        -> notEqual? null var 'null?
    ] => not? passed
    
    ; for :logical
    ensure -> not? every? @[
        -> notEqual? true 0                     -> notEqual? true 0.0            
        -> notEqual? true to :rational [1 1]    -> notEqual? true to :complex [1 1]
        -> notEqual? true 0.0.0                 -> notEqual? true :true
        -> notEqual? true `0`                   -> notEqual? true "true"
        -> notEqual? @[true] [true]             -> notEqual? @[true] [true: true]
        -> notEqual? @[true true] [true: true]  -> notEqual? true 'true
        -> notEqual? @[true] [.true]            -> notEqual? @[true] [.true:]
        -> notEqual? @[true true] [.true: true] -> notEqual? @[true] [true\true]
        -> notEqual? @[true] [true\true:]       -> notEqual? @[true true] [true\true: true]
        -> notEqual? @[true] [ø]                -> notEqual? true {/true/}
        -> notEqual? true to :binary 0          -> notEqual? true to :binary 0             
        -> notEqual? @[true] [(true)]           -> notEqual? true [true]                   
        -> notEqual? true 0..0                  -> notEqual? true #[true: true]            
        -> notEqual? true #black                -> notEqual? true var 'true?
    ] => not? passed
    
    ensure -> not? every? @[
        -> notEqual? false 0                        -> notEqual? false 0.0            
        -> notEqual? false to :rational [1 1]       -> notEqual? false to :complex [1 1]
        -> notEqual? false 0.0.0                    -> notEqual? false :false
        -> notEqual? false `0`                      -> notEqual? false "false"
        -> notEqual? @[false] [false]               -> notEqual? @[false] [false:]
        -> notEqual? @[false false] [false: false]  -> notEqual? false 'false
        -> notEqual? @[false] [.false]              -> notEqual? @[false] [.false:]
        -> notEqual? @[false false] [.false: false] -> notEqual? @[false] [false\false]
        -> notEqual? @[false] [false\false:]        -> notEqual? @[false false] [false\false: false]
        -> notEqual? @[false] [ø]                   -> notEqual? false {/false/}
        -> notEqual? false to :binary 0             -> notEqual? false to :binary 0                
        -> notEqual? @[false] [(false)]             -> notEqual? false [false]                     
        -> notEqual? false 0..0                     -> notEqual? false #[false: false]             
        -> notEqual? false #black                   -> notEqual? false var 'false?
    ] => not? passed
    
    ensure -> not? every? @[
        -> notEqual? maybe 0                        -> notEqual? maybe 0.0            
        -> notEqual? maybe to :rational [1 1]       -> notEqual? maybe to :complex [1 1]
        -> notEqual? maybe 0.0.0                    -> notEqual? maybe :maybe
        -> notEqual? maybe `0`                      -> notEqual? maybe "maybe"
        -> notEqual? @[maybe] [maybe]               -> notEqual? @[maybe] [maybe:]
        -> notEqual? @[maybe maybe] [maybe: maybe]  -> notEqual? maybe 'maybe
        -> notEqual? @[maybe] [.maybe]              -> notEqual? @[maybe] [.maybe:]
        -> notEqual? @[maybe maybe] [.maybe: maybe] -> notEqual? @[maybe] [maybe\maybe]
        -> notEqual? @[maybe] [maybe\maybe:]        -> notEqual? @[maybe maybe] [maybe\maybe: maybe]
        -> notEqual? @[maybe] [ø]                   -> notEqual? maybe {/maybe/}
        -> notEqual? maybe to :binary 0             -> notEqual? maybe to :binary 0
        -> notEqual? @[maybe] [(maybe)]             -> notEqual? maybe [maybe]
        -> notEqual? maybe 0..0                     -> notEqual? maybe #[maybe: maybe]             
        -> notEqual? maybe #black                   
    ] => not? passed
    
    ; for :complex
    a: to :complex [1 1]
    ensure -> not? every? @[
        -> notEqual? a 1                        -> notEqual? a 1.0            
        -> notEqual? a to :rational [1 1]       -> notEqual? a null                    
        -> notEqual? a true                     -> notEqual? a false
        -> notEqual? a 1.0.0                    -> notEqual? a :rational
        -> notEqual? a `1`                      -> notEqual? a "1.0+1.0i"
        -> notEqual? @[a] [one]                 -> notEqual? @[a] [one:]
        -> notEqual? @[a a] [one: 1]            -> notEqual? 1 '1
        -> notEqual? @[a] [.1]                  -> notEqual? @[a] [.1:]
        -> notEqual? @[a a] [.1: 1]             -> notEqual? @[a] [one\1]
        -> notEqual? @[a] [one\1:]              -> notEqual? @[a a] [one\1: 1]
        -> notEqual? @[a] [+]                   -> notEqual? a {/1.0+1.0i/}
        -> notEqual? a to :binary 1             -> notEqual? a to :binary 1
        -> notEqual? @[a] [(1)]                 -> notEqual? a [1]
        -> notEqual? a 1..1                     -> notEqual? a #[one: 1]
        -> notEqual? to :complex [0 0] #black   -> notEqual? a var 'one?
    ] => not? passed
    
    ; for :version
    ensure -> not? every? @[
        -> notEqual? 1.0.0 1                        -> notEqual? 1.0.0 1.0          
        -> notEqual? 1.0.0 to :rational [1 1]       -> notEqual? 1.0.0 null                    
        -> notEqual? 1.0.0 true                     -> notEqual? 1.0.0 false                   
        -> notEqual? 1.0.0 to :complex [1.0 1.0]    -> notEqual? 1.0.0 :floating
        -> notEqual? 1.0.0 `1`                      -> notEqual? 1.0.0 "1.0.0"
        -> notEqual? [1.0.0] [one]                  -> notEqual? [1.0.0] [one:]
        -> notEqual? [1.0.0 1.0.0] [one: 1.0.0]     -> notEqual? 1.0.0 '1
        -> notEqual? [1.0.0] [.1]                   -> notEqual? [1.0.0] [.1:]
        -> notEqual? [1.0.0 1.0.0] [.1: 1.0.0]      -> notEqual? [1.0.0] [one\1]
        -> notEqual? [1.0.0] [one\1:]               -> notEqual? [1.0.0 1.0.0] [one\1: 1.0.0]
        -> notEqual? [1.0.0] [+]                    -> notEqual? 1.0.0 {/1.0.0/}
        -> notEqual? 1.0.0 to :binary 1.0           -> notEqual? 1.0.0 to :binary 1.0
        -> notEqual? [1.0.0] [(1.0.0)]              -> notEqual? 1.0.0 [1.0.0]
        -> notEqual? 1.0.0 1..1                     -> notEqual? 1.0.0 #[one: 1.0.0]
        -> notEqual? 0.0.0 #black                   -> notEqual? 1.0.0 var 'version?
    ] => not? passed
    
    ; for :type
    ensure -> not? every? @[
        -> notEqual? :1 1                              -> notEqual? :1 1.0          
        -> notEqual? :integer 1                        -> notEqual? :floating 1.0          
        -> notEqual? :rational to :rational [1 1]      -> notEqual? :null null                    
        -> notEqual? :true true                        -> notEqual? :false false                   
        -> notEqual? :logical false                    -> notEqual? :complex to :complex [1 1]   
        -> notEqual? :version 1.0.0                    -> notEqual? :T `T`                         
        -> notEqual? :char `T`                         -> notEqual? :string ":type"
        -> notEqual? [:type] [type]                    -> notEqual? [:word] [word]                     
        -> notEqual? [:type] [type:]                   -> notEqual? [:label] [label:]
        -> notEqual? [:type :type] [type: :type]       -> notEqual? :1 '1
        -> notEqual? :literal '1                       -> notEqual? [:type] [.type]                      
        -> notEqual? [:attribute] [.type]              -> notEqual? [:type] [.type:]
        -> notEqual? [:attributeLabel] [.type:]        -> notEqual? [:type :type] [.type: :type]         
        -> notEqual? [:type] [type\type]               -> notEqual? [:path] [type\type]
        -> notEqual? [:type] [type\type:]              -> notEqual? [:pathLabel] [type\type:]            
        -> notEqual? [:type :type] [type\type: :type]  -> notEqual? [:type] [+]                       
        -> notEqual? [:symbol] [+]                     -> notEqual? :type {/:type/}
        -> notEqual? :regex {/:type/}                  -> notEqual? :type to :binary 1.0              
        -> notEqual? :binary to :binary 1.0            -> notEqual? [:type] [(:type)]                 
        -> notEqual? [:inline] [(:type)]               -> notEqual? :type [:type]
        -> notEqual? :block [:type]                    -> notEqual? :type 1..1                        
        -> notEqual? :range 1..1                       -> notEqual? :type #[type: :type]
        -> notEqual? :dictionary #[type: :type]        -> notEqual? :type #black                      
        -> notEqual? :color #black                     -> notEqual? :type var 'type?
        -> notEqual? :function var 'one?
    ] => not? passed
    
    ; for :char
    ensure -> not? every? @[
        -> notEqual? `1` 1.0          
        -> notEqual? `1` to :rational [1 1]    -> notEqual? `ø` null                    
        -> notEqual? `t` true                  -> notEqual? `f` false                   
        -> notEqual? `1` to :complex [1.0 1.0] -> notEqual? `T` :floating
        -> notEqual? [`a`] [one]               -> notEqual? [`a`] [a: `a`]
        -> notEqual? [`a` `a`] [a: `a`]        -> notEqual? `a` 'a
        -> notEqual? [`a`] [.1]                -> notEqual? [`a`] [.a:]
        -> notEqual? [`a` `a`] [.a: `a`]       -> notEqual? [`a`] [a\a]
        -> notEqual? [`a`] [a\a:]              -> notEqual? [`a` `a`] [a\a: `a`]
        -> notEqual? [`+`] [+]                 -> notEqual? `a` {/a/}
        -> notEqual? `1` to :binary 1          -> notEqual? `a` to :binary 1
        -> notEqual? [`1`] [(`1`)]             -> notEqual? `a` [`a`]
        -> notEqual? `1` 1..1                  -> notEqual? `a` #[a: `a`]
        -> notEqual? `1` #black                -> notEqual? `a` var 'char?
    ] => not? passed
    
    ; for :string
    ensure -> not? every? @[
        -> notEqual? "1" 1                             -> notEqual? "1/1" to :rational [1 1]          
        -> notEqual? "1.0" 1.0                         -> notEqual? "null" null                    
        -> notEqual? "" null                           -> notEqual? "true" true                  
        -> notEqual? "" false                          -> notEqual? "false" false                   
        -> notEqual? "1.0+1.0i" to :complex [1.0 1.0]  -> notEqual? "type" :floating
        -> notEqual? "floating" :floating              -> notEqual? ":floating" :floating
        -> notEqual? "1.0" :floating                   -> notEqual? ["a"] [a\a]
        -> notEqual? ["a"] [a\a:]                      -> notEqual? ["a" "a"] [a\a: "a"]
        -> notEqual? ["+"] [+]                         -> notEqual? "a" {/a/}
        -> notEqual? "01" to :binary 1                 -> notEqual? "1" to :binary 1
        -> notEqual? [""] [("")]                       -> notEqual? "" [""]
        -> notEqual? "1" 1..1                          -> notEqual? "a" #[a: "a"]
        -> notEqual? "#000000" #black                  -> notEqual? "000000" #black              
        -> notEqual? "" var 'char?
    ] => not? passed
    
    ; for :word
    ensure -> not? every? @[        
        -> notEqual? [rational] @[to :rational [1 1]]      -> notEqual? [null]  @[null]                    
        -> notEqual? [true]     @[true]                    -> notEqual? [false] @[false]                   
        -> notEqual? [complex]  @[to :complex [1.0 1.0]]   -> notEqual? [type]  @[:floating]  
        -> notEqual? [floating] @[:floating]               -> notEqual? [a]     [a\a]                   
        -> notEqual? [a]         [a\a:]                    -> notEqual? [a]     [{/a/}]                      
        -> notEqual? [binary]   @[to :binary 1]            -> notEqual? [one]   @[to :binary 1]              
        -> notEqual? [word]     [(word)]                   -> notEqual? [word]  [[word]]                      
        -> notEqual? [range]    @[range 1 1]               -> notEqual? [a]     @[#[a: `a`]]               
        -> notEqual? [black]    @[#black ]                 -> notEqual? [word]  @[var 'word?]              
        -> notEqual? [var]      @[var 'word?]
    ] => not? passed
    
    ; for :label
    ensure -> not? every? @[
        -> notEqual? [rational:] @[to :rational [1 1]]      -> notEqual? [null:]     @[null]                                                        
        -> notEqual? [true:]     @[true]                    -> notEqual? [false:]    @[false]                   
        -> notEqual? [complex:]  @[to :complex [1.0 1.0]]   -> notEqual? [floating:]  [:floating]
        -> notEqual? [type:]      [:floating]               -> notEqual? [a:]         [a\a]                     
        -> notEqual? [a:]         [a\a:]                    -> notEqual? [a:]         [{/a:/}]                 
        -> notEqual? [binary:]   @[to :binary 1]            -> notEqual? [word:]      [(word:)]                
        -> notEqual? [label:]     [[label:]]                -> notEqual? [a:]        @[#[a: `a`]]               
        -> notEqual? [black:]     [#black ]                 -> notEqual? [var:]      @[var 'word?]
        -> notEqual? [word:]     @[var 'word?]
    ] => not? passed
    
    ; for :literal
    ; NOTE: technically, '+ is not a :literal, but a :symbolLiteral type ;)
    ensure -> not? every? @[
        -> notEqual? 'integer  1                   -> notEqual? 'floating 1.0
        -> notEqual? 'rational to :rational [1 1]  -> notEqual? 'one      to :rational [1 1]
        -> notEqual? 'null     null                -> notEqual? 'true     true    
        -> notEqual? 'false    false               -> notEqual? 'complex  to :complex [1.0 1.0]    
        -> notEqual? 'type     :floating           -> notEqual? 'floating :floating               
        -> notEqual? ['a]      [a\a]               -> notEqual? ['+]      [+]                       
        -> notEqual? 'a        {/a/}               -> notEqual? 'binary   to :binary 1            
        -> notEqual? ['word]   [('word)]           -> notEqual? 'word     ['word]                                     
        -> notEqual? 'range    1..1                -> notEqual? 'a        #[a: 'a]                
        -> notEqual? 'black    #black              -> notEqual? 'word?    var 'word?              
        -> notEqual? 'var      var 'var
    ] => not? passed
    
    ; for :attribute
    ensure -> not? every? @[           
        -> notEqual? [.rational] @[to :rational [1 1]]      -> notEqual? [.null]     @[null]                  
        -> notEqual? [.true]     @[true]                    -> notEqual? [.false]    @[false]                 
        -> notEqual? [.complex]  @[to :complex [1.0 1.0]]   -> notEqual? [.floating] @[:floating]                          
        -> notEqual? [.a]        @[{/a:/}]                  -> notEqual? [.binary]   @[to :binary 1]          
        -> notEqual? [.word]      [(.word)]                 -> notEqual? [.label]    @[[.label]]                               
        -> notEqual? [.a]        @[#[a: `a`]]               -> notEqual? [.black]    @[#black]                
        -> notEqual? [.var]      @[var 'word?]              -> notEqual? [.word]     @[var 'word?]
    ] => not? passed
    
    ; for :attributeLabel
    ensure -> not? every? @[           
        -> notEqual? [.rational:] @[to :rational [1 1]]    -> notEqual? [.null:]     @[null]                  
        -> notEqual? [.true:]     @[true]                  -> notEqual? [.false:]    @[false]                 
        -> notEqual? [.complex:]  @[to :complex [1.0 1.0]] -> notEqual? [.floating:]  [:floating]             
        -> notEqual? [.a:]         [a\a]                   -> notEqual? [.a: `a`]     [a\a: `a`]              
        -> notEqual? [.plus:]      [+]                     -> notEqual? [.a:]        @[{/a:/}]                
        -> notEqual? [.binary:]   @[to :binary 1]          -> notEqual? [.word:]      [(.word:)]               
        -> notEqual? [.label:]    @[[label:]]              -> notEqual? [.a:]        @[#[a: `a`]]             
        -> notEqual? [.black:]     [#black]                -> notEqual? [.var:]      @[var 'word?]            
        -> notEqual? [.word:]     @[var 'word?]
    ] => not? passed
    
    ; for :path & :pathLabel
    ensure -> not? every? @[
        -> notEqual? [a\b:] [a\b]
        -> notEqual? [a\b] [a\b:]
    ] => not? passed
    
    ; for :regex
    ensure -> not? every? @[
        -> notEqual? {/1/} 1                               -> notEqual? {/1/1/} to :rational [1 1]          
        -> notEqual? {/1.0/} 1.0                           -> notEqual? {/null/} null                    
        -> notEqual? {//} null                             -> notEqual? {/true/} true                  
        -> notEqual? {//} false                            -> notEqual? {/false/} false                   
        -> notEqual? {/1.0+1.0i/} to :complex [1.0 1.0]    -> notEqual? {/type/} :floating
        -> notEqual? {/floating/} :floating                -> notEqual? {/:floating/} :floating
        -> notEqual? {/1.0/} :floating                     -> notEqual? [{/a/}] [a\a]
        -> notEqual? [{/a/}] [a\a:]                        -> notEqual? [{/a/} {/a/}] [a\a: {/a/}]
        -> notEqual? [{/\+/}] [+]                          -> notEqual? {/01/} to :binary 1                 
        -> notEqual? {/1/} to :binary 1                    -> notEqual? [{//}] [({//})]                     
        -> notEqual? {//} [""]                             -> notEqual? {/1/} 1..1                          
        -> notEqual? {/a/} #[a: "a"]                       -> notEqual? {/#000000/} #black                  
        -> notEqual? {/000000/} #black                     -> notEqual? {/var/} var 'regex?
        -> notEqual? {/regex?/} var 'regex?
    ] => not? passed
    
    ; for :binary
    ensure -> not? every? @[
        -> notEqual? to :binary 1 1                    -> notEqual? to :binary 1 1.0                
        -> notEqual? to :binary 1 to :rational [1 1]   -> notEqual? to :binary 1 1:usd                
        -> notEqual? to :binary 1 1:m                  -> notEqual? to :binary 1 1:m3                 
        -> notEqual? to :binary 1 1:c                  -> notEqual? to :binary 0 null                 
        -> notEqual? to :binary 0 true                 -> notEqual? to :binary 0 false                
        -> notEqual? to :binary 0 maybe                -> notEqual? to :binary 1 to :complex [1 1]                  
        -> notEqual? to :binary 1 1.0.0                -> notEqual? to :binary 1 :type              
        -> notEqual? to :binary 1 :binary              -> notEqual? to :binary 1 `1`                  
        -> notEqual? to :binary "a" `a`                -> notEqual? to :binary 1 "01"                 
        -> notEqual? to :binary 1 "1"                  -> notEqual? @[to :binary 1] [binary]          
        -> notEqual? @[to :binary 1] [one]             -> notEqual? @[to :binary 1] [binary:]         
        -> notEqual? @[to :binary 1][.binary]          -> notEqual? @[to :binary 1] [.binary:]        
        -> notEqual? to :binary 1 {/01/}               -> notEqual? to :binary 1    {/1/}
    ] => not? passed
    
    ; for :range
    ensure -> not? every? @[
        -> notEqual? 1..1 1                        -> notEqual? 1..1 1.0
        -> notEqual? 1..1 a: to :rational [1 1]    -> notEqual? 1..1 1:usd
        -> notEqual? 1..1 1:m                      -> notEqual? 1..1 1:m3  
        -> notEqual? 1..1 1:c                      -> notEqual? 0..0 null 
        -> notEqual? 0..0 true                     -> notEqual? 0..0 false
        -> notEqual? 0..0 maybe                    -> notEqual? 1..1 to :complex [1 1]
        -> notEqual? 1..1 1.0.0                    -> notEqual? 1..1 :type                        
        -> notEqual? 1..1 :range                   -> notEqual? 1..1 `1` 
        -> notEqual? 1..1 "1"                      -> notEqual? 1..1 'range  
        -> notEqual? 1..1 {/1/}
    ] => not? passed
    
    ; for :dictionary, :object & :date
    define :person [name surname][]
    
    a: to :person ["Walter" "Pinkman"]
    b: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    
    ensure -> not? every? @[
        -> notEqual? #[name: "Walter" surname: "Pinkman"] a
        -> notEqual? a #[name: "Walter" surname: "Pinkman"]
        -> notEqual? #[year: 2023 day: 15 Month: "January"] b
        -> notEqual? b #[year: 2023 day: 15 Month: "January"]
    ] => not? passed
    
    ; for :color
    ensure -> not? every? @[
        -> notEqual? #black 0                  -> notEqual? #black 0.0
        -> notEqual? #black to :rational [1 1] -> notEqual? #black 0:usd 
        -> notEqual? #black 0:m                -> notEqual? #black 0:m3
        -> notEqual? #black 0:c                -> notEqual? #black null 
        -> notEqual? #black true               -> notEqual? #black false 
        -> notEqual? #black maybe              -> notEqual? #black to :complex [0 0]
        -> notEqual? #black 0.0.0              -> notEqual? #black :color
        -> notEqual? #black `1`                -> notEqual? #black "#000000"
        -> notEqual? #black "000000"           -> notEqual? [#black] [black] 
        -> notEqual? #black 'black             -> notEqual? [#black] [.black]
        -> notEqual? [#black] [.black:]        -> notEqual? #black  {/#000000/}                 
        -> notEqual? #black{/000000/} 
    ] => not? passed
    
    ; for :function
    ensure -> not? every? @[
        -> notEqual? var 'null?     null       -> notEqual? var 'true?    true  
        -> notEqual? var 'false?    false
        -> notEqual? var 'version?  1.0.0      -> notEqual? var 'type?    :type 
        -> notEqual? var 'function? :function  -> notEqual? var 'char?    `a` 
        -> notEqual? @[var 'word?]  [word]     -> notEqual? @[var 'word?] [var]      
        -> notEqual? @[var 'word?]  [var:]     -> notEqual? @[var 'word?] [word:]    
        -> notEqual? var 'word?     'word?     -> notEqual? var 'var      'var       
        -> notEqual? @[var 'word?]  [.var]     -> notEqual? @[var 'word?] [.word]    
        -> notEqual? @[var 'word?]  [.var:]    -> notEqual? @[var 'word?] [.word:]   
        -> notEqual? var 'regex?    {/var/}    -> notEqual? var 'regex?   {/regex?/} 
    ] => not? passed  
    
]

topic « same?
do [
    
    
    topic « same? - :integer :floating :rational
    
    ensure -> same? 1 1
    passed
    
    ensure -> not? same? 1 2
    ensure -> not? same? 1 1.0
    ensure -> not? same? 1 to :rational @[1 1]
    ensure -> not? same? 1 to :rational @[5 5]
    passed
    
    ensure -> same? 1.0 1.0
    passed
    
    ensure -> not? same? 1.0 2.0
    ensure -> not? same? 1.0 2
    ensure -> not? same? 1.0 to :rational @[1 1]
    ensure -> not? same? 1.0 to :rational @[5 5]
    passed
    
    ensure -> same? to :rational @[5 5] to :rational @[1 1]
    passed
    
    ensure -> not? same? to :rational @[5 5] to :rational @[1 2]
    ensure -> not? same? to :rational @[5 5] 1
    ensure -> not? same? to :rational @[5 5] 1.0
    passed
    
    
    topic « same? - :quantity
    
    ensure -> same? 1:usd 1:usd
    ensure -> same? 1:m   1:m
    ensure -> same? 1:m2  1:m2
    ensure -> same? 1:m3  1:m3
    ; ensure -> same? 1:c   1:c
    ; ensure -> same? 1:f   1:f
    passed
    
    ensure -> not? same? 1:usd 1
    ensure -> not? same? 1:m   1
    ensure -> not? same? 1:m2  1
    ensure -> not? same? 1:m3  1
    ensure -> not? same? 1:c   1
    ensure -> not? same? 1:f   1
    passed
    
    ensure -> not? same? 1 1:usd
    ensure -> not? same? 1 1:m
    ensure -> not? same? 1 1:m2
    ensure -> not? same? 1 1:m3
    ensure -> not? same? 1 1:c
    ensure -> not? same? 1 1:f
    passed
    
    ensure -> not? same? 1:usd 1.0
    ensure -> not? same? 1:m   1.0
    ensure -> not? same? 1:m2  1.0
    ensure -> not? same? 1:m3  1.0
    ensure -> not? same? 1:c   1.0
    ensure -> not? same? 1:f   1.0
    passed
    
    ensure -> not? same? 1.0 1:usd
    ensure -> not? same? 1.0 1:m
    ensure -> not? same? 1.0 1:m2
    ensure -> not? same? 1.0 1:m3
    ensure -> not? same? 1.0 1:c
    ensure -> not? same? 1.0 1:f
    passed
    
    ensure -> not? same? 1:usd to :rational @[5 5]
    ensure -> not? same? 1:m   to :rational @[5 5]
    ensure -> not? same? 1:m2  to :rational @[5 5]
    ensure -> not? same? 1:m3  to :rational @[5 5]
    ensure -> not? same? 1:c   to :rational @[5 5]
    ensure -> not? same? 1:f   to :rational @[5 5]
    passed
    
    ensure -> not? same? to :rational @[5 5] 1:usd
    ensure -> not? same? to :rational @[5 5] 1:m
    ensure -> not? same? to :rational @[5 5] 1:m2
    ensure -> not? same? to :rational @[5 5] 1:m3
    ensure -> not? same? to :rational @[5 5] 1:c
    ensure -> not? same? to :rational @[5 5] 1:f
    passed
    
    ensure -> not? same? 2:usd 1
    ensure -> not? same? 2 1:usd
    ensure -> not? same? 2:usd 1.0
    ensure -> not? same? 2.0 1:usd
    ensure -> not? same? 2:usd to :rational @[5 5]
    ensure -> not? same? to :rational @[2 5] 1:usd
    passed
    
    ensure -> not? same? 1.5:m 150:cm 
    ensure -> not? same? 2:m 2:cm
    ensure -> not? same? 1:m 1:usd
    ensure -> not? same? 1:m 1:m2
    ensure -> not? same? 1:m 1:m3
    ensure -> not? same? 1:m 1:c
    ensure -> not? same? 1:m 1:f
    ensure -> not? same? 1:usd 1:m
    ensure -> not? same? 1:usd 1:m2
    ensure -> not? same? 1:usd 1:m3
    ensure -> not? same? 1:usd 1:c
    ensure -> not? same? 1:usd 1:f
    ensure -> not? same? 2:m2 2:cm
    ensure -> not? same? 1:m2 1:usd
    ensure -> not? same? 1:m2 1:m
    ensure -> not? same? 1:m2 1:m3
    ensure -> not? same? 1:m2 1:c
    ensure -> not? same? 1:m2 1:f
    ensure -> not? same? 1:c 1:usd
    ensure -> not? same? 1:c 1:m2
    ensure -> not? same? 1:c 1:m3
    ensure -> not? same? 1:c 1:m
    ensure -> not? same? 1:c 1:f
    ensure -> not? same? 1:f 1:usd
    ensure -> not? same? 1:f 1:m
    ensure -> not? same? 1:f 1:m3
    ensure -> not? same? 1:f 1:c
    ensure -> not? same? 1:f 1:m2
    passed
    
    
    topic « same? - :null
    
    ensure -> same? null null
    ensure -> same? null ø
    ensure -> same? ø ø
    ensure -> same? ø null
    passed
    
    ensure -> not? same? ø 1
    ensure -> not? same? ø 1.0
    ensure -> not? same? ø "ø"
    ensure -> not? same? ø `ø`
    passed
    
    
    topic « same? - :logical
    
    ensure -> same? true true
    ensure -> same? true (1 > 0)
    ensure -> same? false false
    ensure -> same? false (1 < 0)
    ensure -> same? maybe maybe
    passed
    
    ensure -> not? same? true maybe
    ensure -> not? same? true false
    ensure -> not? same? false true
    ensure -> not? same? false maybe
    ensure -> not? same? maybe true
    ensure -> not? same? maybe false
    passed
    
    
    topic « same? - :complex
    
    ensure -> same? to :complex [0 2] ((to :complex [1 2]) - 1) 
    passed
    
    ensure -> not? same? to :complex [1 2] to :complex @[neg 1 2] 
    ensure -> not? same? to :complex [1 2] 1
    ensure -> not? same? 1 to :complex [1 2]
    passed
    
    
    topic « same? - :version
    
    ensure -> same? 1.2.3 1.2.3
    passed
    
    ensure -> not? same? 1.2.3 1.2.3-pre
    ensure -> not? same? 1.2.3 1.2.3-dev
    passed
    
    
    topic « same? - :type
    
    ensure -> same? :string type "a"
    ensure -> same? :integer type 1
    ensure -> same? :floating type 1.5
    passed
    
    ensure -> not? same? :string :integer
    ensure -> not? same? :string :char
    ensure -> not? same? :integer :floating
    passed
    
    
    topic « same? - :char
    
    ensure -> same? `a` `a`
    passed
    
    ensure -> not? same? `a` "a" 
    ensure -> not? same? `a` `b`
    ensure -> not? same? `1` 1
    ensure -> not? same? "a" `a` 
    ensure -> not? same? `b` `a`
    ensure -> not? same? 1   `1`
    passed 
    
    
    topic « same? - :string
    
    ensure -> same? "Art" "Arturo" -- "uro"
    passed
    
    ensure -> not? same? "A" "B"
    ensure -> not? same? "Art" "Bob"
    passed
    
    ensure -> not? same? "a"    `a` 
    ensure -> not? same? "10"   10 
    ensure -> not? same? "10"   10
    ensure -> not? same? ["help"] [help]
    ensure -> not? same? ["a"]    [a: "a"]
    ensure -> not? same? "help"   'help
    ensure -> not? same? ["help"] [.help]
    ensure -> not? same? ["help"] ['help: "help"]
    passed
    
    
    topic « same? - :word
    
    ensure -> same? [word] [word]
    ensure -> not? same? [word] [otherWord]
    ensure -> not? same? [word] ["word"]
    ensure -> not? same? [word] [word: word]
    ensure -> not? same? [word] ['word]
    ; ensure -> not? same? [word] [.word]
    ensure -> not? same? [word] [.word: word]
    passed
    
    
    topic « same? - :label
    
    ensure -> same? [label: value] [label: value]
    passed
    
    ensure -> not? same? [label: value] [label: value2]
    ensure -> not? same? [label: value] [label2: value]
    passed
    
    ensure -> not? same? [label: value] ["label"]
    ensure -> not? same? ["label": value] ["label"]
    ensure -> not? same? [label: value] ["value"]
    ensure -> not? same? [label: "value"] ["value"]
    ensure -> not? same? [label: "value"] ["label" "value"]
    passed
    
    ensure -> not? same? [label: "value"] [label]
    ensure -> not? same? [label: "value"] [value]
    ensure -> not? same? [label: "value"] [label value]
    passed
    
    ensure -> not? same? [label: 'world] ['label]
    ensure -> not? same? [label: 'world] ['word]
    ensure -> not? same? [label: 'world] ['label 'word]
    passed
    
    ensure -> not? same? [label: .attr] [.label]
    ensure -> not? same? [label: .attr] [.attr]
    ; ensure -> not? same? [label: .attr: "a"] [.label: .attr: "a"]
    ensure -> not? same? [label: .attr: "a"] [.label: "a"]
    ensure -> not? same? [label: .attr: "a"] [.attr: "a"]
    passed
    
    
    topic « same? - :literal
    
    ensure -> same? 'literal 'literal
    ensure -> not? same? 'literal 'other
    ensure -> not? same? 'literal "literal"
    ensure -> not? same? ['literal] ["literal"]
    ensure -> not? same? ['literal] [literal]
    ensure -> not? same? ['literal] [.literal]
    ensure -> not? same? ['literal] [literal: 'literal]
    passed
    
    
    topic « same? - :attribute
    
    ensure -> same? [.attr] [.attr]
    ensure -> not? same? [.attr] ["attr"]
    ; ensure -> not? same? [.attr] [attr]
    ensure -> not? same? [.attr] [attr: .attr]
    ensure -> not? same? [.attr] ['attr]
    ensure -> not? same? [.attr] [.other]
    ensure -> not? same? [.attr] [.attr: .attr]
    passed
    
    
    topic « same? - :attributeLabel
    
    ensure -> same? [.attr: value] [.attr: value]
    passed
    
    ensure -> not? same? [.attr: value] ["attr"]
    ensure -> not? same? [.attr: value] ["value"]
    ensure -> not? same? [.attr: value] ["attr" "value"]
    passed
    
    ensure -> not? same? [.attr: value] [attr]
    ensure -> not? same? [.attr: value] [attr: .attr:]
    ; ensure -> not? same? [.attr: value] [attr: value]
    ensure -> not? same? [.attr: value] [attr: .attr: value]
    passed
    
    ensure -> not? same? [.attr: value] ['attr]
    ensure -> not? same? [.attr: value] ['value]
    ensure -> not? same? [.attr: value] ['attr 'value]
    passed
    
    ensure -> not? same? [.attr: value] [.attr]
    ensure -> not? same? [.attr: value] [.value]
    ensure -> not? same? [.attr: value] [.other: value]
    ensure -> not? same? [.attr: value] [.attr: other]
    passed
    
    
    topic « same? - :path
    
    a: #[name: "John", surname: "Doe"]
    b: @["Joe" "Jane" "Jesse"]
    
    ensure -> same? a\name "John" 
    ensure -> same? a\surname "Doe" 
    ensure -> not? same? a\name "Jane" 
    ensure -> not? same? a\name 1
    passed
    
    ensure -> same? b\0 "Joe" 
    ensure -> same? b\1 "Jane" 
    ensure -> same? b\2 "Jesse" 
    ensure -> not? same? b\2 "Walter" 
    passed
    
    ensure -> same? [b\0] [b\0]
    ensure -> same? [a\name] [a\name]
    ensure -> not? same? [b\0] [b\1]
    ensure -> not? same? [a\name] [a\surname]
    passed
    
    
    topic « same? - :pathLabel
       
    ensure -> same? [a\name: "John"] [a\name: "John"]
    ensure -> not? same? [a\surname: "Doe"] [b\surname: "Doe" ]
    ensure -> not? same? [a\name: "John"] [b\name: "Jane"]
    ensure -> not? same? [a\name: "John"] [b\name: "John"]
    passed
    
    
    topic « same? - :symbol
    
    ensure -> same? [+] [+]
    ensure -> not? same? [+] [-]
    ensure -> not? same? [+] [++]
    ensure -> not? same? [+] [`+`]
    ensure -> not? same? [+] [{+}]
    ensure -> not? same? [+] ["+"]
    ensure -> not? same? [+] [plus]
    ensure -> not? same? [+] ['+]
    passed
    
    
    topic « same? - :regex
    
    ensure -> regex? {/[A-Z]/}
    ensure -> same? {/[A-Z]/} {/[A-Z]/} 
    ensure -> not? same? {/[A-Z]/} {/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]/}
    ensure -> not? same? {/[A-Z]/} {[A-Z]}
    ensure -> not? same? {/[A-Z]/} "/[A-Z]/"
    passed
    
    
    topic « same? - :binary
    
    ensure -> same? "48 65 6C 6C 6F 20 77 6F 72 6C 64"
        ~{|to :binary "Hello world"|}
    ensure -> same? "00" ~{|to :binary 0|}
    ensure -> same? "01" ~{|to :binary 1|}
    ensure -> same? "0A" ~{|to :binary 10|}
    ensure -> same? "05" ~{|to :binary 5|}
    passed
    
    a: to :binary 0
    
    ensure -> not? same? a 0
    ensure -> not? same? "49 65 6C 6C 6F 20 77 6F 72 6C 64"
        ~{|to :binary "Hello world"|}
    passed
    
    
    topic « same? - :bytecode
    
    x: to :bytecode [["print"][1 112 155]]
    
    ensure -> same? x to :bytecode [["print"][1 112 155]]
    ensure -> not? same? x to :bytecode [["print"][2 112 155]]
    ensure -> not? same? x [["print"][2 112 155]]
    passed
    
    
    topic « same? - :inline
    
    a: [(1 + 1)], b: [(1 + 1)] 
    ensure -> same? a\0 b\0
    passed
    
    c: [(2 + 1)] 
    ensure -> not? same? a\0 c\0
    passed
    
    d: [(3 - 1)] 
    ensure -> not? same? a\0 d\0   ; even the calc (3-1) and (1+1) being 2, 
    passed                          ; they are different inlines 
                                    ; with the same result when evaluated
    
    
    e: [(1 + 2 - 1)]
    ensure -> not? same? a\0 e\0
    ensure -> not? same? a\0 2
    passed
    
    
    topic « same? - :block
    
    a: [1 + 1]
    ensure -> same? a [1 + 1]
    ensure -> not? same? a [2]
    ensure -> not? same? a 2
    ensure -> not? same? a [1 ++ 1]
    passed
    
    
    topic « same? :range
    
    ensure -> same? [0 1 2 3 4 5] @0..5
    ensure -> same? [0 2 4] @0.. .step: 2 5
    ensure -> same? @range.step: 2 0 5 @range.step: 2 0 4
    ensure -> not? same? range.step: 2 0 5 range.step: 2 0 4
    passed
    
    
    topic « same? :dictionary
    
    a: #[name: "Walter" surname: "Pinkman"]
    
    ensure -> same? a #[name: "Walter" surname: "Pinkman"]
    ensure -> not? same? a #[name: "Jesse" surname: "Pinkman"]
    ensure -> not? same? a #[name "Jesse" surname "Pinkman"]
    ensure -> not? same? a [name "Jesse" surname "Pinkman"]
    passed
    
    ensure -> same? a\name "Walter"
    ensure -> same? a\surname "Pinkman"
    ensure -> not? same? a\surname "White"
    passed
    
    
    topic « same? - :object
    
    define :person [name age][  
        init: -> this\name: capitalize this\name
        print: -> 
            render "NAME: |this\name|, AGE: |this\age|"
    ]
    
    define.as: :person :student [name age id][  
        init: -> this\name: capitalize this\name
        print: -> 
            render "NAME: |this\name|, AGE: |this\age|, ID: |this\id|"
    ]
    
    a: to :person ["Joe" 32]
    ensure -> same? a to :person ["Joe" 32]
    ensure -> not? same? to :person ["Joe" 32] #[name: "Joe" age: 32]
    ensure -> not? same? to :person ["Joe" 32] to :student ["Joe" 32 15]
    passed
    
    a\name: "Jane"
    ensure -> same? a to :person ["Jane" 32]
    passed
    
    
    topic « same? - :store
    
    a: store "test.db"
    a\name: "John" a\surname: "Doe"
    b: store "test.db"
    b\name: "John" b\surname: "Doe"
    c: store "test2.db"
    c\name: "John" c\surname: "Doe"
    d: store "test3.db"
    d\name: "Jane" d\surname: "Doe"
    
    ensure -> same? a a
    ensure -> same? a b
    ensure -> same? b a
    passed
    
    ensure -> not? same? a c 
    ensure -> not? same? c a 
    ensure -> not? same? a d 
    ensure -> not? same? d a 
    ensure -> not? same? c d 
    ensure -> not? same? d c 
    passed
    
    
    topic « same? - :color
    
    ensure -> same? #000 #black
    ensure -> same? #fff #white
    ensure -> same? #white #white
    ensure -> not? same? #black #white
    ensure -> not? same? #white #black
    passed
    
    
    topic « same? - :function
    
    ensure -> same? var 'print var 'print
    ensure -> not? same? var 'inspect var 'print
    passed
    
    a: $[name surname][]
    A: $[name][]
    b: $[name][]
    c: $[name surname][]
    
    ensure -> same? ~"|var 'a|" ~"|$[name surname][]|"
    ensure -> same? ~"|var 'a|" ~"|var 'c|"
    ensure -> not? same? ~"|var 'a|" ~"|var 'A|"
    ensure -> not? same? ~"|var 'a|" ~"|var 'b|"
    passed
    
    
    topic « same? - :database
    ; todo: test this
    
    
    topic « same? - :date
    
    a: to :date .format: "MMM dd" "Jan 15"
    b: to :date .format: "MMM dd" "Jan 15"
    c: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    d: now
    
    ensure -> same? a b 
    ensure -> not? same? a c 
    ensure -> not? same? a d
    passed 
    
    ensure -> same? a\day c\day
    ensure -> same? a\month c\month
    ensure -> not? same? a\year c\year
    passed
    
    
    topic « same? - incompatible types
    
    ; NOTES: 
    ; - to avoid repetition some tests may be not explicitly included
    ; - this test part tries to cover the most of possible behaviors,
    ;     including the possility of the Comparison module be rewritten, 
    ;     avoiding future broken changes
    ; - some combinations were not made, because it's considered very
    ;     improbable to happen, even with a future rewrite of 
    ;     the Comparison module
    
    
    ; for :integer
    ensure -> not? every? @[
        -> same? 1 1
    ] => not?
    
    ensure -> every? @[
        -> same? 1 null           -> same? 1 true
        -> same? 1 false          -> same? 1 to :complex [1 1]
        -> same? 1 1.0.0          -> same? 1 :integer
        -> same? 1 `1`            -> same? 1 "1"
        -> same? [1] [one]        -> same? [1] [one:]
        -> same? [1 1] [one: 1]   -> same? 1 '1
        -> same? [1] [.1]         -> same? [1] [.1:]
        -> same? [1 1] [.1: 1]    -> same? [1] [one\1]
        -> same? [1] [one\1:]     -> same? [1 1] [one\1: 1]
        -> same? [1] [+]          -> same? 1 {/1/}
        -> same? 1 to :binary 1   -> same? 1 to :binary 1
        -> same? [1] [(1)]        -> same? 1 [1]
        -> same? 1 1..1           -> same? 1 #[one: 1]
        -> same? 0 #black         -> same? 1 var 'one?
    ] => not? passed
    
    ; for :floating
    ensure -> every? @[
        -> same? 1.0 null              -> same? 1.0 true
        -> same? 1.0 false             -> same? 1.0 to :complex [1.0 1.0]
        -> same? 1.0 1.0.0             -> same? 1.0 :floating
        -> same? 1.0 `1`               -> same? 1.0 "1.0"
        -> same? [1.0] [one]           -> same? [1.0] [one: 1.0]
        -> same? [1.0 1.0] [one: 1.0]  -> same? 1.0 '1
        -> same? [1.0] [.1]            -> same? [1.0] [.1:]
        -> same? [1.0 1.0] [.1: 1.0]   -> same? [1.0] [one\1]
        -> same? [1.0] [one\1:]        -> same? [1.0 1.0] [one\1: 1.0]
        -> same? [1.0] [+]             -> same? 1.0 {/1.0/}
        -> same? 1.0 to :binary 1.0    -> same? 1.0 to :binary 1.0
        -> same? [1.0] [(1.0)]         -> same? 1.0 [1]
        -> same? 1.0 1..1              -> same? 1.0 #[one: 1.0]
        -> same? 0.0 #black            -> same? 1.0 var 'one?
    ] => not? passed
    
    ; for :rational
    a: to :rational [1 1]
    ensure -> every? @[
        -> same? a null                    -> same? a true
        -> same? a false                   -> same? a to :complex [1 1]
        -> same? a 1.0.0                   -> same? a :rational
        -> same? a `1`                     -> same? a "1/1"
        -> same? @[a] [one]                -> same? @[a] [one:]
        -> same? @[a a] [one: 1]           -> same? 1 '1
        -> same? @[a] [.1]                 -> same? @[a] [.1:]
        -> same? @[a a] [.1: 1]            -> same? @[a] [one\1]
        -> same? @[a] [one\1: 1]           -> same? @[a a] [one\1: 1]
        -> same? @[a] [+]                  -> same? a {/1/1/}
        -> same? a to :binary 1            -> same? a to :binary 1
        -> same? @[a] [(1)]                -> same? a [1]
        -> same? a 1..1                    -> same? a #[one: 1]
        -> same? to :rational [1 1] #black -> same? a var 'one?
    ] => not? passed
    
    ; for :quantity
    ensure -> every? @[
        -> same? 1:usd null                    -> same? 1:usd true
        -> same? 1:usd false                   -> same? 1:usd to :complex [1 1]
        -> same? 1:usd 1.0.0                   -> same? 1:usd :quantity
        -> same? 1:usd `1`                     -> same? 1:usd "1USD"
        -> same? [1:usd] [one]                 -> same? [1:usd] [one:]
        -> same? [1:usd 1:usd] [one: 1:usd]    -> same? 1:usd '1
        -> same? [1:usd] [.1]                  -> same? [1:usd] [.1:]
        -> same? [1:usd 1:usd] [.1: 1:usd]     -> same? [1:usd] [one\1]
        -> same? [1:usd] [one\1:]              -> same? [1:usd 1:usd] [one\1: 1:usd]
        -> same? [1:usd] [+]                   -> same? 1:usd {/1USD/}
        -> same? 1:usd to :binary 1            -> same? 1:usd to :binary 1
        -> same? [1:usd] [(1)]                 -> same? 1:usd [1:usd]
        -> same? 1:usd 1..1                    -> same? 1:usd #[one: 1:usd]
        -> same? 0:usd #black                  -> same? 1:usd var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> same? 1:m null              -> same? 1:m true
        -> same? 1:m false             -> same? 1:m to :complex [1 1]
        -> same? 1:m 1.0.0             -> same? 1:m :quantity
        -> same? 1:m `1`               -> same? 1:m "1m"
        -> same? [1:m] [one]           -> same? [1:m] [one:]
        -> same? [1:m 1:m] [one: 1:m]  -> same? 1:m '1
        -> same? [1:m] [.1]            -> same? [1:m] [.1: 1:m]
        -> same? [1:m 1:m] [.1: 1:m]   -> same? [1:m] [one\1]
        -> same? [1:m] [one\1:]        -> same? [1:m 1:m] [one\1: 1:m]
        -> same? [1:m] [+]             -> same? 1:m {/1m/}
        -> same? 1:m to :binary 1      -> same? 1:m to :binary 1
        -> same? [1:m] [(1)]           -> same? 1:m [1:m]
        -> same? 1:m 1..1              -> same? 1:m #[one: 1:m]
        -> same? 0:m #black            -> same? 1:m var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> same? 1:m3 null                 -> same? 1:m3 true
        -> same? 1:m3 false                -> same? 1:m3 to :complex [1 1]
        -> same? 1:m3 1.0.0                -> same? 1:m3 :quantity
        -> same? 1:m3 `1`                  -> same? 1:m3 "1m³"
        -> same? [1:m3] [one]              -> same? [1:m3] [one:]
        -> same? [1:m3 1:m3] [one: 1:m3]   -> same? 1:m3 '1
        -> same? [1:m3] [.1]               -> same? [1:m3] [.1:]
        -> same? [1:m3 1:m3] [.1: 1:m3]    -> same? [1:m3] [one\1]
        -> same? [1:m3] [one\1:]           -> same? [1:m3 1:m3] [one\1: 1:m3]
        -> same? [1:m3] [+]                -> same? 1:m3 {/1m³/}
        -> same? 1:m3 to :binary 1         -> same? 1:m3 to :binary 1
        -> same? [1:m3] [(1)]              -> same? 1:m3 [1:m3]
        -> same? 1:m3 1..1                 -> same? 1:m3 #[one: 1:m3]
        -> same? 0:m3 #black               -> same? 1:m3 var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> same? 1:c null              -> same? 1:c true
        -> same? 1:c false             -> same? 1:c to :complex [1 1]
        -> same? 1:c 1.0.0             -> same? 1:c :quantity
        -> same? 1:c `1`               -> same? 1:c "1°C"
        -> same? [1:c] [one]           -> same? [1:c] [one:]
        -> same? [1:c 1:c] [one: 1:c]  -> same? 1:c '1
        -> same? [1:c] [.1]            -> same? [1:c] [.1:]
        -> same? [1:c 1:c] [.1: 1:c]   -> same? [1:c] [one\1]
        -> same? [1:c] [one\1:]        -> same? [1:c 1:c] [one\1: 1:c]
        -> same? [1:c] [+]             -> same? 1:c {/1°C/}
        -> same? 1:c to :binary 1      -> same? 1:c to :binary 1
        -> same? [1:c] [(1)]           -> same? 1:c [1:c]
        -> same? 1:c 1..1              -> same? 1:c #[one: 1:c]
        -> same? 0:c #black            -> same? 1:c var 'one?
    ] => not? passed
    
    ; for :null
    ensure -> every? @[
        -> same? null 0                        -> same? null 0.0            
        -> same? null to :rational [1 1]       -> same? null true
        -> same? null false                    -> same? null to :complex [0 0]
        -> same? null 0.0.0                    -> same? null :null
        -> same? null `ø`                      -> same? null "null"
        -> same? @[null] [null]                -> same? @[null] [null:]
        -> same? @[null null] [null: null]     -> same? null 'null
        -> same? @[null] [.null]               -> same? @[null] [.null:]
        -> same? @[null null] [.null: null]    -> same? @[null] [null\null]
        -> same? @[null] [null\null:]          -> same? @[null null] [null\null: null]
        -> same? @[null] [ø]                   -> same? null {/null/}
        -> same? null {/ø/}                    -> same? null to :binary 0   
        -> same? null to :binary 0             -> same? @[null] [(null)]         
        -> same? null [null]                   -> same? null 0..0            
        -> same? null #[null: null]            -> same? null #black          
        -> same? null var 'null?
    ] => not? passed
    
    ; for :logical
    ensure -> every? @[
        -> same? true 0                        -> same? true 0.0            
        -> same? true to :rational [1 1]       -> same? true to :complex [0 0]
        -> same? true 0.0.0                    -> same? true :true
        -> same? true `0`                      -> same? true "true"
        -> same? @[true] [true]                -> same? @[true] [true: true]
        -> same? @[true true] [true: true]     -> same? true 'true
        -> same? @[true] [.true]               -> same? @[true] [.true:]
        -> same? @[true true] [.true: true]    -> same? @[true] [true\true]
        -> same? @[true] [true\true:]          -> same? @[true true] [true\true: true]
        -> same? @[true] [ø]                   -> same? true {/true/}
        -> same? true to :binary 0             -> same? true to :binary 0             
        -> same? @[true] [(true)]              -> same? true [true]                   
        -> same? true 0..0                     -> same? true #[true: true]            
        -> same? true #black                   -> same? true var 'true?
    ] => not? passed
    
    ensure -> every? @[
        -> same? false 0                           -> same? false 0.0            
        -> same? false to :rational [1 1]          -> same? false to :complex [0 0]
        -> same? false 0.0.0                       -> same? false :false
        -> same? false `0`                         -> same? false "false"
        -> same? @[false] [false]                  -> same? @[false] [false:]
        -> same? @[false false] [false: false]     -> same? false 'false
        -> same? @[false] [.false]                 -> same? @[false] [.false:]
        -> same? @[false false] [.false: false]    -> same? @[false] [false\false]
        -> same? @[false] [false\false:]           -> same? @[false false] [false\false: false]
        -> same? @[false] [ø]                      -> same? false {/false/}
        -> same? false to :binary 0                -> same? false to :binary 0                
        -> same? @[false] [(false)]                -> same? false [false]                     
        -> same? false 0..0                        -> same? false #[false: false]             
        -> same? false #black                      -> same? false var 'false?
    ] => not? passed
    
    ensure -> every? @[
        -> same? maybe 0                           -> same? maybe 0.0            
        -> same? maybe to :rational [1 1]          -> same? maybe to :complex [0 0]
        -> same? maybe 0.0.0                       -> same? maybe :maybe
        -> same? maybe `0`                         -> same? maybe "maybe"
        -> same? @[maybe] [maybe]                  -> same? @[maybe] [maybe:]
        -> same? @[maybe maybe] [maybe: maybe]     -> same? maybe 'maybe
        -> same? @[maybe] [.maybe]                 -> same? @[maybe] [.maybe:]
        -> same? @[maybe maybe] [.maybe: maybe]    -> same? @[maybe] [maybe\maybe]
        -> same? @[maybe] [maybe\maybe:]           -> same? @[maybe maybe] [maybe\maybe: maybe]
        -> same? @[maybe] [ø]                      -> same? maybe {/maybe/}
        -> same? maybe to :binary 0                -> same? maybe to :binary 0
        -> same? @[maybe] [(maybe)]                -> same? maybe [maybe]
        -> same? maybe 0..0                        -> same? maybe #[maybe: maybe]             
        -> same? maybe #black                      
    ] => not? passed
    
    ; for :complex
    a: to :complex [1 1]
    ensure -> every? @[
        -> same? a 1                       -> same? a 1.0            
        -> same? a to :rational [1 1]      -> same? a null                    
        -> same? a true                    -> same? a false
        -> same? a 1.0.0                   -> same? a :rational
        -> same? a `1`                     -> same? a "1.0+1.0i"
        -> same? @[a] [one]                -> same? @[a] [one:]
        -> same? @[a a] [one: 1]           -> same? 1 '1
        -> same? @[a] [.1]                 -> same? @[a] [.1:]
        -> same? @[a a] [.1: 1]            -> same? @[a] [one\1]
        -> same? @[a] [one\1:]             -> same? @[a a] [one\1: 1]
        -> same? @[a] [+]                  -> same? a {/1.0+1.0i/}
        -> same? a to :binary 1            -> same? a to :binary 1
        -> same? @[a] [(1)]                -> same? a [1]
        -> same? a 1..1                    -> same? a #[one: 1]
        -> same? to :complex [0 0] #black  -> same? a var 'one?
    ] => not? passed
    
    ; for :version
    ensure -> every? @[
        -> same? 1.0.0 1                       -> same? 1.0.0 1.0          
        -> same? 1.0.0 to :rational [1 1]      -> same? 1.0.0 null                    
        -> same? 1.0.0 true                    -> same? 1.0.0 false                   
        -> same? 1.0.0 to :complex [1.0 1.0]   -> same? 1.0.0 :floating
        -> same? 1.0.0 `1`                     -> same? 1.0.0 "1.0.0"
        -> same? [1.0.0] [one]                 -> same? [1.0.0] [one:]
        -> same? [1.0.0 1.0.0] [one: 1.0.0]    -> same? 1.0.0 '1
        -> same? [1.0.0] [.1]                  -> same? [1.0.0] [.1:]
        -> same? [1.0.0 1.0.0] [.1: 1.0.0]     -> same? [1.0.0] [one\1]
        -> same? [1.0.0] [one\1:]              -> same? [1.0.0 1.0.0] [one\1: 1.0.0]
        -> same? [1.0.0] [+]                   -> same? 1.0.0 {/1.0.0/}
        -> same? 1.0.0 to :binary 1.0          -> same? 1.0.0 to :binary 1.0
        -> same? [1.0.0] [(1.0.0)]             -> same? 1.0.0 [1.0.0]
        -> same? 1.0.0 1..1                    -> same? 1.0.0 #[one: 1.0.0]
        -> same? 0.0.0 #black                  -> same? 1.0.0 var 'version?
    ] => not? passed
    
    ; for :type
    ensure -> every? @[
        -> same? :1 1                              -> same? :1 1.0          
        -> same? :integer 1                        -> same? :floating 1.0          
        -> same? :rational to :rational [1 1]      -> same? :null null                    
        -> same? :true true                        -> same? :false false                   
        -> same? :logical false                    -> same? :complex to :complex [1 1]   
        -> same? :version 1.0.0                    -> same? :T `T`                         
        -> same? :char `T`                         -> same? :string ":type"
        -> same? [:type] [type]                    -> same? [:word] [word]                     
        -> same? [:type] [type:]                   -> same? [:label] [label:]
        -> same? [:type :type] [type: :type]       -> same? :1 '1
        -> same? :literal '1                       -> same? [:type] [.type]                      
        -> same? [:attribute] [.type]              -> same? [:type] [.type:]
        -> same? [:attributeLabel] [.type:]        -> same? [:type :type] [.type: :type]         
        -> same? [:type] [type\type]               -> same? [:path] [type\type]
        -> same? [:type] [type\type:]              -> same? [:pathLabel] [type\type:]            
        -> same? [:type :type] [type\type: :type]  -> same? [:type] [+]                       
        -> same? [:symbol] [+]                     -> same? :type {/:type/}
        -> same? :regex {/:type/}                  -> same? :type to :binary 1.0              
        -> same? :binary to :binary 1.0            -> same? [:type] [(:type)]                 
        -> same? [:inline] [(:type)]               -> same? :type [:type]
        -> same? :block [:type]                    -> same? :type 1..1                        
        -> same? :range 1..1                       -> same? :type #[type: :type]
        -> same? :dictionary #[type: :type]        -> same? :type #black                      
        -> same? :color #black                     -> same? :type var 'type?
        -> same? :function var 'one?
    ] => not? passed
    
    ; for :char
    ensure -> every? @[
        -> same? `1` 1.0          
        -> same? `1` to :rational [1 1]    -> same? `ø` null                    
        -> same? `t` true                  -> same? `f` false                   
        -> same? `1` to :complex [1.0 1.0] -> same? `T` :floating
        -> same? [`a`] [one]               -> same? [`a`] [a: `a`]
        -> same? [`a` `a`] [a: `a`]        -> same? `a` 'a
        -> same? [`a`] [.1]                -> same? [`a`] [.a:]
        -> same? [`a` `a`] [.a: `a`]       -> same? [`a`] [a\a]
        -> same? [`a`] [a\a:]              -> same? [`a` `a`] [a\a: `a`]
        -> same? [`+`] [+]                 -> same? `a` {/a/}
        -> same? `1` to :binary 1          -> same? `a` to :binary 1
        -> same? [`1`] [(`1`)]             -> same? `a` [`a`]
        -> same? `1` 1..1                  -> same? `a` #[a: `a`]
        -> same? `1` #black                -> same? `a` var 'char?
    ] => not? passed
    
    ; for :string
    ensure -> every? @[
        -> same? "1" 1                             -> same? "1/1" to :rational [1 1]          
        -> same? "1.0" 1.0                         -> same? "null" null                    
        -> same? "" null                           -> same? "true" true                  
        -> same? "" false                          -> same? "false" false                   
        -> same? "1.0+1.0i" to :complex [1.0 1.0]  -> same? "type" :floating
        -> same? "floating" :floating              -> same? ":floating" :floating
        -> same? "1.0" :floating                   -> same? ["a"] [a\a]
        -> same? ["a"] [a\a:]                      -> same? ["a" "a"] [a\a: "a"]
        -> same? ["+"] [+]                         -> same? "a" {/a/}
        -> same? "01" to :binary 1                 -> same? "1" to :binary 1
        -> same? [""] [("")]                       -> same? "" [""]
        -> same? "1" 1..1                          -> same? "a" #[a: "a"]
        -> same? "#000000" #black                  -> same? "000000" #black              
        -> same? "" var 'char?
    ] => not? passed
    
    ; for :word
    ensure -> every? @[        
        -> same? [rational] @[to :rational [1 1]]      -> same? [null]  @[null]                    
        -> same? [true]     @[true]                    -> same? [false] @[false]                   
        -> same? [complex]  @[to :complex [1.0 1.0]]   -> same? [type]  @[:floating]  
        -> same? [floating] @[:floating]               -> same? [a]      [a\a]                   
        -> same? [a]         [a\a:]                    -> same? [a]     @[{/a/}]                      
        -> same? [binary]   @[to :binary 1]            -> same? [one]   @[to :binary 1]              
        -> same? [word]      [(word)]                  -> same? [word]  @[[word]]                      
        -> same? [range]    @[range 1 1]               -> same? [a]     @[#[a: `a`]]               
        -> same? [black]    @[#black ]                 -> same? [word]  @[var 'word?]              
        -> same? [var]      @[var 'word?]
    ] => not? passed
    
    ; for :label
    ensure -> every? @[
        -> same? [rational:] @[to :rational [1 1]]     -> same? [null:]     @[null]                                                        
        -> same? [true:]     @[true]                   -> same? [false:]    @[false]                   
        -> same? [complex:]  @[to :complex [1.0 1.0]]  -> same? [floating:] @[:floating]
        -> same? [type:]     @[:floating]              -> same? [a:]         [a\a]                     
        -> same? [a:]         [a\a:]                   -> same? [a:]        @[{/a:/}]                 
        -> same? [binary:]   @[to :binary 1]           -> same? [word:]      [(word:)]                
        -> same? [label:]    @[[label:]]               -> same? [a:]        @[#[a: `a`]]               
        -> same? [black:]    @[#black ]                -> same? [var:]      @[var 'word?]
        -> same? [word:]     @[var 'word?]
    ] => not? passed
    
    ; for :literal
    ; NOTE: technically, '+ is not a :literal, but a :symbolLiteral type ;)
    ensure -> every? @[
        -> same? 'integer  1                   -> same? 'floating 1.0
        -> same? 'rational to :rational [1 1]  -> same? 'one      to :rational [1 1]
        -> same? 'null     null                -> same? 'true     true    
        -> same? 'false    false               -> same? 'complex  to :complex [1.0 1.0]    
        -> same? 'type     :floating           -> same? 'floating :floating               
        -> same? ['a]        [a\a]             -> same? ['+]      [+]                       
        -> same? 'a        {/a/}               -> same? 'binary   to :binary 1            
        -> same? ['word]   [('word)]           -> same? 'word     ['word]                                     
        -> same? 'range    1..1                -> same? 'a        #[a: 'a]                
        -> same? 'black    #black              -> same? 'word?    var 'word?              
        -> same? 'var      var 'var
    ] => not? passed
    
    ; for :attribute
    ensure -> every? @[           
        -> same? [.rational] @[to :rational [1 1]]    -> same? [.null]     @[null]                  
        -> same? [.true]     @[true]                  -> same? [.false]    @[false]                 
        -> same? [.complex]  @[to :complex [1.0 1.0]] -> same? [.floating] @[:floating]                          
        -> same? [.a]        @[{/a:/}]                -> same? [.binary]   @[to :binary 1]          
        -> same? [.word]      [(.word:)]              -> same? [.label]    @[[.label]]                               
        -> same? [.a]        @[#[a: `a`]]             -> same? [.black]    @[#black]                
        -> same? [.var]      @[var 'word?]            -> same? [.word]     @[var 'word?]
    ] => not? passed
    
    ; for :attributeLabel
    ensure -> every? @[           
        -> same? [.rational:] @[to :rational [1 1]]    -> same? [.null:]     @[null]                  
        -> same? [.true:]     @[true]                  -> same? [.false:]    @[false]                 
        -> same? [.complex:]  @[to :complex [1.0 1.0]] -> same? [.floating:] @[:floating]             
        -> same? [.a:]         [a\a]                   -> same? [.a: `a`]     [a\a: `a`]              
        -> same? [.plus:]      [+]                     -> same? [.a:]        @[{/a:/}]                
        -> same? [.binary:]   @[to :binary 1]          -> same? [.word:]      [(.word:)]               
        -> same? [.label:]    @[[label:]]              -> same? [.a:]        @[#[a: `a`]]             
        -> same? [.black:]    @[#black]                -> same? [.var:]      @[var 'word?]            
        -> same? [.word:]     @[var 'word?]
    ] => not? passed
    
    ; for :path & :pathLabel
    ensure -> every? @[
        -> same? [a\b:] [a\b]
        -> same? [a\b] [a\b:]
    ] => not? passed

    ; for :regex
    ensure -> every? @[
        -> same? {/1/} 1                               -> same? {/1/1/} to :rational [1 1]          
        -> same? {/1.0/} 1.0                           -> same? {/null/} null                    
        -> same? {//} null                             -> same? {/true/} true                  
        -> same? {//} false                            -> same? {/false/} false                   
        -> same? {/1.0+1.0i/} to :complex [1.0 1.0]    -> same? {/type/} :floating
        -> same? {/floating/} :floating                -> same? {/:floating/} :floating
        -> same? {/1.0/} :floating                     -> same? [{/a/}] [a\a]
        -> same? [{/a/}] [a\a:]                        -> same? [{/a/} {/a/}] [a\a: {/a/}]
        -> same? [{/\+/}] [+]                          -> same? {/01/} to :binary 1                 
        -> same? {/1/} to :binary 1                    -> same? [{//}] [({//})]                     
        -> same? {//} [""]                             -> same? {/1/} 1..1                          
        -> same? {/a/} #[a: "a"]                       -> same? {/#000000/} #black                  
        -> same? {/000000/} #black                     -> same? {/var/} var 'regex?
        -> same? {/regex?/} var 'regex?
    ] => not? passed
    
    ; for :binary
    ensure -> every? @[
        -> same? to :binary 1 1                    -> same? to :binary 1 1.0                
        -> same? to :binary 1 to :rational [1 1]   -> same? to :binary 1 1:usd                
        -> same? to :binary 1 1:m                  -> same? to :binary 1 1:m3                 
        -> same? to :binary 1 1:c                  -> same? to :binary 0 null                 
        -> same? to :binary 0 true                 -> same? to :binary 0 false                
        -> same? to :binary 0 maybe                -> same? to :binary 1 to :complex [1 1]                  
        -> same? to :binary 1 1.0.0                -> same? to :binary 1 :type              
        -> same? to :binary 1 :binary              -> same? to :binary 1 `1`                  
        -> same? to :binary "a" `a`                -> same? to :binary 1 "01"                 
        -> same? to :binary 1 "1"                  -> same? @[to :binary 1] [binary]          
        -> same? @[to :binary 1] [one]             -> same? @[to :binary 1] [binary:]         
        -> same? @[to :binary 1][.binary]          -> same? @[to :binary 1] [.binary:]        
        -> same? to :binary 1 {/01/}               -> same? to :binary 1    {/1/}
    ] => not? passed
    
    ; for :range
    ensure -> every? @[
        -> same? 1..1 1                        -> same? 1..1 1.0
        -> same? 1..1 a: to :rational [1 1]    -> same? 1..1 1:usd
        -> same? 1..1 1:m                      -> same? 1..1 1:m3  
        -> same? 1..1 1:c                      -> same? 0..0 null 
        -> same? 0..0 true                     -> same? 0..0 false
        -> same? 0..0 maybe                    -> same? 1..1 to :complex [1 1]
        -> same? 1..1 1.0.0                    -> same? 1..1 :type                        
        -> same? 1..1 :range                   -> same? 1..1 `1` 
        -> same? 1..1 "1"                      -> same? 1..1 'range  
        -> same? 1..1 {/1/}
    ] => not? passed
    
    ; for :dictionary, :object & :date
    define :person [name surname][]
    
    a: to :person ["Walter" "Pinkman"]
    b: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    
    ensure -> every? @[
        -> same? #[name: "Walter" surname: "Pinkman"] a
        -> same? a #[name: "Walter" surname: "Pinkman"]
        -> same? #[year: 2023 day: 15 Month: "January"] b
        -> same? b #[year: 2023 day: 15 Month: "January"]
    ] => not? passed
    
    ; for :color
    ensure -> every? @[
        -> same? #black 0                  -> same? #black 0.0
        -> same? #black to :rational [1 1] -> same? #black 0:usd 
        -> same? #black 0:m                -> same? #black 0:m3
        -> same? #black 0:c                -> same? #black null 
        -> same? #black true               -> same? #black false 
        -> same? #black maybe              -> same? #black to :complex [0 0]
        -> same? #black 0.0.0              -> same? #black :color
        -> same? #black `1`                -> same? #black "#000000"
        -> same? #black "000000"           -> same? [#black] [black] 
        -> same? #black 'black             -> same? [#black] [.black]
        -> same? [#black] [.black:]        -> same? #black  {/#000000/}                 
        -> same? #black{/000000/} 
    ] => not? passed
    
    ; for :function
    ensure -> every? @[
        -> same? var 'null?     null       -> same? var 'true?    true  
        -> same? var 'false?    false 
        -> same? var 'version?  1.0.0      -> same? var 'type?    :type 
        -> same? var 'function? :function  -> same? var 'char?    `a` 
        -> same? @[var 'word?]  [word]     -> same? @[var 'word?] [var]      
        -> same? @[var 'word?]  [var:]     -> same? @[var 'word?] [word:]    
        -> same? var 'word?     'word?     -> same? var 'var      'var       
        -> same? @[var 'word?]  [.var]     -> same? @[var 'word?] [.word]    
        -> same? @[var 'word?]  [.var:]    -> same? @[var 'word?] [.word:]   
        -> same? var 'regex?    {/var/}    -> same? var 'regex?   {/regex?/} 
    ] => not? passed
    
    
]

; integer comparisons

print less? 1 1
print 1<1
print less? 1 2
print 1<2

print lessOrEqual? 1 1
print 1=<1
print lessOrEqual? 1 2
print 1=<2

print greater? 1 1
print 1>1
print greater? 2 1
print 2>1

print greaterOrEqual? 1 1
print 1>=1
print greaterOrEqual? 2 1
print 2>=1

; floating comparisons

print 3.0>2
print 1.123 < 1.023

; floating-integer comparisons

print 3.0>2
print 2<3.14

; other types

print "hello">"iceland"
print "hello"<"iceland"

print [1 2 3 4]>[1 2 3]

a: to :date .format: "YYYY" "2002"
b: to :date .format: "YYYY" "2001"
print a > b
print a < b

a: to :date .format: "MMM dd" "Jan 15"
b: to :date .format: "MMM dd" "Jan 14"
print a > b
print a < b

a: to :date .format: "HH:mm" "13:25"
b: to :date .format: "HH:mm" "12:12"
print a > b
print a < b
