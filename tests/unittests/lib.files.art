;; Library: Files -- https://arturo-lang.io/documentation/library/files/
;;
;; This file tests Arturo's Files Library
;; for obvious reasons, bash is used as helper to this,
;; doing functions independents of each other.


topic: $[topic :string] [
    print ""
    print ~">> |topic|"
    print ""
]

execute "mkdir temp"
print "Created: temp/"

; ---------------------------- Functions ----------------------------

; -- Test: copy

topic "copy"
do [

    ; preparing
    execute "mkdir temp/toCopy"
    ; Using write because I can't redirect using `execute` function
    write "temp/toCopy/file.txt" "Hello, world!"

    ; action
    copy "temp/toCopy/file.txt" "temp/copied.txt"

    ; assertion
    print execute "cat temp/copied.txt"

    ; cleaning
    execute "rm temp/* --recursive"

]


topic "copy.directory - with empty folders"
do [

    ; preparing
    execute "mkdir temp/toCopy"
    execute "mkdir temp/toCopy/folder{A,B,C}"
    execute "mkdir temp/toCopy/folder{A,B,C}/{A,B,C}"
    execute "mkdir temp/dest"

    ; action
    copy.directory "temp/toCopy/" "temp/dest"

    ; assertion
    print execute "ls temp/dest/**"

    ; cleaning
    execute "rm temp/* --recursive"

]

topic "copy.directory - with mixed folders"
do [

    ; preparing

    execute "mkdir temp/toCopy"
    execute "mkdir temp/toCopy/folder{A,B,C}"
    execute "mkdir temp/toCopy/folder{A,B,C}/{A,B,C}"

    write "temp/toCopy/folderA/A/file.txt" "Hello, world!"
    write "temp/toCopy/folderB/B/file.txt" "Hello, world!"
    write "temp/toCopy/folderC/C/file.txt" "Hello, world!"
    write "temp/toCopy/folderA/file.txt" "Hello, world!"
    write "temp/toCopy/file.txt" "Hello, world!"

    execute "mkdir temp/dest"

    ; action
    copy.directory "temp/toCopy/" "temp/dest"

    ; assertion
    print execute "ls temp/dest/** --recursive"

    ; cleaning
    execute "rm temp/* --recursive"

]


; -- Test: delete

topic "delete"
do [

    ; preparing
    ; Using write because I can't redirect using `execute` function
    write "temp/file.txt" "Hello, world!"

    ; 1st assertion
    print execute "cat temp/file.txt"

    ; action
    print "deleting..."
    delete "temp/file.txt"

    ; 2nd assertion
    print execute "cat temp/file.txt"

    ; cleaning
    execute "rm temp/* --recursive"

]

topic "delete.directory - with empty folders"
do [

    ; preparing
    execute "mkdir temp/folder{A,B,C}"
    execute "mkdir temp/folder{A,B,C}/{A,B,C}"

    ; assertion
    print execute "ls temp/**"

    ; action
    print "Deleting..."
    delete.directory "temp/folderA"
    delete.directory "temp/folderB"
    delete.directory "temp/folderC"

    ; assertion
    print ["now:" execute "ls temp"]

    ; cleaning
    execute "rm temp/* --recursive"

]

topic "delete.directory - with mixed folders"
do [

    ; preparing

    execute "mkdir temp/folder{A,B,C}"
    execute "mkdir temp/folder{A,B,C}/{A,B,C}"

    ; Using write because I can't redirect using `execute` function
    write "temp/folderA/A/file.txt" "Hello, world!"
    write "temp/folderB/B/file.txt" "Hello, world!"
    write "temp/folderC/C/file.txt" "Hello, world!"
    write "temp/folderA/file.txt" "Hello, world!"
    write "temp/file.txt" "Hello, world!"

    ; 1st assertion
    print execute "ls temp/**"

    ; action
    print "Deleting..."

    delete.directory "temp/folderA"
    delete.directory "temp/folderB"
    delete.directory "temp/folderC"
    delete "file.txt"

    ; 2nd assertion
    print execute "ls temp/**"

    ; cleaning
    execute "rm temp/* --recursive"

]

; -- Test: move

topic "move"
do [

    ; preparing
    execute "mkdir temp/toMove"
    ; Using write because I can't redirect using `execute` function
    write "temp/toMove/file.txt" "Hello, world!"

    ; action
    move "temp/toMove/file.txt" "temp/moved.txt"

    ; assertion
    print execute "cat temp/moved.txt"
    print execute "cat temp/toMove/moved.txt"

    ; cleaning
    execute "rm temp/* --recursive"

]



topic "move.directory - with empty folders"
do [

    ; preparing
    execute "mkdir temp/toMove"
    execute "mkdir temp/toMove/folder{A,B,C}"
    execute "mkdir temp/toMove/folder{A,B,C}/{A,B,C}"
    execute "mkdir temp/dest"

    ; action
    move.directory "temp/toMove/" "temp/dest"

    ; assertion
    print execute "ls temp/dest/**"
    print execute "ls temp/toMove/**"

    ; cleaning
    execute "rm temp/* --recursive"

]

topic "move.directory - with mixed folders"
do [

    ; preparing

    execute "mkdir temp/toMove"
    execute "mkdir temp/toMove/folder{A,B,C}"
    execute "mkdir temp/toMove/folder{A,B,C}/{A,B,C}"

    write "temp/toMove/folderA/A/file.txt" "Hello, world!"
    write "temp/toMove/folderB/B/file.txt" "Hello, world!"
    write "temp/toMove/folderC/C/file.txt" "Hello, world!"
    write "temp/toMove/folderA/file.txt" "Hello, world!"
    write "temp/toMove/file.txt" "Hello, world!"

    execute "mkdir temp/dest"

    ; action
    move.directory "temp/toMove/" "temp/dest"

    ; assertion
    print execute "ls temp/dest/** --recursive"

    ; cleaning
    execute "rm temp/* --recursive"

]


; -- Test: permissions

topic "permissions"
do [

    ; preparing
    ; Using write because I can't redirect using `execute` function
    write "temp/file.txt" "Hello, world!"

    ; action & assertion
    inspect permissions "temp/file.txt"

    ; cleaning
    execute "rm temp/* --recursive"

]


;; Returns me a `SIGSEGV: Illegal storage access. (Attempt to read from nil?)`
; topic "permissions.set"
; do [
;
;     ; preparing
;     ; Using write because I can't redirect using `execute` function
;     write "temp/file.txt" "Hello, world!"
;
;     ; action
;     permissions.set: #[others:#[write:false]] "temp/file.txt"
;
;     ; assertion
;     inspect permissions "temp/file.txt"
;
;     ; cleaning
;     execute "rm temp/* --recursive"
;
; ]

; -- Test: read

topic "read"
do [

    ; preparing
    write "temp/test.txt" {
        Hello, world
        This is a multiline File.
        :)
    }

    ; action & assertion
    a: read "temp/test.txt"
    inspect a
    print a

    ; cleaning
    execute "rm temp/* --recursive"

]


;; What is the difference between `read` and `read.lines`?
topic "read.lines"
do [

    ; preparing
    write "temp/test.txt" {
        Hello, world
        This is a multiline File.
        :)
    }

    ; action & assertion
    a: read "temp/test.txt"
    inspect a
    print a

    ; cleaning
    execute "rm temp/* --recursive"

]

topic "read.json"
do [

    ; preparing
    write "temp/test.json" {
        {
            "name": "Arturo",
            "version": "0.9.83",
            "build": "b/12",
            "platform": "amd/win10"
        }
    }

    ; action & assertion
    a: read.json "temp/test.json"
    inspect a

    ; cleaning
    execute "rm temp/* --recursive"

]

topic "read.csv"
do [

    ; preparing
    write "temp/test.csv" {
        language; version; platform
        Arturo; 0.9.83; win10
        Python; 3.9; gnu/linux
        Ruby; 3.2.1; macOS
    }

    ; action & assertion
    a: read.csv "temp/test.csv"
    inspect a

    ; cleaning
    execute "rm temp/* --recursive"

]

topic "read.csv.withHeaders"
do [

    ; preparing
    write "temp/test.csv" {
        language; version; platform
        Arturo; 0.9.83; win10
        Python; 3.9; gnu/linux
        Ruby; 3.2.1; macOS
    }

    ; action & assertion
    a: read.csv.withHeaders "temp/test.csv"
    inspect a

    ; cleaning
    execute "rm temp/* --recursive"

]

topic "read.html"
do [

    ; preparing
    write "temp/test.html" {
        <!DOCTYPE html>
        <html>
        <body>
            <h2>Unordered List with Square Bullets</h2>
            <ul style="list-style-type:square;">
                <li>Arturo</li>
                <li>Python</li>
                <li>Ruby</li>
            </ul>
            <p>
                Hello
                <br>
                World
            </p>
        </body>
        </html>
    }

    ; action & assertion
    a: read.html "temp/test.html"
    print a

    ; cleaning
    execute "rm temp/* --recursive"

]

topic "read.xml"
do [

    ; preparing
    write "temp/test.xml" {
        <?xml version="1.0"?>
        <languages>
        <language id="art">
            <name>Arturo Programming Language</name>
            <author>Yanis Zafiropulos</author>
            <category>Scripting and Concatenative</category>
        </language>
        <language id="py">
            <name>CPython</name>
            <author>Guido van Rossum</author>
            <category>Scripting and Object Oriented</category>
        </language>
        <language id="rb">
            <name>Ruby</name>
            <author>Yukihiro Matsumoto</author>
            <category>Scripting and Object Oriented</category>
        </language>
        </languages>
    }

    ; action & assertion
    a: read.xml "temp/test.xml"
    inspect a

    ; cleaning
    execute "rm temp/* --recursive"

]

topic "read.markdown"
do [

    ; preparing
    write "temp/test.markdown" {
        # Arturo Basics

        > Arturo is a very simple language.
        > Even without any prior experience,
        > I estimate it would take you roughly half an hour
        > before you are comfortable enough to write your first program.

        ---

        - [Library](https://arturo-lang.io/documentation/library)
        - [Examples](https://arturo-lang.io/documentation/examples)

        ## First Steps
        1. [Main Components](https://arturo-lang.io/documentation/language/#the-main-components)
        2. [Precedence & Evaluation](https://arturo-lang.io/documentation/language/#precedence-and-evaluation)
        3. [Scope & Rules](https://arturo-lang.io/documentation/language/#scope-and-rules)

    }

    ; action & assertion
    a: read.markdown "temp/test.markdown"
    inspect a

    ; cleaning
    execute "rm temp/* --recursive"

]

topic "read.toml"
do [

    ; preparing
    write "temp/test.toml" {
        [arturo.package]
        name = "TOML Reader"
        description = "Yet another TOML Reader"
        version = "1.0.1"
        authors = ["author A", "author B"]
        license = "MIT"

        [arturo.config]
        version = "^0.9"
        pkg-manager = "^0.2"
    }

    ; action & assertion
    a: read.toml "temp/test.toml"
    inspect a

    ; cleaning
    execute "rm temp/* --recursive"

]

topic "read.toml -- from ini file"
do [

    ; preparing
    write "temp/test.ini" {
        [package]
        name = "TOML Reader"
        description = "Yet another TOML Reader"
        version = "1.0.1"
        authors = ["author A", "author B"]
        license = "MIT"

        [config]
        version = "^0.9"
        pkg-manager = "^0.2"
    }

    ; action & assertion
    a: read.toml "temp/test.ini"
    inspect a

    ; cleaning
    execute "rm temp/* --recursive"

]

;; How can I test it?
; topic "read.bytecode"
; do [
;
;     ; preparing
;
;     ; action & assertion
;     a: read.bytecode "temp/test.artc"
;     inspect a
;
;     ; cleaning
;     execute "rm temp/* --recursive"
;
; ]

topic "read.binary"
do [

    ; preparing
    write "temp/test.bin" {
        Hello, World!
    }

    ; action & assertion
    a: read.binary "temp/test.bin"
    inspect a

    ; cleaning
    execute "rm temp/* --recursive"

]

;; What is the difference from `read`?
topic "read.file"
do [

    ; action & assertion

    inspect read "temp/test.bin"
    ; temp/test.bin :string
    try? -> inspect read.file "temp/test.bin"
    else -> print "error raised!"
    ; >> Runtime | File: lib.files.art
    ; error | Line: 578
    ;       |
    ;       | file not found: temp/test.bin

    ; cleaning
    execute "rm temp/* --recursive"

]

; -- Test: rename

topic "rename"
do [

    ; preparing
    ; Using write because I can't redirect using `execute` function
    write "temp/file.txt" "Hello, world!"

    ; action
    rename "temp/file.txt" "temp/renamed.txt"

    ; assertion
    print execute "cat temp/renamed.txt"

    ; cleaning
    execute "rm temp/* --recursive"

]

topic "rename.directory"
do [

    ; preparing
    ; Using write because I can't redirect using `execute` function
    execute "mkdir temp/folder"

    ; action
    print execute "ls temp"
    rename.directory "temp/folder" "temp/directory"

    ; assertion
    print execute "ls temp"

    ; cleaning
    execute "rm temp/* --recursive"

]

; ; -- Test: symlink

;; How can I properly test it?
; topic "rename.directory"
; do [
;
;     ; cleaning
;     execute "rm temp/* --recursive"
;
; ]

; -- Test: timestamp

topic "timestamp"
do [

    ; preparing
    ; Using write because I can't redirect using `execute` function
    write "temp/file.txt" "Hello, world!"

    ; action & assertion
    a: timestamp "temp/file.txt"
    ensure -> a\created
    ensure -> a\accessed
    ensure -> a\modified
    print "assertions passed"

    ; cleaning
    execute "rm temp/* --recursive"

]

; -- Test: zip & unzip

;; Zip is writing an empty archive
; topic "delete.directory - with mixed folders"
; do [
;     ; preparing
;     execute "mkdir temp/folder{A,B,C}"
;     execute "mkdir temp/folder{A,B,C}/{A,B,C}"
;
;     ; Using write because I can't redirect using `execute` function
;     write "temp/folderA/A/file.txt" "Hello, world!"
;     write "temp/folderB/B/file.txt" "Hello, world!"
;     write "temp/folderC/C/file.txt" "Hello, world!"
;     write "temp/folderA/file.txt" "Hello, world!"
;     write "temp/file.txt" "Hello, world!"
;
;     ; 1st assertion
;     print execute "ls temp/**"
;
;     ; zip's assertion
;     print "Zipping..."
;     zip "temp/dest.zip" ["temp/file.txt" "temp/folderA" "temp/folderB" "temp/folderC"]
;     print execute "ls temp/**"
;
;     ; unzip's assertion
;     print "Unzipping..."
;     unzip "temp/" "temp/dest.zip"
;     print execute "ls temp/**"
;
;     ; cleaning
;     execute "rm temp/* --recursive"
; ]


; -- Test: volume

topic "volume"
do [

    ; preparing
    write "temp/test.bin" "Hello, World!"

    ; action & assertion
    print volume "temp/test.bin"

    ; cleaning
    execute "rm temp/* --recursive"

]

; -- Test: write

; -- exists?

; -- hidden?


; ---- Finish
execute "rmdir temp"
