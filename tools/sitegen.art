#!/usr/bin/env arturo

modules: []
functions: #[]
relatedFuncs: #[]

; get modules and functions

loop symbols [sym][
    print ["processing:" sym]
    inf: info.get sym

    if key? inf 'module [
        fun: inf\name
        lib: inf\module
        append 'modules lib
        if not? key? functions lib [
            set functions lib []
        ]
        set functions lib append (get functions lib) fun


        levD: 100
        related: new #[]
        loop symbols [sym2][
            inf2: info.get sym2

            if and? key? inf2 'module
                    inf <> inf2 [
                lib2: inf2\module
                lev: 100
                levA: (levenshtein sym sym2) * 3
                levB: levenshtein (inf\description) (inf2\description)
                set related new ~"|capitalize lib2|/|sym2|" min @[levA levB]
            ]
        ]
        ;inspect sort.values related
        set relatedFuncs sym first.n: 4 keys sort.values related
        ; inspect relatedFuncs
    ]
]

inspect relatedFuncs

unique 'modules

inspect functions

loop functions [modl,lst][
    target: relative join.path @["../docs/website/pages/documentation/library" lower modl]
    ; write.directory target Ã¸

    loop lst 'func [
        funcInfo:  info.get func
        if? funcInfo\type = :function [
            attributes: funcInfo\attrs
            arguments: funcInfo\args
            funcInfo: remove.key funcInfo 'attrs
            funcInfo: remove.key funcInfo 'args
            funcInfo\attributes: attributes
            funcInfo\arguments: arguments
        ]
        else [
            funcInfo\returns: @[funcInfo\type]
        ]
        funcInfo\related: get relatedFuncs func
        funcInfo: replace strip as.pretty.code.unwrapped funcInfo "\t" "    "

        inspect funcInfo
        
        print join.path @[target ~"|func|.art"]
        write join.path @[target ~{|replace func "?" "-"|.art}] funcInfo
    ]
]